<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<title>SpatiaLite SQL functions reference list</title>
		<style type="text/css">
			h2 {color:navy; text-align:center;} 
			h3 {color:blue;} 
			b {color:brown;}
			i {color:navy;}
		</style>
	</head><body bgcolor="#fffff0">
		<h2>SpatiaLite 5.0.0-devel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQL functions reference list</h2>
		<a href="https://www.gaia-gis.it/fossil/libspatialite">back</a>
		<ul>
			<li><a href="#version">SQL Version Info [and build options testing] functions</a></li>
			<li><a href="#generic">Generic SQL utility functions</a></li>
			<li><a href="#global">Global settings per connection</a></li>
			<li><a href="#sequence">SQL functions manipulating Sequences</a></li>
			<li><a href="#math">SQL math functions</a></li>
			<li><a href="#error">SQL functions reporting GEOS / RTTOPO errors and warnings</a></li>
			<li><a href="#length_cvt">SQL length/distance unit-conversion functions</a></li>
			<li><a href="#dms_cvt">SQL conversion functions from DD/DMS notations (longitude/latitude)</a></li>
			<li><a href="#blob">SQL utility functions for BLOB objects</a></li>
			<li><a href="#p0">SQL utility functions [non-standard] for geometric objects</a></li>
			<li><a href="#p1">SQL functions for constructing a geometric object given its Well-known Text Representation</a></li>
			<li><a href="#p2">SQL functions for constructing a geometric object given its Well-known Binary Representation</a></li>
			<li><a href="#p3">SQL functions for obtaining the Well-known Text / Well-known Binary Representation of a geometric object</a></li>
			<li><a href="#p3misc">SQL functions supporting exotic geometric formats</a></li>
			<li><a href="#p4">SQL functions on type Geometry</a></li>
			<li><a href="#repair">SQL functions attempting to repair malformed Geometries</a></li>
			<li><a href="#compress">SQL Geometry-compression functions</a></li>
			<li><a href="#cast">SQL Geometry-type casting functions</a></li>
			<li><a href="#dims-cast">SQL Space-dimensions casting functions</a></li>
			<li><a href="#p5">SQL functions on type Point</a></li>
			<li><a href="#p6">SQL functions on type Curve [Linestring or Ring]</a></li>
			<li><a href="#p7">SQL functions on type LineString</a></li>
			<li><a href="#p8">SQL functions on type Surface [Polygon or Ring]</a></li>
			<li><a href="#p9">SQL functions on type Polygon</a></li>
			<li><a href="#p10">SQL functions on type GeomCollection</a></li>
			<li><a href="#p11">SQL functions that test approximate spatial relationships via MBRs</a></li>
			<li><a href="#p12">SQL functions that test spatial relationships</a></li>
			<li><a href="#p13">SQL functions for distance relationships</a></li>
			<li><a href="#p14-">SQL functions supporting Linear Referencing</a></li>
			<li><a href="#p14">SQL functions that implement spatial operators</a></li>
			<li><a href="#p14b">SQL functions that implement spatial operators [GEOS specific features]</a></li>
			<li><a href="#p14c">SQL functions that implement spatial operators [GEOS advanced features]</a></li>
			<li><a href="#p14d">SQL functions that implement spatial operators [RTTOPO features]</a></li>
			<li><a href="#p14e">SQL functions supporting Geodesic Arcs</a></li>
			<li><a href="#p15">SQL functions for coordinate transformations</a></li>
			<li><a href="#p15plus">SQL functions supporting Affine Transformations and Ground Control Points</a></li>
			<li><a href="#p16">SQL functions for Spatial-MetaData and Spatial-Index handling</a></li>
			<li><a href="#p16metacatalog">SQL functions supporting the MetaCatalog and related Statistics</a></li>
			<li><a href="#p16style">SQL functions supporting SLD/SE Styled Layers</a></li>
			<li><a href="#p16isometa">SQL functions supporting ISO Metadata</a></li>
			<li><a href="#p16fdo">SQL functions implementing FDO/OGR compatibility</a></li>
			<li><a href="#p16gpkg">SQL functions implementing OGC GeoPackage compatibility</a></li>
			<li><a href="#p17">SQL functions for MbrCache-based queries</a></li>
			<li><a href="#p18">SQL functions for R*Tree-based queries (Geometry Callbacks)</a></li>
			<li><a href="#xmlBlob">SQL functions supporting XmlBLOB</a></li>
			<li><a href="#srid">SQL functions supporting SRID inspection</a></li>
			<li><a href="#topology">SQL functions supporting Topology-Geometry</a></li>
			<li><a href="#network">SQL functions supporting Topology-Network</a></li>
			<li><a href="#wms">SQL functions supporting WMS datasources</a></li>
			<li><a href="#datalic">SQL functions supporting Data Licenses</a></li>
			<li><a href="#advanced">miscellaneous advanced SQL functions</a></li>
			<li><a href="#sqlproc">SQL Procedures, Stored Procedures and Stored Variables related SQL functions</a></li>
		</ul>
		<table bgcolor="#e2eae2" border="1" cellpadding="2" cellspacing="2" width="100%">
			<tbody><tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="version">SQL Version Info [and build options testing] functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>spatialite_version</b></td>
				<td>spatialite_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>SpatiaLite</b> version as a text string</td></tr>
			<tr><td><b>spatialite_target_cpu</b></td>
				<td>spatialite_target_cpu( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>SpatiaLite</b> Target CPU as a text string</td></tr>
			<tr><td><b>freexl_version</b></td>
				<td>freexl_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>FreeXL</b> version as a text string<br>
					or NULL if FreeXL is currently unsupported</td></tr>
			<tr><td><b>proj4_version</b></td>
				<td>proj4_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>PROJ</b> version as a text string<br>
					or NULL if PROJ is currently unsupported</td></tr>
			<tr><td><b>geos_version</b></td>
				<td>geos_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>GEOS</b> version as a text string<br>
					or NULL if GEOS is currently unsupported</td></tr>
			<tr><td><b>rttopo_version</b></td>
				<td>rttopo_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>RTTOPO</b> version as a text string<br>
					or NULL if RTTOPO is currently unsupported</td></tr>
			<tr><td><b>libxml2_version</b></td>
				<td>libxml2_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>LibXML2</b> version as a text string<br>
					or NULL if LibXML2 is currently unsupported</td></tr>
			<tr><td><b>HasIconv</b></td>
				<td>HasIconv( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>ICONV</b></td></tr>
			<tr><td><b>HasMathSQL</b></td>
				<td>HasMathSQL( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>MATHSQL</b></td></tr>
			<tr><td><b>HasGeoCallbacks</b></td>
				<td>HasGeoCallbacks( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>GEOCALLBACKS</b></td></tr>
			<tr><td><b>HasProj</b></td>
				<td>HasProj( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>PROJ</b></td></tr>
			<tr><td><b>HasGeos</b></td>
				<td>HasGeos( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>GEOS</b></td></tr>
			<tr><td><b>HasGeosAdvanced</b></td>
				<td>HasGeosAdvanced( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>GEOSADVANCED</b></td></tr>
			<tr><td><b>HasGeosTrunk</b></td>
				<td>HasGeosTrunk( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>GEOSTRUNK</b></td></tr>
			<tr><td><b>HasGeosReentrant</b></td>
				<td>HasGeosReentrant( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>GEOSREENTRANT</b></td></tr>
			<tr><td><b>HasGeosOnlyReentrant</b></td>
				<td>HasGeosOnlyReentrant( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>GEOSONLYREENTRANT</b></td></tr>
			<tr><td><b>HasRtTopo</b></td>
				<td>HasRtTopo( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>RTTOPO</b></td></tr>
			<tr><td><b>HasLibXML2</b></td>
				<td>HasLibXML2( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>LibXML2</b></td></tr>
			<tr><td><b>HasEpsg</b></td>
				<td>HasEpsg( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>EPSG</b></td></tr>
			<tr><td><b>HasFreeXL</b></td>
				<td>HasFreeXL( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>FREEXL</b></td></tr>
			<tr><td><b>HasGeoPackage</b></td>
				<td>HasGeoPackage( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>GeoPackage</b> support (<b>GPKG</b>)</td></tr>
			<tr><td><b>HasGCP</b></td>
				<td>HasGCP( void ) : <i>Boolean</i><hr>
				    HasGroundControlPoints ( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>Ground Control Points</b> support (<b>GGP</b>)</td></tr>
			<tr><td><b>HasTopology</b></td>
				<td>HasTopology( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>Topology</b> (RTTOPO) support</td></tr>
			<tr><td><b>HasKNN</b></td>
				<td>HasKNN( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>VirtualKNN</b> (KNN) support</td></tr>
			<tr><td><b>HasRouting</b></td>
				<td>HasRouting( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlying library was built enabling <b>VirtualRouting</b> support</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="generic">Generic SQL functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>	
			<tr><td><b>IsInteger</b></td>
				<td>IsInteger( value <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Checks a TEXT string testing if it corresponds to an Integer Number.<br>
				The function returns <b>1</b> if <b>TRUE</b> and <b>0</b> if <b>FALSE</b>; <b>-1</b> is returned when the argument is not a Text string.<hr>
				Examples of valid Integer strings:
				<ul>
					<li><b>'1234'</b></li>
					<li><b>'+5678'</b></li>
					<li><b>'-4321'</b></li>
					<li><b>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+12345678'</b></li>
				</ul></td></tr>
			<tr><td><b>IsDecimalNumber</b></td>
				<td>IsDecimalNumber( value <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Checks a TEXT string testing if it corresponds to a Decimal Number.<br>
				The function returns <b>1</b> if <b>TRUE</b> and <b>0</b> if <b>FALSE</b>; <b>-1</b> is returned when the argument is not a Text string.<hr>
				Examples of valid Decimal Number strings:
				<ul>
					<li><b>'1234.56'</b></li>
					<li><b>'+5678.09'</b></li>
					<li><b>'-4321.67'</b></li>
					<li><b>'-4321.67e12'</b></li>
					<li><b>'6789.123E+6'</b></li>
					<li><b>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1234.56e-6'</b></li>
				</ul></td></tr>
			<tr><td><b>IsNumber</b></td>
				<td>IsNumber( value <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Checks a TEXT string testing if it corresponds to a Number.<br>
				The function returns <b>1</b> if <b>TRUE</b> and <b>0</b> if <b>FALSE</b>; <b>-1</b> is returned when the argument is not a Text string.<hr>
				convenience predicate: same as <b>IsInteger(value) OR IsDecimalNumber(value)</b>.</td></tr>
			<tr><td><b>CastToInteger</b></td>
				<td>CastToInteger( value <i>Generic</i> ) : <i>Integer</i></td>
				<td colspan="3">returns the intput value possibly casted to the Integer data-type; NULL if no conversion is possible.</td></tr>
			<tr><td><b>CastToDouble</b></td>
				<td>CastToDouble( value <i>Generic</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the intput value possibly casted to the Double data-type; NULL if no conversion is possible.</td></tr>
			<tr><td><b>CastToText</b></td>
				<td>CastToText( value <i>Generic</i> ) : <i>Text</i><hr>
				CastToText( value <i>Generic</i> , zero_pad <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">returns the intput value possibly casted to the Text data-type; NULL if no conversion is possible.<br>
				If an optional argument <b>zero_pad</b> is passed and the input value is of the Integer or Double type, then the returned string will be padded using as many trailing ZEROs needed to ensure the required length.</td></tr>
			<tr><td><b>CastToBlob</b></td>
				<td>CastToBlob( value <i>Generic</i> ) : <i>Blob</i><hr>
                                CastToBlob( value <i>Generic</i> , hex_input <i>Boolean</i> ) : <i>Blob</i></td>
				<td colspan="3">returns the intput value possibly casted to the BLOB data-type:
                                if the optional argument <b>hex_input</b> is set to <b>TRUE</b> the input value will be expected to correspond to an HexaDecimal string, e.g. <b>01ab89EF</b>; if this conversion fails then NULL will be returned.<hr>
                                returns NULL if no conversion is possible.</td></tr>
			<tr><td><b>ForceAsNull</b></td>
				<td>ForceAsNull( val1 <i>Generic</i> , val2 <i>Generic</i>) : <i>Generic</i></td>
				<td colspan="3">if <b>val1</b> and <b>val2</b> are equal (and of the same data-type) NULL will be returned; 
				otherwise <b>val1</b> will be returned unchanged, preserving its original data-type.</td></tr>
			<tr><td><b>CreateUUID</b></td>
				<td>CreateUUID( void ) : <i>Text</i></td>
				<td colspan="3">returns a Version 4 (random) UUID (<a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">Universally unique identifier</a>).</td></tr>
			<tr><td><b>MD5Checksum</b></td>
				<td>MD5Checksum( BLOB | TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the <a href="http://en.wikipedia.org/wiki/MD5">MD5 checksum</a> corresponding to the input value.<br>Will return <b>NULL</b> for non-BLOB or non-TEXT input.</td></tr>
			<tr><td><b>MD5TotalChecksum</b></td>
				<td>MD5TotalChecksum( BLOB | TEXT ) : <i>Text</i></td>
				<td colspan="3">returns a cumulative MD5 checksum.<br><b><u>aggregate function</u></b></td></tr>
			<tr><td><b>EncodeURL</b></td>
				<td>EncodeURL( url <i>Text</i> ) : <i>Text</i><hr>
					EncodeURL( url <i>Text</i> , charset <i>Text</i> ) : <i>Text</i></td>
				<td colspan="3">returns the <a href="http://en.wikipedia.org/wiki/Percent-encoding">percent encoded URL</a> corresponding to the input value.<br>Will return <b>NULL</b> for invalid input.
					<ul>
						<li>the <u>input URL</u> is always assumed to be an <b>UTF-8</b> string.</li>
						<li>the <u>output URL</u> will be converted into the charset encoding specified by the <b>charset</b> argument.<br>
							if not specified <b>UTF-8</b> will be assumed by default.</li>
					</ul></td></tr>
			<tr><td><b>DecodeURL</b></td>
				<td>DecodeURL( url <i>Text</i> ) : <i>Text</i><hr>
					DecodeURL( url <i>Text</i>, charset <i>Text</i> ) : <i>Text</i></td>
				<td colspan="3">returns a plain URL from its corresponding percent encoding.<br>Will return <b>NULL</b> for invalid input.
					<ul>
						<li>the <u>output URL</u> will be always returned as an <b>UTF-8</b> string.</li>
						<li>the <u>input URL</u> will be converted from the charset encoding specified by the <b>charset</b> argument.<br>
							if not specified <b>UTF-8</b> will be assumed by default.</li>
					</ul></td></tr>
			<tr><td><b>DirNameFromPath</b></td>
				<td>DirNameFromPath( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the Directory Name from a relative or absolute Pathname.<br>Will return <b>NULL</b> for invalid input of for any simple path lacking a Directory.</td></tr>
			<tr><td><b>FullFileNameFromPath</b></td>
				<td>FullFileNameFromPath( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the Full File Name (including an eventual File Extension) from a relative or absolute Pathname.<br>Will return <b>NULL</b> for invalid input of for any path
				 lacking a File Name.</td></tr>
			<tr><td><b>FileNameFromPath</b></td>
				<td>FileNameFromPath( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the File Name (excluding an eventual File Extension) from a relative or absolute Pathname.<br>Will return <b>NULL</b> for invalid input of for any path
				 lacking a File Name.</td></tr>
			<tr><td><b>FileExtFromPath</b></td>
				<td>FileExtFromPath( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the File Extension from a relative or absolute Pathname.<br>Will return <b>NULL</b> for invalid input of for any path
				 lacking a File Name or when no Extension is present.</td></tr>
			<tr><td><b>MakeStringList</b></td>
				<td>MakeStringList( value ) : <i>Text</i><hr>
				    MakeStringList( value , delimiter <i>text</i>) : <i>Text</i></td>
				<td colspan="3">returns a comma-delimited list of integer or text values.<br>
				the optional argument <b>delimiter</b> can be used so to specify an alternative delimiter different from comma.<br>
				<b><u>aggregate function</u></b><hr>
				Will return <b>NULL</b> for invalid arguments.</td></tr>
			<tr><td><b>eval</b></td>
				<td>eval( X <i>TEXT</i> [ , Y <i>TEXT</i> ) : <i>Text</i></td>
				<td colspan="3">Evaluate the SQL text in <b>X</b>.  Return the results, using string <b>Y</b> as the separator.<br>
				If <b>Y</b> is omitted, use a single space character.<hr>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>PostgreSQL_GetLastError</b></td>
				<td>PostgreSQL_GetLastError() : <i>Text</i></td>
				<td colspan="3">returns the most recent error message raised by PostgreSQL.<br>
				<b>NULL</b> if there is no pending error message available.</td></tr>
			<tr><td><b>PostgreSQL_ResetLastError</b></td>
				<td>PostgreSQL_ResetLastError() : <i>Integer</i></td>
				<td colspan="3">Resets the most recent error message raised by PostgreSQL.<br>
				Returns <b>1</b> on success and <b>0</b> on failure.<hr>
				Only intended for internal usage by the <b>VirtualPostgres</b> extension module.</td></tr>
			<tr><td><b>PostgreSQL_SetLastError</b></td>
				<td>PostgreSQL_SetLastError( <i>TEXT</i> ) : <i>Integer</i></td>
				<td colspan="3">Permanently sets the most recent error message raised by PostgreSQL.<br>
				Returns <b>1</b> on success and <b>0</b> on failure; <b>-1</b> if the argument is not a Text string.<hr>
				Only intended for internal usage by the <b>VirtualPostgres</b> extension module.</td></tr>
            <tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="global">Global settings per connection</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>EnableGpkgMode</b></td>
				<td>EnableGpkgMode( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Enables the <b>Geopackage mode</b><br>
				All connections are initially started with a disabled GPKG mode, that must be explicitly enabled whenever required.<br>
				Enabling GPKG mode is a supported option only if the currently connected DB-file presents a GPKG layout.</td></tr>
			<tr><td><b>DisableGpkgMode</b></td>
				<td>DisableGpkgMode( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Disables the <b>Geopackage mode</b></td></tr>
			<tr><td><b>GetGpkgMode</b></td>
				<td>GetGpkgMode( <i>void</i> ) : <i>boolean</i></td>
				<td colspan="3">Returns <b>TRUE</b> if the <b>Geopackage mode</b> is currently enabled, otherwise <b>FALSE</b></td></tr>
			<tr><td><b>EnableGpkgAmphibiousMode</b></td>
				<td>EnableGpkgAmphibiousMode( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Enables the <b>Geopackage amphibious mode</b><br>
				All connections are initially started with a disabled amphibious mode, that must be explicitly enabled whenever required.<br>
				<u>Note</u>: <i>GPKG mode</i> and <i>GPKG amphibious mode</i> are mutually exclusive options.</td></tr>
			<tr><td><b>DisableGpkgAmphibiousMode</b></td>
				<td>DisableGpkgAmphibiousMode( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Disables the <b>Geopackage amphibious mode</b></td></tr>
			<tr><td><b>GetGpkgAmphibiousMode</b></td>
				<td>GetGpkgAmphibiousMode( <i>void</i> ) : <i>boolean</i></td>
				<td colspan="3">Returns <b>TRUE</b> if the <b>Geopackage amphibious mode</b> is currently enabled, otherwise <b>FALSE</b></td></tr>
			<tr><td><b>SetDecimalPrecision</b></td>
				<td>SetDecimalPrecision( <i>integer</i> ) : <i>void</i></td>
				<td colspan="3">Explicitly sets the number of decimal digits (<i>precision</i>) to be displayed by <b>ST_AsText()</b> for coordinate values: the standard default setting is <b>6</b> decimal digits.<br>
				Passing any <b>negative</b> precision will automatically restore the initial default setting.<br>
				The <b>spatialite_gui</b> tool will honor this setting for all floating point values to be displayed on the screen.</td></tr>
			<tr><td><b>GetDecimalPrecision</b></td>
				<td>GetDecimalPrecision( <i>void</i> ) : <i>integer</i></td>
				<td colspan="3">Returns the currently set <b>decimal precision</b>.<br>
				A <b>negative</b> precision identifies the default setting.</td></tr>
			<tr><td><b>EnableTinyPoint</b></td>
				<td>EnableTinyPoint( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Enables the <b>TinyPoint</b> BLOB encoding for all Point-Geometries being created.<br>
				All connections are initially started with a disabled TinyPoint BLOB encoding, that must be explicitly enabled whenever required.<br><hr>
				<u>Exception</u>: if the environment variable <b>SPATIALITE_TINYPOINT=1</b> is set, then all connections will initially start by enabling the TinyPoint BLOB encoding.</td></tr>
			<tr><td><b>DisableTinyPoint</b></td>
				<td>DisableTinyPoint( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Disables the <b>TinyPoint</b> BLOB encoding; all Point-Geometries will then be created applying the classic BLOB-Geometry encoding.</td></tr>
			<tr><td><b>IsTinyPointEnabled</b></td>
				<td>IsTinyPointEnabled( <i>void</i> ) : <i>boolean</i></td>
				<td colspan="3">Returns <b>TRUE</b> if the <b>TinyPoint</b> BLOB encoding is currently enabled, otherwise <b>FALSE</b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="sequence">SQL functions manipulating Sequences</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>sequence_nextval</b></td>
				<td>sequence_nextval ( seq_name <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">advances to the next value of the Sequence, which is then returned.<br>
					Will return <b>NULL</b> if any error occurred.</td></tr>
			<tr><td><b>sequence_currval</b></td>
				<td>sequence_currval ( seq_name <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">returns the value most recently obtained by <b>sequence_nextval()</b> for the Sequence identified by <i>seq_name</i><br>
					Will return <b>NULL</b> if the Sequence identified by <i>seq_name</i> has not yet been used.</td></tr>
			<tr><td><b>sequence_lastval</b></td>
				<td>sequence_lastval ( <i>void</i> ) : <i>Integer</i></td>
				<td colspan="3">returns the value most recently obtained by <b>sequence_nextval()</b><br>
					Will return <b>NULL</b> if <b>sequence_nextval()</b> has not yet been used.</td></tr>
			<tr><td><b>sequence_setval</b></td>
				<td>sequence_setval ( seq_name <i>Text</i> , value <i>Integer</i> ) : <i>Integer</i></td>
				<td colspan="3">sets the current <i>value</i> for the Sequence identified by <b>seq_name</b>; if the Sequence doesn't yet exist it will be created on-the-fly.<br>
					Will return <i>value</i> on success or <b>NULL</b> on failure.</td></tr>				
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="math">SQL math functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Abs</b></td>
				<td>Abs( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the absolute value of <b>x</b></td></tr>
			<tr><td><b>Acos</b></td>
				<td>Acos( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the arc cosine of <b>x</b>, that is, the value whose cosine is <b>x</b><br>
				returns NULL if <b>x</b> is not within the range -1 to 1</td></tr>
			<tr><td><b>Asin</b></td>
				<td>Asin( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the arc sine of <b>x</b>, that is, the value whose sine is <b>x</b><br>
				returns NULL if <b>x</b> is not in the range -1 to 1</td></tr>
			<tr><td><b>Atan</b></td>
				<td>Atan( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the arc tangent of <b>x</b>, that is, the value whose tangent is <b>x</b></td></tr>
			<tr><td><b>Atan2</b></td>
				<td>Atan2( y <i>Double precision</i> , x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the principal value of the arc tangent of <b>y/x</b> in radians, using the signs of the two
				arguments to determine the quadrant of the result. The return value is in the range[<b>-pi</b>, <b>pi</b>].</td></tr>
			<tr><td><b>Ceil<br>Ceiling</b></td>
				<td>Ceil( x <i>Double precision</i> ) : <i>Double precision</i><hr>
				Ceiling( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the smallest integer value not less than <b>x</b></td></tr>
			<tr><td><b>Cos</b></td>
				<td>Cos( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the cosine of <b>x</b>, where <b>x</b> is given in <u>radians</u></td></tr>
			<tr><td><b>Cot</b></td>
				<td>Cot( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the cotangent of <b>x</b>, where <b>x</b> is given in <u>radians</u></td></tr>
			<tr><td><b>Degrees</b></td>
				<td>Degrees( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the argument <b>x</b>, converted from radians to degrees</td></tr>
			<tr><td><b>Exp</b></td>
				<td>Exp( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the value of <b><i>e</i></b> (the base of natural logarithms) raised to the power of <b>x</b><hr>
				the inverse of this function is <b>Log()</b> (using a single argument only) or <b>Ln()</b></td></tr>
			<tr><td><b>Floor</b></td>
				<td>Floor( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the largest integer value not greater than <b>x</b></td></tr>
			<tr><td><b>Ln</b><br><b>Log</b></td>
				<td>Ln( x <i>Double precision</i> ) : <i>Double precision</i><hr>
				Log( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the natural logarithm of <b>x</b>; that is, the base-<b><i>e</i></b> logarithm of <b>x</b><br>
				If <b>x</b> is less than or equal to 0, then NULL is returned</td></tr>
			<tr><td><b>Log</b></td>
				<td>Log( x <i>Double precision</i> , b <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the logarithm of <b>x</b> to the base <b>b</b><br>
				If <b>x</b> is less than or equal to 0, or if <b>b</b> is less than or equal to 1, then NULL is returned<hr>
				<b>Log(x, b)</b>  is equivalent to <b>Log(x)</b> / <b>Log(b)</b></td></tr>
			<tr><td><b>Log2</b></td>
				<td>Log2( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the base-2 logarithm of <b>x</b><hr>
				<b>Log2(x)</b>  is equivalent to <b>Log(x)</b> / <b>Log(2)</b></td></tr>
			<tr><td><b>Log10</b></td>
				<td>Log10( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the base-10 logarithm of <b>x</b><hr>
				<b>Log10(x)</b>  is equivalent to <b>Log(x)</b> / <b>Log(10)</b></td></tr>
			<tr><td><b>PI</b></td>
				<td>PI( void ) : <i>Double precision</i></td>
				<td colspan="3">returns the value of <b>PI</b></td></tr>
			<tr><td><b>Pow</b><br><b>Power</b></td>
				<td>Pow( x <i>Double precision</i> , y <i>Double precision</i> ) : <i>Double precision</i><hr>
				Power( x <i>Double precision</i> , y <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the value of <b>x</b> raised to the power of <b>y</b></td></tr>
			<tr><td><b>Radians</b></td>
				<td>Radians( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the argument <b>x</b>, converted from degrees to radians</td></tr>
			<tr><td><b>Sign</b></td>
				<td>Sign( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the sign of the argument as -1, 0, or 1, 
				depending on whether <b>x</b> is negative, zero, or positive. </td></tr>
			<tr><td><b>Sin</b></td>
				<td>Sin( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the sine of <b>x</b>, where <b>x</b> is given in <u>radians</u></td></tr>
			<tr><td><b>Sqrt</b></td>
				<td>Sqrt( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the square root of a non-negative number <b>x</b></td></tr>
			<tr><td><b>Stddev_pop</b></td>
				<td>Stddev_pop( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the population standard deviation of the input values<br><b><u>aggregate function</u></b></td></tr>
			<tr><td><b>Stddev_samp</b></td>
				<td>Stddev_samp( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the sample standard deviation of the input values<br><b><u>aggregate function</u></b></td></tr>
			<tr><td><b>Tan</b></td>
				<td>Tan( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the tangent of <b>x</b>, where <b>x</b> is given in <u>radians</u></td></tr>
			<tr><td><b>Var_pop</b></td>
				<td>Var_pop( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the population variance of the input values (<i>square of the population standard deviation</i>)<br>
				<b><u>aggregate function</u></b></td></tr>
			<tr><td><b>Var_samp</b></td>
				<td>Var_samp( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the sample variance of the input values (<i>square of the sample standard deviation</i>)<br>
				<b><u>aggregate function</u></b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="error">SQL functions reporting GEOS / RTTOPO errors and warnings</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>GEOS_GetLastWarningMsg</b></td>
				<td>GEOS_GetLastWarningMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td colspan="2">Will return the most recent warning message returned by GEOS (if any).<hr>
				<b>NULL</b> will be returned if there is no pending GEOS warning.</td></tr>
			<tr><td><b>GEOS_GetLastErrorMsg</b></td>
				<td>GEOS_GetLastErrorMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td colspan="2">Will return the most recent error message returned by GEOS (if any).<hr>
				<b>NULL</b> will be returned if there is no pending GEOS error.</td></tr>
			<tr><td><b>GEOS_GetLastAuxErrorMsg</b></td>
				<td>GEOS_GetLastAuxErrorMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td colspan="2">Will return the most recent error message (auxiliary) returned by GEOS (if any).<hr>
				<b>NULL</b> will be returned if there is no pending GEOS (auxiliary) error.</td></tr>
			<tr><td><b>GEOS_GetCriticalPointFromMsg</b></td>
				<td>GEOS_GetCriticalPointFromMsg( <i>void</i> ) : <i>Point</i><hr>
				GEOS_GetCriticalPointFromMsg( SRID <i>Integer</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td colspan="2">Will (possibly) return a Point Geometry extracted from the latest error / warning
				message returned by GEOS.<hr>
				<b>NULL</b> will be returned if there is no pending GEOS message, or if the current GEOS message
				doesn't contain a critical Point.</td></tr>
			<tr><td><b>RTTOPO_GetLastWarningMsg</b></td>
				<td>RTTOPO_GetLastWarningMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="2">Will return the most recent warning message returned by RTTOPO (if any).<hr>
				<b>NULL</b> will be returned if there is no pending RTTOPO warning.</td></tr>
			<tr><td><b>RTTOPO_GetLastErrorMsg</b></td>
				<td>RTTOPO_GetLastErrorMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="2">Will return the most recent error message returned by RTTOPO (if any).<hr>
				<b>NULL</b> will be returned if there is no pending RTTOPO error.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="length_cvt">SQL length/distance unit-conversion functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Kilometer</b></td>
				<td>CvtToKm( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromKm( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>kilometers</b></td></tr>
			<tr><td><b>Decimeter</b></td>
				<td>CvtToDm( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromDm( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>decimeters</b></td></tr>
			<tr><td><b>Centimeter</b></td>
				<td>CvtToCm( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromCm( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>centimeters</b></td></tr>
			<tr><td><b>Millimeter</b></td>
				<td>CvtToMm( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromMm( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>millimeters</b></td></tr>
			<tr><td><b>International Nautical Mile</b></td>
				<td>CvtToKmi( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromKmi( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international nautical miles</b></td></tr>
			<tr><td><b>International Inch</b></td>
				<td>CvtToIn( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromIn( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international inches</b></td></tr>
			<tr><td><b>International Foot</b></td>
				<td>CvtToFt( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromFt( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international feet</b></td></tr>
			<tr><td><b>International Yard</b></td>
				<td>CvtToYd( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromYd( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international yards</b></td></tr>
			<tr><td><b>International Statute Mile</b></td>
				<td>CvtToMi( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromMi( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international statute miles</b></td></tr>
			<tr><td><b>International Fathom</b></td>
				<td>CvtToFath( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromFath( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international fathoms</b></td></tr>
			<tr><td><b>International Chain</b></td>
				<td>CvtToCh( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromCh( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international chains</b></td></tr>
			<tr><td><b>International Link</b></td>
				<td>CvtToLink( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromLink( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international links</b></td></tr>
			<tr><td><b>U.S. Inch</b></td>
				<td>CvtToUsIn( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsIn( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. inches</b></td></tr>
			<tr><td><b>U.S. Foot</b></td>
				<td>CvtToUsFt( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsFt( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. feet</b></td></tr>
			<tr><td><b>U.S. Yard</b></td>
				<td>CvtToUsYd( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsYd( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. yards</b></td></tr>
			<tr><td><b>U.S. Statute Mile</b></td>
				<td>CvtToUsMi( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsMi( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. statute miles</b></td></tr>
			<tr><td><b>U.S. Chain</b></td>
				<td>CvtToUsCh( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsCh( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. chains</b></td></tr>
			<tr><td><b>Indian Foot</b></td>
				<td>CvtToIndFt( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromIndFt( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>indian feet</b></td></tr>
			<tr><td><b>Indian Yard</b></td>
				<td>CvtToIndYd( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromIndYd( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>indian yards</b></td></tr>
			<tr><td><b>Indian Chain</b></td>
				<td>CvtToIndCh( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromIndCh( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>indian chains</b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="dms_cvt">SQL conversion functions from DD/DMS notations (longitude/latitude)</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>DD to DMS</b></td>
				<td>LongLatToDMS( longitude <i>Double precision</i> , latitude <i>Double precision</i> ) : <i>String</i></td>
				<td colspan="3">will return a DMS string (Degrees, Minutes and Seconds) using the given DD (Decimal Degrees) input coordinates<hr>
                                <b>NULL</b> will be returned on invalid input.</tr>
			<tr><td><b>DMS to DD</b></td>
				<td>LongitudeFromDMS( dms_expression <i>String</i> ) : <i>Double precision</i><hr>
                                    LatitudeFromDMS( dms_expression <i>String</i> ) : <i>Double precision</i></td>
				<td colspan="3">will return the DD coordinates from within a DMS expression, which must contain both the Latitude and Longitude (in that order)<hr>
                                <b>NULL</b> will be returned on invalid input.</tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="blob">SQL utility functions for BLOB objects</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>IsZipBlob</b></td>
				<td>IsZipBlob( content <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid ZIP-compressed file</td></tr>
			<tr><td><b>IsPdfBlob</b></td>
				<td>IsPdfBlob( content <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid PDF document</td></tr>
			<tr><td><b>IsGifBlob</b></td>
				<td>IsGifBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid GIF image</td></tr>
			<tr><td><b>IsPngBlob</b></td>
				<td>IsPngBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid PNG image</td></tr>
			<tr><td><b>IsTiffBlob</b></td>
				<td>IsTiffBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid TIFF image</td></tr>
			<tr><td><b>IsJpegBlob</b></td>
				<td>IsJpegBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid JPEG image</td></tr>
			<tr><td><b>IsExifBlob</b></td>
				<td>IsExifBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid EXIF image<br>
					<u>Please note:</u> any valid EXIF image is also a valid JPEG</td></tr>
			<tr><td><b>IsExifGpsBlob</b></td>
				<td>IsExifGpsBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid EXIF-GPS image<br>
					<u>Please note:</u> any valid EXIF-GPS image is a valid EXIF and JPEG as well</td></tr>
			<tr><td><b>IsWebpBlob</b></td>
				<td>IsWebpBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid WebP image</td></tr>
			<tr><td><b>IsJP2Blob</b></td>
				<td>IsJP2Blob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid JP2 [Jpeg2000] image</td></tr>
			<tr><td><b>GetMimeType</b></td>
				<td>GetMimeType( payload <i>BLOB</i> ) : <i>String</i></td>
				<td colspan="3">The return type is Text, and could be one of: <b>image/gif</b>, <b>image/png</b>,
					<b>image/jpeg</b>, <b>image/jp2</b>, <b>image/tiff</b>, <b>image/svg+xml</b>, <b>application/xml</b>,
					<b>application/zip</b>,	<b>application/pdf</b>.<br>
					NULL will be returned when called with a NULL or non-BLOB argument, or if no valid mime-type is detected.</td></tr>
			<tr><td><b>IsGeometryBlob</b></td>
				<td>IsGeometryBlob( content <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if the BLOB argument is a valid BLOB-Geometry.</td></tr>
			<tr><td><b>IsTinyPointBlob</b></td>
				<td>IsTinyPointBlob( content <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL or non-BLOB argument.<hr>
					TRUE if the BLOB argument is a valid BLOB-TinyPoint.</td></tr>
			<tr><td><b>TinyPointEncode</b></td>
				<td>TinyPointEncode( content <i>POINT BLOB-GEOMETRY</i> ) : <i>BLOB-TinyPoint</i></td>
				<td colspan="3">If the input argument corresponds to a valid <b>BLOB-GEOMETRY</b> of the <b>POINT</b>, <b>POINT Z</b>, <b>POINT M</b> or <b>POINT ZM</b> type 
				    the corresponding <b>BLOB-TinyPoint</b> will be returned.<hr>
					In any other case the input argument will be retuned.</td></tr>
			<tr><td><b>GeometryPointEncode</b></td>
				<td>GeometryPointEncode( content <i>BLOB-TinyPoint</i> ) : <i>BLOB-GEOMETRY</i></td>
				<td colspan="3">If the input argument corresponds to a valid <b>BLOB-TinyPoint</b> the corresponding <b>BLOB-GEOMETRY</b> will be returned.<hr>
					In any other case the input argument will be retuned.</td></tr>
			<tr><td><b>BlobFromFile</b></td>
				<td>BlobFromFile( filepath <i>String</i> ) : <i>BLOB</i></td>
				<td colspan="3">If the filepath is valid, and the existing file can be successfully read, then the whole file content will be returned as a
					BLOB value.<br>
					Otherwise NULL will be returned.<br>
					<u>Please note:</u> SQLite doesn't support BLOB values bigger than SQLITE_MAX_LENGTH (usually, 1 GB).<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is required in order to use this function.</td></tr>
			<tr><td><b>BlobToFile</b></td>
				<td>BlobToFile( binary-data <i>BLOB</i> , filepath <i>String</i> ) : <i>Integer</i></td>
				<td colspan="3">If <i>binary-data</i> is of the BLOB-type, and the filepath is valid (i.e. accessible in write/create mode), 
					then the corresponding file will be created/overwritten with the binary-data.<br>
					The return type is Integer, with a return value of 1 for success, 0 for failure.<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is required in order to use this function.</td></tr>
			<tr><td><b>CountUnsafeTriggers</b></td>
				<td>CountUnsafeTriggers( ) : <i>Integer</i></td>
				<td colspan="3">This SQL function checks if the currently connected DB contains any potentially malicious Triggers;
					carefully checking this conditions is a minimal precaution expected to be always verified before eventually activating the <b>SPATIALITE_SECURITY=relaxed</b> mode.<hr>
					The return type is Integer (total count of suspected Triggers); 0 means that the currently connected DB should be considered absolutely safe.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p0">SQL utility functions [<i>non-standard</i>] for geometric objects</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>GeomFromExifGpsBlob</b></td>
				<td>GeomFromExifGpsBlob( image <i>BLOB</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a POINT Geometry will be returned representing the GPS long/lat contained within EXIF-GPS <i>metadata</i>
				for the BLOB image<hr>
				NULL will be returned if for any reason it's not possible to create such a POINT</td></tr>
			<tr><td><b>ST_Point</b></td>
				<td>ST_Point( x <i>Double precision</i> , y <i>Double precision</i>  ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>simply an alias-name for <b>MakePoint()</b><br>
				<u>Please note</u>: the <u>SRID</u> argument is never supported by <u>ST_Point()</u></td></tr>
			<tr><td><b>MakePoint</b></td>
				<td>MakePoint( x <i>Double precision</i> , y <i>Double precision</i> ,
				[ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry will be returned representing the POINT defined by [<b>x y</b>] coordinates</td></tr>
			<tr><td><b>MakePointZ</b></td>
				<td>MakePointZ( x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> ,
				[ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry will be returned representing the POINT Z defined by [<b>x y z</b>] coordinates</td></tr>
			<tr><td><b>MakePointM</b></td>
				<td>MakePointM( x <i>Double precision</i> , y <i>Double precision</i> , m <i>Double precision</i> ,
				[ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry will be returned representing the POINT M defined by [<b>x y m</b>] coordinates</td></tr>
			<tr><td><b>MakePointZM</b></td>
				<td>MakePointZM( x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> ,
				m <i>Double precision</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry will be returned representing the POINT ZM defined by [<b>x y z m</b>] coordinates</td></tr>
			<tr><td><b>MakeLine</b></td>
				<td>MakeLine( pt1 <i>PointGeometry</i> , pt2 <i>PointGeometry</i> ) : <i>LinestringGeometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Linestring Geometry will be returned representing the segment connecting <b>pt1</b> to <b>pt2</b><hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>MakeLine</b></td>
				<td>MakeLine( geom <i>PointGeometry</i> ) : <i>LinestringGeometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Linestring Geometry will be returned connecting all the input Points (accordingly to input sequence)<br>
				<b><u>aggregate function</u></b><hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>MakeLine</b></td>
				<td>MakeLine( geom <i>MultiPointGeometry</i> , direction <i>Boolean</i> ) : <i>LinestringGeometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Linestring Geometry will be returned connecting all the input Points (accordingly to input sequence); <b>direction=FALSE</b> implies <u>reverse order</u>.<br>
				<u>Please note</u>: similar to the previuous one, but this one is an ordinary (not aggregate) function; a MultiPoint input is always expected.<hr>
				NULL will be returned if any error is encountered</td></tr>
                        <tr><td><b>MakeCircle</b></td>
				<td>MakeCircle( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				radius <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a closed LINESTRING approximating the Circle defined by <b>cx, cy</b> and <b>radius</b>.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the circumference; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeEllipse</b></td>
				<td>MakeEllipse( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				x_axis <i>Double precision</i> , y_axis <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a closed LINESTRING approximating the Ellipse defined by <b>cx, cy</b> and <b>x_axis, y_axis</b>.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the ellipse; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeArc</b></td>
				<td>MakeArc( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				radius <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a LINESTRING approximating the Circular Arc defined by <b>cx, cy</b> and <b>radius</b>; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the circumference; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeEllipticArc</b></td>
				<td>MakeEllipticArc( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				x_axis <i>Double precision</i> , y_axis <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a LINESTRING approximating the Elliptic Arc defined by <b>cx, cy</b> and <b>x_axis, y_axis</b>; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the ellipse; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeCircularSector</b></td>
				<td>MakeCircularSector( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				radius <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a POLYGON approximating the Circular Sector defined by <b>cx, cy</b> and <b>radius</b>; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the circumference; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeEllipticSector</b></td>
				<td>MakeEllipticSector( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				x_axis <i>Double precision</i> , y_axis <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a POLYGON approximating the Elliptic Sector defined by <b>cx, cy</b> and <b>x_axis, y_axis</b>; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the ellipse; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeCircularStripe</b></td>
				<td>MakeCircularStripe( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				radius_1 <i>Double precision</i> , radius_2 <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a POLYGON approximating the Circular Stripe delimited by two arcs sharing the same Centre [<b>cx</b>, <b>cy</b>]
                                but having different radii [<b>radius_1</b>, <b>radius_2</b>]; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the circumference; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
			<tr><td><b>SquareGrid</b></td>
				<td>SquareGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , mode <i>Integer</i> , [ origin <i>PointGeometry</i> ] ] ) : <i>Geometry</i><hr>
                                    ST_SquareGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , mode <i>Integer</i> , [ origin <i>PointGeometry</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a grid of square cells (having the edge length of <i>size</i>) precisely covering the input Geometry.<br>
                                The specific Type of returned Geometry is controlled by the <b>mode</b> attribute value:
                                <ul>
									<li>any <i>positive</i> value will cause a <b>MultiLinestring</b> to be returned.</li>
									<li><i>zero</i> (default value) will cause a <b>MultiPolygon</b> to be returned.</li>
									<li>any <i>negative</i> value will cause a <b>MultiPoint</b> to be returned.</li>
                                </ul>
                                If the optional <b>origin</b> argument (expected to be a Point) is not specified then the (0,0) grid origin will be assumed by default.<hr>
				NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>TriangularGrid</b></td>
				<td>TriangularGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , mode <i>Integer</i> , [ origin <i>PointGeometry</i> ] ] ) : <i>Geometry</i><hr>
                                    ST_TriangularGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , mode <i>Integer</i> , [ origin <i>PointGeometry</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a grid of triangular cells (having the edge length of <i>size</i>) precisely covering the input Geometry.<br>
                                The specific Type of returned Geometry is controlled by the <b>mode</b> attribute value:
                                <ul>
									<li>any <i>positive</i> value will cause a <b>MultiLinestring</b> to be returned.</li>
									<li><i>zero</i> (default value) will cause a <b>MultiPolygon</b> to be returned.</li>
									<li>any <i>negative</i> value will cause a <b>MultiPoint</b> to be returned.</li>
                                </ul>
                                If the optional <b>origin</b> argument (expected to be a Point) is not specified then the (0,0) grid origin will be assumed by default.<hr>
				NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>HexagonalGrid</b></td>
				<td>HexagonalGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , mode <i>Integer</i> , [ origin <i>PointGeometry</i> ] ] ) : <i>Geometry</i><hr>
                                    ST_HexagonalGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , mode <i>Integer</i> , [ origin <i>PointGeometry</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a grid of hexagonal cells (having the edge length of <i>size</i>) precisely covering the input Geometry.<br>
                                The specific Type of returned Geometry is controlled by the <b>mode</b> attribute value:
                                <ul>
									<li>any <i>positive</i> value will cause a <b>MultiLinestring</b> to be returned.</li>
									<li><i>zero</i> (default value) will cause a <b>MultiPolygon</b> to be returned.</li>
									<li>any <i>negative</i> value will cause a <b>MultiPoint</b> to be returned.</li>
                                </ul>
                                If the optional <b>origin</b> argument (expected to be a Point) is not specified then the (0,0) grid origin will be assumed by default.<hr>
				NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>BuildMbr</b></td>
				<td>BuildMbr( x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>[<b>x1 y1</b>] and [<b>x2 y2</b>] are assumed to be Points identifying a line segment;
then a Geometry will be returned representing the MBR for this line segment</td></tr>
			<tr><td><b>BuildCircleMbr</b></td>
				<td>BuildCircleMbr( x <i>Double precision</i> , y <i>Double precision</i> ,
				radius <i>Double precision</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>[<b>x y</b>] is assumed to be the center of a circle of given <b>radius</b>;
then a Geometry will be returned representing the MBR for this circle</td></tr>
			<tr><td><b>Extent</b></td>
				<td>Extent( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object representing the bounding box that encloses a set of input values<br>
				<b><u>aggregate function</u></b></td></tr>
			<tr><td><b>ToGARS</b></td>
				<td>ToGARS( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td><b>geom</b> is expected to represent a POINT (longitude and latitude coordinates);
                                the corresponding <a href="https://www.gaia-gis.it/fossil/libspatialite/wiki?name=GARS">GARS</a> area designation code will be returned.<hr>
                                NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>GARSMbr</b></td>
				<td>GARSMbr( code <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td><b>code</b> is assumed to represent a valid GARS area designation code;
a Geometry will be returned representing the MBR for the corresponding GARS area.<hr>
                                NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>MbrMinX</b></td>
				<td>MbrMinX( geom <i>Geometry</i>) : <i>Double precision</i><hr>
				    ST_MinX( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the x-coordinate for <i>geom</i> MBR's <u>leftmost side</u> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry.</td></tr>
			<tr><td><b>MbrMinY</b></td>
				<td>MbrMinY( geom <i>Geometry</i>) : <i>Double precision</i><hr>
				    ST_MinY( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the y-coordinate for <i>geom</i> MBR's <u>lowermost side</u> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry.</td></tr>
			<tr><td><b>MbrMaxX</b></td>
				<td>MbrMaxX( geom <i>Geometry</i>) : <i>Double precision</i><hr>
				    ST_MaxX( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the x-coordinate for <i>geom</i> MBR's <u>rightmost side</u> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry.</td></tr>
			<tr><td><b>MbrMaxY</b></td>
				<td>MbrMaxY( geom <i>Geometry</i>) : <i>Double precision</i><hr>
				    ST_MaxY( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the y-coordinate for <i>geom</i> MBR's <u>uppermost side</u> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry.</td></tr>
			<tr><td><b>MinZ</b></td>
				<td>ST_MinZ( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the minimum Z-coordinate value for <i>geom</i> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry or if <i>geom</i> has no Z dimension.</td></tr>
			<tr><td><b>MaxZ</b></td>
				<td>ST_MaxZ( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the maximum Z-coordinate value for <i>geom</i> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry or if <i>geom</i> has no Z dimension.</td></tr>
			<tr><td><b>MinM</b></td>
				<td>ST_MinM( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the minimum M-coordinate value for <i>geom</i> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry or if <i>geom</i> has no M dimension.</td></tr>
			<tr><td><b>MaxM</b></td>
				<td>ST_MaxM( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the maximum M-coordinate value for <i>geom</i> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry or if <i>geom</i> has no M dimension.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p1">SQL functions for constructing a geometric object given its Well-known Text Representation</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>GeomFromText</b></td>
				<td>GeomFromText( wkt <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i><hr>
					ST_GeomFromText( wkt <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its Well-known text Representation</td></tr>
			<tr><td><b>ST_WKTToSQL</b></td>
				<td>ST_WKTToSQL( wkt <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td><b>SQL/MM</b> compliant: simply an <i>alias name</i> for <b>ST_GeomFromText</b><hr>
                                        <u>Please note</u>: <b>SRID=0</b> is always assumed.</td></tr>
			<tr><td><b>PointFromText</b></td>
				<td>PointFromText( wktPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Point</i><hr>
					ST_PointFromText( wktPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Point</td></tr>
			<tr><td><b>LineFromText</b><br><b>LineStringFromText</b></td>
				<td>LineFromText( wktLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					ST_LineFromText( wktLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					LineStringFromText( wktLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					ST_LineStringFromText( wktLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Linestring</td></tr>
			<tr><td><b>PolyFromText</b><br><b>PolygonFromText</b></td>
				<td>PolyFromText( wktPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_PolyFromText( wktPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					PolygonFromText( wktPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_PolygonFromText( wktPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Polygon</td></tr>
			<tr><td><b>MPointFromText</b><br><b>MultiPointFromText</b></td>
				<td>MPointFromText( wktMultiPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					ST_MPointFromText( wktMultiPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					MultiPointFromText( wktMultiPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					ST_MultiPointFromText( wktMultiPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiPoint</td></tr>
			<tr><td><b>MLineFromText</b><br><b>MultiLineStringFromText</b></td>
				<td>MLineFromText( wktMultiLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					ST_MLineFromText( wktMultiLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					MultiLineStringFromText( wktMultiLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					ST_MultiLineStringFromText( wktMultiLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiLinestring</td></tr>
			<tr><td><b>MPolyFromText</b><br><b>MultiPolygonFromText</b></td>
				<td>MPolyFromText( wktMultiPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_MPolyFromText( wktMultiPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					MultiPolygonFromText( wktMultiPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_MultiPolygonFromText( wktMultiPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiPolygon</td></tr>
			<tr><td><b>GeomCollFromText</b><br><b>GeometryCollectionFromText</b></td>
				<td>GeomCollFromText( wktGeometryCollection <i>String</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					ST_GeomCollFromText( wktGeometryCollection <i>String</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					GeometryCollectionFromText( wktGeometryCollection <i>String</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					ST_GeometryCollectionFromText( wktGeometryCollection <i>String</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a GeometryCollection</td></tr>
			<tr><td><b>BdPolyFromText</b></td>
				<td>BdPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_BdPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Construct a Polygon given an arbitrary collection of closed linestrings as a MultiLineString text representation.
				<hr><i>see also</i>: <b>BuildArea()</b>, <b>Polygonize()</b></td></tr>
			<tr><td><b>BdMPolyFromText</b></td>
				<td>BdMPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_BdMPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Construct a MultiPolygon given an arbitrary collection of closed linestrings as a MultiLineString text representation.
				<hr><i>see also</i>: <b>BuildArea()</b>, <b>Polygonize()</b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p2">SQL functions for constructing a geometric object given its Well-known Binary Representation</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>GeomFromWKB</b></td>
				<td>GeomFromWKB( wkbGeometry <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i><hr>
					ST_GeomFromWKB( wkbGeometry <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its Well-known binary Representation</td></tr>
			<tr><td><b>ST_WKBToSQL</b></td>
				<td>ST_WKBToSQL( wkbGeometry <i>Binary</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td><b>SQL/MM</b> compliant: simply an <i>alias name</i> for <b>ST_GeomFromWKB</b><hr>
                                        <u>Please note</u>: <b>SRID=0</b> is always assumed.</td></tr>
			<tr><td><b>PointFromWKB</b></td>
				<td>PointFromWKB( wkbPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Point</i><hr>
					ST_PointFromWKB( wkbPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Point</td></tr>
			<tr><td><b>LineFromWKB</b><br><b>LineStringFromWKB</b></td>
				<td>LineFromWKB( wkbLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					ST_LineFromWKB( wkbLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					LineStringFromText( wkbLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					ST_LineStringFromText( wkbLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Linestring</td></tr>
			<tr><td><b>PolyFromWKB</b><br><b>PolygonFromWKB</b></td>
				<td>PolyFromWKB( wkbPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_PolyFromWKB( wkbPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					PolygonFromWKB( wkbPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_PolygonFromWKB( wkbPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Polygon</td></tr>
			<tr><td><b>MPointFromWKB</b><br><b>MultiPointFromWKB</b></td>
				<td>MPointFromWKB( wkbMultiPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					ST_MPointFromWKB( wkbMultiPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					MultiPointFromWKB( wkbMultiPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i>
					ST_MultiPointFromWKB( wkbMultiPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiPoint</td></tr>
			<tr><td><b>MLineFromWKB</b><br><b>MultiLineStringFromWKB</b></td>
				<td>MLineFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					ST_MLineFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					MultiLineStringFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					ST_MultiLineStringFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiLinestring</td></tr>
			<tr><td><b>MPolyFromWKB</b><br><b>MultiPolygonFromWKB</b></td>
				<td>MPolyFromWKB( wkbMultiPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_MPolyFromWKB( wkbMultiPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					MultiPolygonFromWKB( wkbMultiPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_MultiPolygonFromWKB( wkbMultiPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiPolygon</td></tr>
			<tr><td><b>GeomCollFromWKB</b><br><b>GeometryCollectionFromWKB</b></td>
				<td>GeomCollFromWKB( wkbGeometryCollection <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					ST_GeomCollFromWKB( wkbGeometryCollection <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					GeometryCollectionFromWKB( wkbGeometryCollection <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					ST_GeometryCollectionFromWKB( wkbGeometryCollection <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a GeometryCollection</td></tr>
			<tr><td><b>BdPolyFromWKB</b></td>
				<td>BdPolyFromWKB( wkbMultilinestring <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_BdPolyFromWKB( wkbMultilinestring <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Construct a Polygon given an arbitrary collection of closed linestrings as a MultiLineString binary representation.
				<hr><i>see also</i>: <b>BuildArea()</b>, <b>Polygonize()</b></td></tr>
			<tr><td><b>BdMPolyFromWKB</b></td>
				<td>BdMPolyFromWKB( wkbMultilinestring <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_BdMPolyFromWKB( wkbMultilinestring <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Construct a MultiPolygon given an arbitrary collection of closed linestrings as a MultiLineString binary representation.
				<hr><i>see also</i>: <b>BuildArea()</b>, <b>Polygonize()</b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p3">SQL functions for obtaining the Well-known Text / Well-known Binary Representation of a geometric object</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>AsText</b></td>
				<td>AsText( geom <i>Geometry</i> ) : <i>String</i><hr>
					ST_AsText( geom <i>Geometry</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the Well-known Text representation</td></tr>
			<tr><td><b>AsWKT</b></td>
				<td>AsWKT( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the Well-known Text representation<hr>always return strictly conformant 2D WKT</td></tr>
			<tr><td><b>AsBinary</b></td>
				<td>AsBinary( geom <i>Geometry</i> ) : <i>Binary</i><hr>
					ST_AsBinary( geom <i>Geometry</i> ) : <i>Binary</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the Well-known Binary representation</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p3misc">SQL functions supporting exotic geometric formats</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>AsSVG</b></td>
				<td>AsSVG( geom <i>Geometry</i> [ , relative <i>Integer</i> [ , precision <i>Integer</i> ] ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the SVG [<i>Scalable Vector Graphics</i>] representation</td></tr>
			<tr><td><b>AsKml</b></td>
				<td>AsKml( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i><br>
				AsKml( name <i>String</i>, description <i>String</i>, geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ</td>
				<td>returns the KML [<i>Keyhole Markup Language</i>] representation<br>
				The first form will simply generate the geometry element: the second form will generate a complete KML entity</td></tr>
			<tr><td><b>GeomFromKml</b></td>
				<td>GeomFromKml( KmlGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its KML Representation</td></tr>	
			<tr><td><b>AsGml</b></td>
				<td>AsGml( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i><br>
				AsGml( version <i>Integer</i>, geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the GML [<i>Geography Markup Language</i>] representation<br>
				If <i>version = 3</i> than GML 3.x is generated, otherwise the output format will be GML 2.x</td></tr>
			<tr><td><b>GeomFromGML</b></td>
				<td>GeomFromGML( gmlGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its GML Representation</td></tr>	
			<tr><td><b>AsGeoJSON</b></td>
				<td>AsGeoJSON( geom <i>Geometry</i> [ , precision <i>Integer</i> [ , options <i>Integer</i> ] ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the GeoJSON [<i>Geographic JavaScript Object Notation</i>] representation<hr>
				if not explicitly specified <i>precision</i> is <b>15</b> decimal digits (default value).<br><br>
				<i>options</i> can assume the following values:
				<ul>
					<li><b>0</b> no options [<i>default</i>]</li>
					<li><b>1</b> GeoJSON BoundingBox</li>
					<li><b>2</b> GeoJSON CRS [<i>short version</i>]</li>
					<li><b>3</b> BoundingBox + short CRS</li>
					<li><b>4</b> GeoJSON CRS [<i>long version</i>]</li>
					<li><b>5</b> BoundingBox + long CRS</li>
				</ul></td></tr>
			<tr><td><b>GeomFromGeoJSON</b></td>
				<td>GeomFromGeoJSON( geoJSONGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its GeoJSON Representation</td></tr>	
			<tr><td><b>AsEWKB</b></td>
				<td>AsEWKB( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the EWKB [<i>Extended Well Known Binary</i>] representation (PostGIS compatibility)</td></tr>
			<tr><td><b>GeomFromEWKB</b></td>
				<td>GeomFromEWKB( ewkbGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its EWKB Representation</td></tr>	
			<tr><td><b>AsEWKT</b></td>
				<td>AsEWKT( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the EWKT [<i>Extended Well Known Text</i>] representation (PostGIS compatibility)</td></tr>
			<tr><td><b>GeomFromEWKT</b></td>
				<td>GeomFromEWKT( ewktGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its EWKT Representation</td></tr>	
			<tr><td><b>AsFGF</b></td>
				<td>AsFGF( geom <i>Geometry</i> , dims <i>Integer</i> ) : <i>Binary</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the FGF [<i>FDO Geometry Binary Format</i>] representation<hr>
				<i>dims</i> can assume one of the following values:
				<ul>
					<li><b>0</b> XY dimension</li>
					<li><b>1</b> XYZ dimension</li>
					<li><b>2</b> XYM dimension</li>
					<li><b>3</b> XYZM dimension</li>
				</ul></td></tr>
			<tr><td><b>GeomFromFGF</b></td>
				<td>GeomFromFGF( fgfGeometry <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its FGF binary Representation</td></tr>
			<tr><td><b>AsTWKB</b></td>
				<td>AsTWKB( geom <i>Geometry</i> ) : <i>TWKB-blob</i><hr>
				    AsTWKB( geom <i>Geometry</i> , precision_xy <i>Integer</i>) : <i>TWKB-blob</i><hr>
				    AsTWKB( geom <i>Geometry</i> , precision_xy <i>Integer</i> , precision_z <i>Integer</i> ) : <i>TWKB-blob</i><hr>
				    AsTWKB( geom <i>Geometry</i> , precision_xy <i>Integer</i> , precision_z <i>Integer</i> , precision_m <i>Integer</i> ) : <i>TWKB-blob</i><hr>
				    AsTWKB( geom <i>Geometry</i> , precision_xy <i>Integer</i> , precision_z <i>Integer</i> , precision_m <i>Integer</i> , with_size <i>Integer</i> ) : <i>TWKB-blob</i><hr>
				    AsTWKB( geom <i>Geometry</i> , precision_xy <i>Integer</i> , precision_z <i>Integer</i> , precision_m <i>Integer</i> , with_size <i>Integer</i> , with_bbox <i>Integer</i> ) : <i>TWKB-blob</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>returns the TWKB [<i>Tiny Well Known Binary</i>] representation (PostGIS/Mapnik compatibility)
				<ul>
					<li>the optional arguments <b>precision_xy</b>, <b>precision_z</b> and <b>precision_m</b> are intended to specify how many decimal digits should be preserved
					for the corresponding coordinate (<i>less decimal digits = stronger compression</i>). If not specified the default value is alwasy <b>ZERO</b> (no decimal digits at all).</li>
					<li>the optional arguments <b>with_size</b> and <b>with_bbox</b> are of the <b>Boolean</b> type (<b>TRUE</b> or <b>FALSE</b>) and respectively control if the
					TWKB geometry should include or not a <b>size</b> and/or a <b>BBOX</b>. If not specified the default value is always <b>FALSE</b>.</li>
				</ul></td></tr>
			<tr><td><b>GeomFromTWKB</b></td>
				<td>GeomFromTWKB( twkbGeometry <i>BLOB</i> [ , SRID <i>Integer</i>]  ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>construct a geometric object given its TWKB Representation</td></tr>
			<tr><td><b>AsEncodedPolyline</b></td>
				<td>ST_AsEncodedPolyline( geom <i>Geometry</i> ) : <i>TEXT</i><hr>
				    ST_AsEncodedPolyline( geom <i>Geometry</i> , precision <i>Integer</i> ) : <i>TEXT</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>returns a <i>GoogleMaps encoded Polyline</i> from a Geometry.<br>
				    The optional arguments <b>precision</b> is intended to specify how many decimal digits should be preserved (<i>default value</i>: <b>5</b>).<br>
				    <u>Note</u>: the input Geometry must be a <b>LINESTRING</b> in some <b>geographic SRID</b> (coordinates expressed as <b>longitude</b> and <b>latitude</b> angles).<hr>
				    <b>NULL</b> will be returned on invalid arguments.
				</td></tr>	
				
			<tr><td><b>LineFromEncodedPolyline</b></td>
				<td>ST_LineFromEncodedPolyline( polyline <i>TEXT</i> ) : <i>Geometry</i><hr>
				    ST_LineFromEncodedPolyline( polyline <i>TEXT</i> , precision <i>Integer</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>returns a Geometry from a <i>GoogleMaps encoded Polyline</i>.<br>
				    The optional arguments <b>precision</b> is intended to specify how many decimal digist should be preserved (<i>default value</i>: <b>5</b>).<br>
				    <u>Note</u>: the returned Geometry will always be a <b>LINESTRING</b> in the <b>SRID=4326</b>.<hr>
				    <b>NULL</b> will be returned on invalid arguments.
				</td></tr>	
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p4">SQL functions on type Geometry</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Dimension</b></td>
				<td>Dimension( geom <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Dimension( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the dimension of the geometric object, which is less than or equal to the dimension 
					of the coordinate space</td></tr>
			<tr><td><b>CoordDimension</b></td>
				<td>CoordDimension( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the dimension model used by the geometric object as:<br>
					'<b>XY</b>', '<b>XYZ</b>', '<b>XYM</b>' or '<b>XYZM</b>'</td></tr>
			<tr><td><b>NDims</b></td>
				<td>ST_NDims( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the number of dimensions used by the geometric object as:<br>
					<b>2</b>, <b>3</b> or <b>4</b></td></tr>
			<tr><td><b>Is3D</b></td>
				<td>ST_Is3D( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks if <i>geom</i> has the Z dimension.<br>
                                    The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
                                    and -1 for UNKNOWN when called with invalid arguments.</td></tr>
			<tr><td><b>IsMeasured</b></td>
				<td>ST_IsMeasured( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Check if <i>geom</i> has the M dimension.<br>
                                    The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
                                    and -1 for UNKNOWN when called with invalid arguments.</td></tr>
			<tr><td><b>GeometryType</b></td>
				<td>GeometryType( geom <i>Geometry</i> ) : <i>String</i><hr>
					ST_GeometryType( geom <i>Geometry</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the name of the instantiable subtype of Geometry of which this geometric object is a member, as a string</td></tr>
			<tr><td><b>SRID</b></td>
				<td>SRID( geom <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_SRID( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the Spatial Reference System ID for this geometric object</td></tr>
			<tr><td><b>SetSRID</b></td>
				<td>SetSRID( geom <i>Geometry</i> , SRID <i>Integer</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>directly sets the Spatial Reference System ID for this geometric object [no reprojection is applied]<hr>
					Will return a new Geometry BLOB object, or <b>NULL</b> on invalid arguments or errors.</td></tr>
			<tr><td><b>IsEmpty</b></td>
				<td>IsEmpty( geom <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_IsEmpty( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.<hr>
					TRUE if this geometric object corresponds to the empty set</td></tr>
			<tr><td><b>IsSimple</b></td>
				<td>IsSimple( geom <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_IsSimple( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.<hr>
					TRUE if this geometric object is simple, as defined in the Geometry Model</td></tr>
			<tr><td><b>IsValid</b></td>
				<td>IsValid( geom <i>Geometry</i> [ , esri_flag <i>Boolean</i> ] ) : <i>Integer</i><hr>
					ST_IsValid( geom <i>Geometry</i> [ , esri_flag <i>Boolean</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.<br>
					If the <b>ESRI_flag</b> argument is set to 1 (TRUE), then all ESRI-like internal holes
					(violating the standard OGC model) will be considered valid.<hr>
					TRUE if this geometric object does  not contains any topological error</td></tr>
			<tr><td><b>IsValidReason</b></td>
				<td>IsValidReason( geom <i>Geometry</i> [ , esri_flag <i>Boolean</i> ] ) : <i>String</i><hr>
					ST_IsValidReason( geom <i>Geometry</i> [ , esri_flag <i>Boolean</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Will return a TEXT string stating if a Geometry is valid and if not valid, a reason why.<br>
					If the <b>ESRI_flag</b> argument is set to 1 (TRUE), then all ESRI-like internal holes
					(violating the standard OGC model) will be considered valid.<hr>
					NULL will be returned on invalid arguments.</td></tr>
			<tr><td><b>IsValidDetail</b></td>
				<td>IsValidDetail( geom <i>Geometry</i>  [ , esri_flag <i>Boolean</i> ]) : <i>Geometry</i><hr>
					ST_IsValidDetail( geom <i>Geometry</i>  [ , esri_flag <i>Boolean</i> ]) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Will return a Geometry detail (usually a <b>POINT</b>) causing invalidity.<br>
					If the <b>ESRI_flag</b> argument is set to 1 (TRUE), then all ESRI-like internal holes
					(violating the standard OGC model) will be considered valid.<hr>
					NULL will be returned on invalid arguments, or in the case of a valid Geometry.</td></tr>
			<tr><td><b>Boundary</b></td>
				<td>Boundary( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Boundary( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>returns a geometric object that is the combinatorial boundary of g as defined in the Geometry Model</td></tr>
			<tr><td><b>Envelope</b></td>
				<td>Envelope( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Envelope( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the rectangle bounding g as a Polygon. The Polygon is defined by the corner points of the bounding
					box [(MINX, MINY),(MAXX, MINY), (MAXX, MAXY), (MINX, MAXY), (MINX, MINY)].</td></tr>
			<tr><td><b>Expand</b></td>
				<td>ST_Expand( geom <i>Geometry</i> , amount <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the rectangle bounding g as a Polygon. The bounding rectangle is expanded in all directions by an amount 
				    specified by the second argument.</td></tr>
			<tr><td><b>NPoints</b></td>
				<td>ST_NPoints( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the total number of Points (this including any Linestring/Polygon vertex).</td></tr>
			<tr><td><b>NRings</b></td>
				<td>ST_NRings( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the total number of Rings (this including both Exterior and Interior Rings).</td></tr>
			<tr><td><b>Reverse</b></td>
				<td>ST_Reverse( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Geometry [if a valid Geometry was supplied], or NULL in any other case.<hr>
                                    Any Linestring or Ring will be in reverse order (first vertex will be the last one,
                                    and last vertex will be the first one).</td></tr>
			<tr><td><b>ForceLHR</b></td>
				<td>ST_ForceLHR( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Just an <b>alias-name</b> for <b>ST_ForcePolygonCW()</b>.<br>
				<table bgcolor="#ffff00"><tr><td>Note: this function in Spatialite has a different interpretation then in PostGIS.</td></tr></table>
				</td></tr>
			<tr><td><b>ForcePolygonCW</b></td>
				<td>ST_ForcePolygonCW( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Geometry [if a valid Geometry was supplied], or NULL in any other case.<hr>
                                    All Polygons will be oriented accordingly to Clockwise Rule (all Exterior
                                    Ring will be clockwise oriented, and all Interior Rings will be counter-clockwise oriented).</td></tr>
			<tr><td><b>ForcePolygonCCW</b></td>
				<td>ST_ForcePolygonCCW( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Geometry [if a valid Geometry was supplied], or NULL in any other case.<hr>
                                    All Polygons will be oriented accordingly to Counter-Clockwise Rule (all Exterior
                                    Ring will be counter-clockwise oriented, and all Interior Rings will be clockwise oriented).</td></tr>
			<tr><td><b>IsPolygonCW</b></td>
				<td>ST_IsPolygonCW( geom <i>Geometry</i> ) : <i>Boolean</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns <b>TRUE</b> (<b>1</b>) if all Polygons into the Geometry are oriented accordingly to Clockwise Rule (all Exterior
                                    Ring must be clockwise oriented, and all Interior Rings must be counter-clockwise oriented).<br>
                    returns <b>FALSE</b> (<b>0</b>) if not; returns <b>-1</b> on invalid Geometries.<hr>
                    <u>Note</u>: a Geometry containing no Polygons will always return TRUE.</td></tr>
			<tr><td><b>IsPolygonCCW</b></td>
				<td>ST_IsPolygonCCW( geom <i>Geometry</i> ) : <i>Boolean</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns <b>TRUE</b> (<b>1</b>) if all Polygons into the Geometry are oriented accordingly to Counter-Clockwise Rule (all Exterior
                                    Ring must be counter-clockwise oriented, and all Interior Rings must be clockwise oriented).<br>
                    returns <b>FALSE</b> (<b>0</b>) if not: returns <b>-1</b> on invalid Geometries.<hr>
                    <u>Note</u>: a Geometry containing no Polygons will always return TRUE.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="repair">SQL functions attempting to repair malformed Geometries</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>SanitizeGeometry</b></td>
				<td>SanitizeGeometry( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a (possibly) sanitized Geometry [<i>if a valid Geometry was supplied</i>], or NULL in any other case<hr>
					<u>Please note</u>: current implementations only affects:<ul>
						<li>repeated vertices suppression</li>
						<li>Ring's closure enforcement</li>
					</ul></td></tr>
			<tr><td><b>EnsureClosedRings</b></td>
				<td>EnsureClosedRings( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Geometry derived from the input Geometry; all <i>Rings</i> within the output Geometry are ensured to be correctly <i>closed</i>, 
				    i.e. will have exactly coincident <i>start</i> and <i>end</i> vertices.<br>
				    This function accepts input Geometries of any class: <b>Point</b>, <b>MultiPoint</b>, <b>Linestring</b>, <b>MultiLinestring</b>,
					<b>Polygon</b>, <b>MultiPolygon</b>, <b>GeometryCollection</b> and <b>Geometry</b>.<hr>
					Will return <b>NULL</b> on invalid argument.
				</td></tr>
			<tr><td><b>RemoveRepeatedPoints</b></td>
				<td>RemoveRepeatedPoints( geom <i>Geometry</i> ) : geom <i>Geometry</i><hr>
				    RemoveRepeatedPoints( geom <i>Geometry</i> , tolerance <i>Double</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Geometry derived from the input Geometry; all repeated vertices found in <i>Linestrings</i> or <i>Rings</i> will be removed and the same applies
				    to repeated points found in <i>Multipoints</i>.<br>
				    This function accepts input Geometries of any class: <b>Point</b>, <b>MultiPoint</b>, <b>Linestring</b>, <b>MultiLinestring</b>,
					<b>Polygon</b>, <b>MultiPolygon</b>, <b>GeometryCollection</b> and <b>Geometry</b>.
					<ul>
						<li>if the optional argument <b>tolerance</b> is defined all vertices/points presenting a distance less or equal to this value will be considered as repeated points.<br>
						The default tolerance value is <b>0.0</b>, this intending an <i>exact coincidence</i>; the same applies to any <i>negative</i> tolerance.</li>
						<li><i>Linestring</i> or <i>Ring</i> vertices are considered to be repeated only if they are <i>consecutive</i>.</li>
						<li><i>Multipoint</i> points are considered to be repeated independentely from their relative order.</li>
					</ul><hr>
					Will return <b>NULL</b> on invalid arguments.
				</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="compress">SQL Geometry-compression functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CompressGeometry</b></td>
				<td>CompressGeometry( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a compressed Geometry [<i>if a valid Geometry was supplied</i>], or NULL in any other case<hr>
					<u>Please note</u>: geometry compression only affects LINESTRINGs and POLYGONs, not POINTs</td></tr>
			<tr><td><b>UncompressGeometry</b></td>
				<td>UncompressGeometry( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns an uncompressed Geometry [<i>if a valid Geometry was supplied</i>], or NULL in any other case</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="cast">SQL Geometry-type casting functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CastToPoint</b></td>
				<td>CastToPoint( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>POINT</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing only a single POINT and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToLinestring</b></td>
				<td>CastToLinestring( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>LINESTRING</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing only a single LINESTRING and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToPolygon</b></td>
				<td>CastToPolygon( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>POLYGON</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing only a single POLYGON and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToMultiPoint</b></td>
				<td>CastToMultiPoint( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>MULTIPOINT</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing one or more POINT(s) and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToMultiLinestring</b></td>
				<td>CastToMultiLinestring( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>MULTILINESTRING</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing one or more LINESTRING(s) and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToMultiPolygon</b></td>
				<td>CastToMultiPolygon( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>MULTIPOLYGON</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing one or more POLYGON(s) and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToGeometyCollection</b></td>
				<td>CastToGeometryCollection( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>GEOMETRYCOLLECTION</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any valid Geometry</td></tr>
			<tr><td><b>CastToMulti</b></td>
				<td>CastToMulti( geom <i>Geometry</i> ) : geom <i>Geometry</i><hr>
					ST_Multi( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>MULTIPOINT-</b>, <b>MULTILINESTRING-</b> or <b>MULTIPOLYGON</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					<ul>
					<li>a MULTIPOINT will be returned for a Geometry containing one or more POINT(s) and no other elementary sub-geometry</li>
					<li>a MULTILINESTRING will be returned for a Geometry containing one or more LINESTRING(s) and no other elementary sub-geometry</li>
					<li>a MULTIPOLYGON will be returned for a Geometry containing one or more POLYGON(s) and no other elementary sub-geometry</li>
					<li>a GEOMETRYCOLLECTION will be returned for any other valid Geometry</li>
					</ul></td></tr>
			<tr><td><b>CastToSingle</b></td>
				<td>CastToSingle( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>POINT-</b>, <b>LINESTRING-</b> or <b>POLYGON</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					<ul>
					<li>a POINT will be returned for a Geometry containing only a single POINT and no other elementary sub-geometry</li>
					<li>a LINESTRING will be returned for a Geometry containing only a single LINESTRING and no other elementary sub-geometry</li>
					<li>a POLYGON will be returned for a Geometry containing only a single POLYGON and no other elementary sub-geometry</li>
					</ul></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="dims-cast">SQL Space-dimensions casting functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CastToXY</b></td>
				<td>CastToXY( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a Geometry using the [<b>XY</b>] space dimension</td></tr>
			<tr><td><b>CastToXYZ</b></td>
				<td>CastToXYZ( geom <i>Geometry</i> ) : geom <i>Geometry</i><hr>
				    CastToXYZ( geom <i>Geometry</i> , no_data <i>Double</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a Geometry using the [<b>XYZ</b>] space dimension.<br>
				    If the input Geometry already supports <b>Z</b> coordinates they'll be preserved as they are.<br>
				    If the input Geometry does not support <b>Z</b> coordinates they'll be set to <b>no_data</b> (defaulting to <b>0.0</b> if <b>no_data</b> is not specified).</td></tr>
			<tr><td><b>CastToXYM</b></td>
				<td>CastToXYM( geom <i>Geometry</i> ) : geom <i>Geometry</i><hr>
				    CastToXYM( geom <i>Geometry</i> , no_data <i>Double</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a Geometry using the [<b>XYM</b>] space dimension.<br>
				    If the input Geometry already supports <b>M</b> coordinates they'll be preserved as they are.<br>
				    If the input Geometry does not support <b>M</b> coordinates they'll be set to <b>no_data</b> (defaulting to <b>0.0</b> if <b>no_data</b> is not specified).</td></tr>
			<tr><td><b>CastToXYZM</b></td>
				<td>CastToXYZM( geom <i>Geometry</i> ) : geom <i>Geometry</i><hr>
				    CastToXYZM( geom <i>Geometry</i> , z_no_data <i>Double</i> , m_no_data <i>Double</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a Geometry using the [<b>XYZM</b>] space dimension.<br>
				    If the input Geometry already supports <b>Z</b> coordinates they'll be preserved as they are.<br>
				    If the input Geometry does not support <b>Z</b> coordinates they'll be set to <b>z_no_data</b> (defaulting to <b>0.0</b> if <b>z_no_data</b> is not specified).<br>
				    The same rule applies to <b>M</b> coordinates and <b>m_no_data</b>.</td></tr>
			<tr><td colspan="7" align="center" bgcolor="#f0f0c0">
				<h3><a name="p5">SQL functions on type Point</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>X</b></td>
				<td>X( pt <i>Point</i> ) : <i>Double precision</i><hr>
					ST_X( pt <i>Point</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the x-coordinate of Point p as a double precision number</td></tr>
			<tr><td><b>Y</b></td>
				<td>Y( pt <i>Point</i> ) : <i>Double precision</i><hr>
					ST_Y( pt <i>Point</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the y-coordinate of Point p as a double precision number</td></tr>
			<tr><td><b>Z</b></td>
				<td>Z( pt <i>Point</i> ) : <i>Double precision</i><hr>
					ST_Z( pt <i>Point</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the z-coordinate of Point p as a double precision number<br>
					or NULL is no z-coordinate is available</td></tr>
			<tr><td><b>M</b></td>
				<td>M( pt <i>Point</i> ) : <i>Double precision</i><hr>
					ST_M( pt <i>Point</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the m-coordinate of Point p as a double precision number<br>
					or NULL is no m-coordinate is available</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p6">SQL functions on type Curve [Linestring or Ring]</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>StartPoint</b></td>
				<td>StartPoint( c <i>Curve</i> ) : <i>Point</i><hr>
					ST_StartPoint( c <i>Curve</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a Point containing the first Point of c</td></tr>
			<tr><td><b>EndPoint</b></td>
				<td>EndPoint( c <i>Curve</i> ) : <i>Point</i><hr>
					ST_EndPoint( c <i>Curve</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a Point containing the last Point of c</td></tr>
			<tr><td rowspan="2"><b>Length</b></td>
				<td>GLength( c <i>Curve</i> ) : <i>Double precision</i>
					<table><tbody><tr><td bgcolor="#d080ff">
						OpenGis name for this function is <b>Length()</b>, but it conflicts with an SQLite reserved keyword
					</td></tr></tbody></table><hr>
					ST_Length( c <i>Curve</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the length of c<hr>
Starting since v.4.0.0 this function will simply consider Linestrings and MultiLinestrings, ignoring any Polygon or MultiPolygon</td></tr>
			<tr><td>GLength( c <i>Curve</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i><hr>
					ST_Length( c <i>Curve</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the length of c (measured in meters).<br>
If the <b>use_ellipsoid</b> argument is set to <b>TRUE</b> the precise (but slower) length will be computed on the Ellipsoid, otherwise will be computed on the Great Cicle (approximative, but faster).<hr>
This function only supports Long/Lat coordinates, and will return NULL for any planar CRS<hr>
Starting since v.4.0.0 this function will simply consider Linestrings and MultiLinestrings, ignoring any Polygon or MultiPolygon</td></tr>
			<tr><td rowspan="2"><b>Perimeter</b></td>
				<td>Perimeter( s <i>Surface</i> ) : <i>Double precision</i>
					ST_Perimeter( s <i>Surface</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the perimeter of s<hr>
Starting since v.4.0.0 this function will simply consider Polygons and MultiPolygons, ignoring any Linestring or MultiLinestring</td></tr>
			<tr><td>Perimeter( s <i>Surface</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i><hr>
					ST_Perimeter( s <i>Surface</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the perimeter of s (measured in meters).<br>
If the <b>use_ellipsoid</b> argument is set to <b>TRUE</b> the precise (but slower) perimeter will be computed on the Ellipsoid, otherwise will be computed on the Great Cicle (approximative, but faster).<hr>
This function only supports Long/Lat coordinates, and will return NULL for any planar CRS<hr>
Starting since v.4.0.0 this function will simply consider Polygons and MultiPolygons, ignoring any Linestring or MultiLinestring</td></tr>
			<tr><td><b>Geodesic Length</b></td>
				<td>GeodesicLength( c <i>Curve</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>If [<i>and only if</i>] the SRID associated with <i>c</i> is a <b>geographic</b> one [<i>i.e. one using longitude and latitude angles</i>],
				then returns the length of <i>c</i> measured on the Ellipsoid [<i>such length is always expressed in meters</i>]<br>
				Otherwise NULL will be returned<hr>
				<u>Please note:</u> measuring lengths on the Ellipsoid requires complex geodesic calculations, and thus is an
				intrinsically <u>slow and time consuming</u> task</td></tr>
			<tr><td><b>Great Circle Length</b></td>
				<td>GreatCircleLength( c <i>Curve</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>If [<i>and only if</i>] the SRID associated with <i>c</i> is a <b>geographic</b> one [<i>i.e. one using longitude and latitude angles</i>],
				then returns the length of <i>c</i> measured on the Great Circle [<i>such length is always expressed in meters</i>]<br>
				Otherwise NULL will be returned<hr>
				<u>Please note:</u> lengths measured on the Great Circle are less 
precise than lengths measured on the Ellipsoid using complex geodesic 
calculations;
				but they are by far quickest to compute</td></tr>
			<tr><td><b>IsClosed</b></td>
				<td>IsClosed( c <i>Curve</i> ) : <i>Integer</i><hr>
					ST_IsClosed( c <i>Curve</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument;<hr>
					return TRUE if c is closed, i.e., if StartPoint(c) = EndPoint(c)</td></tr>
			<tr><td><b>IsRing</b></td>
				<td>IsRing( c <i>Curve</i> ) : <i>Integer</i><hr>
					ST_IsRing( c <i>Curve</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.<hr>
					return TRUE if c is a ring, i.e., if c is closed and simple. A simple Curve does not pass through 
					the same Point more than once.</td></tr>
			<tr><td><b>PointOnSurface</b></td>
				<td>PointOnSurface( s <i>Surface/Curve</i> ) : <i>Point</i><hr>
					ST_PointOnSurface( s <i>Surface/Curve</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a Point guaranteed to lie on the Surface (or Curve)</td></tr>
			<tr><td><b>Simplify</b></td>
				<td>Simplify( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i><hr>
                                ST_Simplify( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i><hr>
				ST_Generalize( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object representing a simplified version of <i>c</i> applying the Douglas-Peuker 
algorithm with given <i>tolerance</i></td></tr>
			<tr><td><b>SimplifyPreserveTopology</b></td>
				<td>SimplifyPreserveTopology( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i><hr>
                                ST_SimplifyPreserveTopology( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object representing a simplified version of <i>c</i> applying the Douglas-Peuker
algorithm with given <i>tolerance</i> and respecting topology</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p7">SQL functions on type LineString</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>NumPoints</b></td>
				<td>NumPoints( line <i>LineString</i> ) : <i>Integer</i><hr>
					ST_NumPoints( line <i>LineString</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the number of Points in the LineString</td></tr>
			<tr><td><b>PointN</b></td>
				<td>PointN( line <i>LineString</i> , n <i>Integer</i> ) : <i>Point</i><hr>
					ST_PointN( line <i>LineString</i> , n <i>Integer</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a Point containing Point n of line (first Point corresponds to n=1)</td></tr>
			<tr><td><b>AddPoint</b></td>
				<td>AddPoint( line <i>LineString</i> , point <i>Point</i> [ , position <i>Integer</i> ] ) : <i>Linestring</i><hr>
					ST_AddPoint( line <i>LineString</i> , point <i>Point</i> [ , position <i>Integer</i> ] ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by adding a new Point into the input Linestring immediately before <b>position</b> (zero-based index).<br>
                                A negative <b>position</b> (default) means appending the new Point to the end of the input Linestring.<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td><b>SetPoint</b></td>
				<td>SetPoint( line <i>LineString</i> , position <i>Integer</i> , point <i>Point</i> ) : <i>Linestring</i><hr>
					ST_SetPoint( line <i>LineString</i> , position <i>Integer</i> , point <i>Point</i> ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by replacing the Point at <b>position</b> (zero-based index).<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td><b>SetStartPoint</b></td>
				<td>SetStartPoint( line <i>LineString</i> , point <i>Point</i> ) : <i>Linestring</i><hr>
					ST_SetStartPoint( line <i>LineString</i> , point <i>Point</i> ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by replacing its StartPoint.<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td><b>SetEndPoint</b></td>
				<td>SetEndPoint( line <i>LineString</i> , point <i>Point</i> ) : <i>Linestring</i><hr>
					ST_SetEndtPoint( line <i>LineString</i> , point <i>Point</i> ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by replacing its EndPoint.<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td><b>RemovePoint</b></td>
				<td>RemovePoint( line <i>LineString</i> , position <i>Integer</i> ) : <i>Linestring</i><hr>
					ST_RemovePoint( line <i>LineString</i> , position <i>Integer</i> ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by removing the Point at <b>position</b> (zero-based index).<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p8">SQL functions on type Surface [Polygon or Ring]</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Centroid</b></td>
				<td>Centroid( s <i>Surface</i> ) : <i>Point</i><hr>
					ST_Centroid( s <i>Surface</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the centroid of s, which may lie outside s</td></tr>
			<tr><td rowspan="2"><b>Area</b></td>
				<td>Area( s <i>Surface</i> ) : <i>Double precision</i><hr>
					ST_Area( s <i>Surface</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the area of s</td></tr>
			<tr><td>Area( s <i>Surface</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i><hr>
					ST_Area( s <i>Surface</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return the area of s (measured in meters).<br>
If the <b>use_ellipsoid</b> argument is set to <b>TRUE</b> the precise (but slower) area will be computed on the Ellipsoid, otherwise will be computed on the Sphere (approximative, but faster).<hr>
This function only supports Long/Lat coordinates, and will return NULL for any planar CRS</td></tr>
			<tr><td rowspan="2"><b><a name="circularity">Circularity</a></b></td>
				<td>Circularity( s <i>Surface</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>computes the Circularity Index from the given Geometry by applying the following formula:
				    <ul>
						<li><i>index = ( 4 * PI * Sum(area) ) / ( Sum(perimeter) * Sum(perimeter) )</i></li>
				    </ul>
				    <ul>
						<li>it only applies to <i>Polygons</i> or <i>MultiPolygons</i> with the following interpretation:
						<ul>
							<li><b>1.0</b> corresponds to a perfectly circular shape.</li>
							<li><b>very low</b> values (near zero) correspond to a threadlike shape.</li>
							<li><b>intermediate</b> values correspond to a more or less flattened shape;  lower index values means a stronger flattening effect.</li>
						</ul></li>
						<li>if the given Geometry does not contains any <i>Polygon</i> but contains at least a <i>Linestring</i> the index will always assume a <b>0.0</b> value.</li>
						<li>if the given Geometry only contains one or more <i>Points</i> the index will always assume a <b>NULL</b> value.</li>
				    </ul>
				    </td></tr>
			<tr><td>Circularity( s <i>Surface</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>same as the above Function, but in this case areas and perimeters will be measured in meters.<br>
If the <b>use_ellipsoid</b> argument is set to <b>TRUE</b> the precise (but slower) values will be computed on the Ellipsoid, otherwise they'll be computed on the Sphere (approximative, but faster).<hr>
This function only supports Long/Lat coordinates, and will return NULL for any planar CRS</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p9">SQL functions on type Polygon</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>ExteriorRing</b></td>
				<td>ExteriorRing( polyg <i>Polygon</i> ) : <i>LineString</i><hr>
					ST_ExteriorRing( polyg <i>Polygon</i> ) : <i>LineString</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the exteriorRing of p</td></tr>
			<tr><td><b>NumInteriorRing</b><br><b>NumInteriorRings</b></td>
				<td>NumInteriorRing( polyg <i>Polygon</i> ) : <i>Integer</i><hr>
					NumInteriorRings( polyg <i>Polygon</i> ) : <i>Integer</i><hr>
					ST_NumInteriorRing( polyg <i>Polygon</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the number of interiorRings</td></tr>
			<tr><td><b>InteriorRingN</b></td>
				<td>InteriorRingN( polyg <i>Polygon</i> , n <i>Integer</i> ) : <i>LineString</i><hr>
					ST_InteriorRingN( polyg <i>Polygon</i> , n <i>Integer</i> ) : <i>LineString</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the nth (1-based) interiorRing. The order of Rings is not geometrically significant.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p10">SQL functions on type GeomCollection</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>NumGeometries</b></td>
				<td>NumGeometries( geom <i>GeomCollection</i> ) : <i>Integer</i><hr>
					ST_NumGeometries( geom <i>GeomCollection</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the number of individual Geometries</td></tr>
			<tr><td><b>GeometryN</b></td>
				<td>GeometryN( geom <i>GeomCollection</i> , n <i>Integer</i> ) : <i>Geometry</i><hr>
					ST_GeometryN( geom <i>GeomCollection</i> , n <i>Integer</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the nth (1-based) geometric object in the collection.
					The order of the elements in the collection is not geometrically significant.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p11">SQL functions that test approximate spatial relationships via MBRs</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>MbrEqual</b></td>
				<td>MbrEqual( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL or invalid arguments.<hr>
					TRUE if g1 and g2 have equal MBRs</td></tr>
			<tr><td><b>MbrDisjoint</b></td>
				<td>MbrDisjoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL or invalid arguments.<hr>
					TRUE if the intersection of g1 and g2 MBRs is the empty set</td></tr>
			<tr><td><b>MbrTouches</b></td>
				<td>MbrTouches( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL or invalid arguments.<hr>
					TRUE if the only Points in common between g1 and g2 MBRs lie in the union of the boundaries of g1 and g2</td></tr>
			<tr><td><b>MbrWithin</b></td>
				<td>MbrWithin( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL or invalid arguments.<hr>
					TRUE if g1 MBR is completely contained in g2 MBR</td></tr>
			<tr><td><b>MbrOverlaps</b></td>
				<td>MbrOverlaps( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL or invalid arguments.<hr>
					TRUE if the intersection of g1 and g2 MBRs results in a value of the same
					dimension as g1 and g2 that is different from both g1 and g2</td></tr>
			<tr><td><b>MbrIntersects</b></td>
				<td>MbrIntersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL or invalid arguments;<hr>
					convenience predicate: TRUE if the intersection of g1 and g2 MBRs is not empty</td></tr>
			<tr><td><b>EnvelopesIntersects</b></td>
				<td>ST_EnvIntersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
				    ST_EnvelopesIntersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
				    ST_EnvIntersects( geom1 <i>Geometry</i> , x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> ) : <i>Integer</i><hr>
				    ST_EnvelopesIntersects( geom1 <i>Geometry</i> , x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The first form simply is an <u>alias name</u> for <b>MbrIntersects</b>; the other form allows to define the second MBR by two extreme points [<b>x1, y1</b>] and [<b>x2, y2</b>].<br>
                                        The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL or invalid arguments;<hr>
					convenience predicate: TRUE if the intersection of both MBRs is not empty</td></tr>
			<tr><td><b>MbrContains</b></td>
				<td>MbrContains( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments;<hr>
					convenience predicate: TRUE if g2 MBR is completely contained in g1 MBR</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p12">SQL functions that test spatial relationships</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Equals</b></td>
				<td>Equals( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Equals( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments.<hr>
					TRUE if g1 and g2 are equal</td></tr>
			<tr><td><b>Disjoint</b></td>
				<td>Disjoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Disjoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments.<hr>
					TRUE if the intersection of g1 and g2 is the empty set</td></tr>
			<tr><td><b>Touches</b></td>
				<td>Touches( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Touches( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments.<hr>
					TRUE if the only Points in common between g1 and g2 lie in the union of the boundaries of g1 and g2</td></tr>
			<tr><td><b>Within</b></td>
				<td>Within( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Within( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments.<hr>
					TRUE if g1 is completely contained in g2</td></tr>
			<tr><td><b>Overlaps</b></td>
				<td>Overlaps( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Overlaps( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments.<hr>
					TRUE if the intersection of g1 and g2 results in a value of the same
					dimension as g1 and g2 that is different from both g1 and g2</td></tr>
			<tr><td><b>Crosses</b></td>
				<td>Crosses( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Crosses( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments.<hr>
					TRUE if the intersection of g1 and g2 results in a value whose dimension is less 
					than the maximum dimension of g1 and g2 and the intersection value includes Points 
					interior to both g1 and g2, and the intersection value is not equal to either g1 or g2</td></tr>
			<tr><td><b>Intersects</b></td>
				<td>Intersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Intersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments;<br>
					convenience predicate: TRUE if the intersection of g1 and g2 is not empty</td></tr>
			<tr><td><b>Contains</b></td>
				<td>Contains( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Contains( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments;<hr>
					convenience predicate: TRUE if g2 is completely contained in g1</td></tr>
			<tr><td><b>Covers</b></td>
				<td>Covers( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Covers( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments;<hr>
					convenience predicate: TRUE if g1 completely covers g2</td></tr>
			<tr><td><b>CoveredBy</b></td>
				<td>CoveredBy( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_CoveredBy( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments;<hr>
					convenience predicate: TRUE if g1 is completely covered by g2</td></tr>
			<tr><td rowspan="2"><b>Relate</b></td>
				<td><h3>OGC canonical signature</h3>
				    Relate( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , patternMatrix <i>String</i> ) : <i>Integer</i><hr>
					ST_Relate( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , patternMatrix <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
					<td>For more informations about patternMatrix interpretation please read: <a href="https://en.wikipedia.org/wiki/DE-9IM">DE-9IM</a><br><br>
					The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL arguments;<hr>
					returns TRUE if the spatial relationship specified by the patternMatrix holds.</td></tr>
			<tr><td><h3>non-canonical signature (PostGIS-like)</h3>
				    Relate( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Text</i><hr>
					ST_Relate( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Text</i><hr>
				    Relate( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , bnr <i>Integer</i> ) : <i>Text</i><hr>
					ST_Relate( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , bnr <i>Integer</i> ) : <i>Text</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Text, this corresponding to the serialized representation of some <b>[DE-9IM]</b> intersection matrix.<br>
					The optional argument <i>bnr</i> determines the Boundary Node Rule to be appiled, and has the following interpretation:
					<ul>
						<li><b>1</b>: OGC/MOD2 (this is the default case, and will be always assumed for any unknown value)</li>
						<li><b>2</b>: Endpoint</li>
						<li><b>3</b>: Multivalent Endpoint</li>
						<li><b>4</b>: Monovalent Endpoint</li>
					</ul>
					A patternMatrix returned by this function is then expected to be evaluated later by <b>ST_RelateMatch()</b>.<br>
					The main advantage in using this approach is that this way a comprehensive result (the patternMatrix itself) representing all possible intersection 
					modes between two geometries will be be computed just once by <b>ST_Relate()</b> and could then be more precisely qualified by repeatedly calling <b>ST_RelateMatch()</b>;
					the first operation is computationally heavy but the second is really fast, so an overall performance boot is usually expected when more than a single
					intersection mode have to be checked at the same time, as e.g. <i>OVERLAPS OR TOUCHES OR INTERSECTS</i>.<hr>
					Will return <b>NULL</b> on NULL or invalid geometries.
					</td></tr>
			<tr><td><b>RelateMatch</b></td>
				<td>ST_RelatedMatch( matrix <i>Text</i> , pattern <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Evaluates if an intersection matrix <b>[DE-9IM]</b> satisfies an intersection pattern.<hr>
					The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN when called with NULL or invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p13">SQL functions for distance relationships</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td rowspan="2"><b>Distance</b></td>
				<td>Distance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i><hr>
					ST_Distance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the distance between geom1 and geom2 (always measured in CRS units).</td></tr>
			<tr><td>Distance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i><hr>
					ST_Distance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the distance between geom1 and geom2 (measured in meters).<br>
If the <b>use_ellipsoid</b> argument is set to <b>TRUE</b> the precise (but slower) distance will be computed on the Ellipsoid, otherwise will be computed on the Great Cicle (approximative, but faster).<hr>
This function only supports Long/Lat coordinates, and will return NULL for any planar CRS</td></tr>
			<tr><td><b>PtDistWithin</b></td>
				<td>PtDistWithin( geom1 <i>Geometry</i> , geom2 <i>Geometry</i>, range <i>Double precision</i> [, use_spheroid <i>Integer</i> ] ) 
					: <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ</td>
				<td>return TRUE (1) if the distance between <i>geom1</i> and <i>geom2</i> is within the given range.<br>
				Usually distances are expressed in the length unit corresponding to the geoms own SRID:
				but if both geoms are simple POINTs and their SRID is 4326 (i.e. WGS84), then distances are
				expressed in <b>meters</b>.<br>
				In this later case the optional arg <i>use_spheroid</i> can be used to select the distance
				algorithm to be used: is <i>use_spheroid = 1</i> the slowest but most accurate <b>geodesic distance</b>
				will be evaluated: in any other case the simplest <b>great circle distance</b> will be used instead</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p14-">SQL functions supporting Linear Referencing</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>AddMeasure</b></td>
				<td>ST_AddMeasure( geom <i>Geometry</i> , m_start <i>Double precision</i> , m_end <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Return a derived Geometry with M-values linearly interpolated between the start and end points.<br>
				NULL will be returned if any error is encountered.<br>
                                <u>Please note</u>: NULL will be returned if geom is not of the Linestring or MultiLinestring type.</td></tr>		
			<tr><td><b>InterpolatePoint</b></td>
				<td>ST_InterpolatePoint( line <i>Geometry</i> , point <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Interpolates the M-value of a linear Geometry at the point closest to the given point.<br>
				NULL will be returned if any error is encountered.<br>
                                <u>Please note</u>: NULL will be returned if the first geometry is not a Linestring supporting M-values, or if the second geometry is not a Point.</td></tr>		
			<tr><td><b>LocateAlongMeasure</b></td>
				<td>ST_Locate_Along_Measure( geom <i>Geometry</i> , m_value <i>Double precision</i> ) : <i>Geometry</i><hr>
				    ST_LocateAlong( geom <i>Geometry</i> , m_value <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Return a derived geometry collection value with elements that match the specified measure.<br>
				NULL will be returned if any error is encountered (or when no element corresponding to the given measure is found).<br>
                                <u>Please note</u>: NULL will be returned if geom doesn't contain M-dimension, or if geom contains a Polygon, or if geom is a GeometryCollection.</td></tr>
			<tr><td><b>LocateBetweenMeasures</b></td>
				<td>ST_Locate_Between_Measures( geom <i>Geometry</i> , m_start <i>Double precision</i> , m_end <i>Double precision</i> ) : <i>Geometry</i><hr>
				    ST_LocateBetween( geom <i>Geometry</i> , m_start <i>Double precision</i> , m_end <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Return a derived geometry collection value with elements that match the specified range of measures.<br>
				NULL will be returned if any error is encountered (or when no element corresponding to the given range of measures is found).<br>
                                <u>Please note</u>: NULL will be returned if geom doesn't contain M-dimension, or if geom contains a Polygon, or if geom is a GeometryCollection.</td></tr>                            
			<tr><td><b>IsValidTrajectory</b></td>
				<td>ST_IsValidTrajectory( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Check if a Geometry corresponds to a valid Trajectory.<br>
				a Trajectory is assumed to be a LINESTRING supporting M-values growing from each vertex to the next.<hr>
				NULL will be returned on invalid arguments.</td></tr>                           
			<tr><td><b>TrajectoryInterpolatePoint</b></td>
				<td>ST_TrajectoryInterpolarePoint( geom <i>Geometry</i> , m_value <i>Double</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Check if a Geometry corresponds to a valid Trajectory.<br>
				Return a POINT Geometry being interpolated along the Geometry (that is expected to be a valid Trajectory) accordingly to the given M-value.<br>
				The interpolated Point will have the same dimensions and SRID of the Trajectory.<hr>
				NULL will be returned on invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p14">SQL functions that implement spatial operators</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Intersection</b></td>
				<td>Intersection( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Intersection( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the intersection of geometric objects geom1 and geom2</td></tr>
			<tr><td><b>Difference</b></td>
				<td>Difference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Difference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the closure of the set difference of geom1 and geom2</td></tr>
			<tr><td><b>GUnion</b></td>
				<td>GUnion( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i>
					<table><tbody><tr><td bgcolor="#d080ff">
						OpenGis name for this function is <b>Union()</b>, but it conflicts with an SQLite reserved keyword
					</td></tr></tbody></table><hr>
					ST_Union( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the set union of geom1 and geom2</td></tr>
			<tr><td><b>GUnion</b></td>
				<td>GUnion( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Union( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the set union of input values
				<b><u>aggregate function</u></b></td></tr>
			<tr><td><b>SymDifference</b></td>
				<td>SymDifference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_SymDifference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the closure of the set symmetric difference of geom1 and geom2 
					(logical XOR of space)</td></tr>
			<tr><td><b>Buffer</b></td>
				<td>Buffer( geom <i>Geometry</i> , dist <i>Double precision</i> [ , quadrantsegments <i>Integer</i> ] ) : <i>Geometry</i><hr>
					ST_Buffer( geom <i>Geometry</i> , dist <i>Double precision</i> [ , quadrantsegments <i>Integer</i> ] ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object defined by buffering a distance d around geom, 
					where dist is in the distance units for the Spatial Reference of geom.<hr>
					the optional <b>quadrantsegments</b> argument specifies the number of segments used to approximate a quarter circle (default is 30).</td></tr>
			<tr><td><b>ConvexHull</b></td>
				<td>ConvexHull( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_ConvexHull( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the convex hull of geom</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p14b">SQL functions that implement spatial operators<br>[GEOS specific features]</a></h3></td></tr>
			<tr><td><b>HausdorffDistance</b></td>
				<td>HausdorffDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i><hr>
					ST_HausdorffDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the Hausdorff distance between geom1 and geom2<br>
				<a href="http://en.wikipedia.org/wiki/Hausdorff_distance">learn more</a></td></tr>
			<tr><td><b>OffestCurve</b></td>
				<td>OffsetCurve( geom <i>Curve</i> , radius <i>Double precision</i> ) : <i>Curve</i><hr>
					ST_OffsetCurve( geom <i>Curve</i> , radius <i>Double precision</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object representing the corresponding <i>left-sided</i> (<b>positive radius</b>) 
					or <i>right-sided</i> (<b>negative radius</b>) offset curve<br>
					NULL is returned whenever is not possible deriving an offset curve from the original geometry<br>
					[a single not-closed LINESTRING is expected as input]</td></tr>
			<tr><td><b>SingleSidedBuffer</b></td>
				<td>SingleSidedBuffer( geom <i>Curve</i> , radius <i>Double precision</i> , left_or_right <i>Integer</i> ) : <i>Curve</i><hr>
					ST_SingleSidedBuffer( geom <i>Curve</i> , radius <i>Double precision</i> , left_or_right <i>Integer</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object representing the corresponding <i>left-</i> (or <i>right-sided</i>) single-sided buffer<br>
					NULL is returned whenever is not possible deriving a single-sided buffer from the original geometry<br>
					[a single not-closed LINESTRING is expected as input]</td></tr>
			<tr><td><b>SharedPaths</b></td>
				<td>SharedPaths( geom1 <i>Geometry</i> , geom2 <i>Geomety</i> ) : <i>Geometry</i><hr>
					ST_SharedPaths( geom1 <i>Geometry</i> , geom2 <i>Geomety</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object (of the MULTILINESTRING type) representing any <i>common lines</i> shared by both geometries<br>
					NULL is returned is no common line exists</td></tr>
			<tr><td><b>Line_Interpolate_Point</b></td>
				<td>Line_Interpolate_Point( line <i>Curve</i> , fraction <i>Double precision</i> ) : <i>Point</i><hr>
					ST_Line_Interpolate_Point( line <i>Curve</i> , fraction <i>Double precision</i> ) : <i>Point</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a point interpolated along a line.<br>
					Second argument (between <b>0.0</b> and <b>1.0</b>) representing fraction of total length of linestring 
					the point has to be located.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>Line_Interpolate_Equidistant_Points</b></td>
				<td>Line_Interpolate_Equidistant_Points( line <i>Curve</i> , distance <i>Double precision</i>) : <i>MultiPoint</i><hr>
					ST_Line_Interpolate_Equidistant_Points( line <i>Curve</i> , distance <i>Double precision</i> ) : <i>MultiPoint</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a set of equidistant points interpolated along a line; the returned geometry
					always corresponds to a MULTIPOINT supporting the M coordinate (representing the
                                        progressive distance for each interpolated Point).<br>
					Second argument represents the regular distance between interpolated points.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>Line_Locate_Point</b></td>
				<td>Line_Locate_Point( line <i>Curve</i> , point <i>Point</i> ) : <i>Double precision</i><hr>
					ST_Line_Locate_Point( line <i>Curve</i> , point <i>Point</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a number (between <b>0.0</b> and <b>1.0</b>) representing the location of the closest 
					point on LineString to the given Point, as a fraction of total 2d line length.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>Line_Substring</b></td>
				<td>Line_Substring( line <i>Curve</i> , start_fraction <i>Double precision</i> , 
					end_fraction <i>Double precision</i> ) : <i>Curve</i><hr>
					ST_Line_Substring( line <i>Curve</i> , start_fraction <i>Double precision</i> , 
					end_fraction <i>Double precision</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Return a Linestring being a substring of the input one starting and ending at the given fractions of total 2d length.<br>
					Second and third arguments are expected to be in the range between <b>0.0</b> and <b>1.0</b>.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>ClosestPoint</b></td>
				<td>ClosestPoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Point</i><hr>
					ST_ClosestPoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Point</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Returns the Point on geom1 that is closest to geom2.<br>
					NULL is returned for invalid arguments (or if distance is ZERO)</td></tr>
			<tr><td><b>ShortestLine</b></td>
				<td>ShortestLine( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Curve</i><hr>
					ST_ShortestLine( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Returns the shortest line between two geometries.<br>
					NULL is returned for invalid arguments (or if distance is ZERO)</td></tr>
			<tr><td><b>Snap</b></td>
				<td>Snap( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Geometry</i><hr>
					ST_Snap( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Returns a new Geometry representing a modified <b>geom1</b>, so to "snap" vertices and segments to <b>geom2</b> vertices;
					a snap distance tolerance is used to control where snapping is performed.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>Collect</b></td>
				<td>Collect( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Collect( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>a generic Geometry (possibly a GEOMETRYCOLLECTION) will be returned merging <b>geom1</b> and <b>geom2</b><hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>Collect</b></td>
				<td>Collect( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Collect( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>a generic Geometry (possibly a GEOMETRYCOLLECTION) will be returned merging input Geometries all together<br>
				<b><u>aggregate function</u></b><hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>LineMerge</b></td>
				<td>LineMerge( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_LineMerge( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i> or <i>MULTILINESTRING</i>) will be returned.<br>
				The input Geometry is expected to represent a <i>LINESTRING</i> or a <i>MULTILINESTRING</i>.<br> 
				The input Geometry can be an arbitrary collection of sparse line fragments: this
				function will then try to (possibly) reassemble them into one (or more) Linestring(s).<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>BuildArea</b></td>
				<td>BuildArea( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_BuildArea( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>a Geometry (actually corresponding to a <i>POLYGON</i> or <i>MULTIPOLYGON</i>) will be returned.<br>
				The input Geometry is expected to represent a <i>LINESTRING</i> or a <i>MULTILINESTRING</i>.<br> 
				The input Geometry can be an arbitrary collection of sparse Linestrings: this
				function will then try to (possibly) reassemble them into one (or more) polygon(s).<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>Polygonize</b></td>
				<td>Polygonize( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Polygonize( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Exactly the same as <b>ST_BuildArea</b>, but implemented as an <b><u>aggregate function</u></b>.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>MakePolygon</b></td>
				<td>MakePolygon( geom1 <i>Geometry</i> [ , geom2 <i>Geometry</i> ] ) : <i>Geometry</i><hr>
					ST_MakePolygon( geom1 <i>Geometry</i> [ , geom2 <i>Geometry</i> ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Kind of lightweight/simplified <b>ST_BuildArea</b>: the first input Geometry is always expected to represent a closed <i>LINESTRING</i> assumed to identify the output polygon's Exterior Ring.<br>
                                The second input Geometry (if any) is expected to be a <i>LINESTRING</i> or <i>MULTILINESTRING</i> identifying any polygon's Interior Ring (and all them are expected to be correctly closed).<br>
                                <b><u>Please note well</u></b>: this function doesn't perform any internal topology check, so it could possibly return an invalid polygon on invalid input.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>UnaryUnion</b></td>
				<td>UnaryUnion( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_UnaryUnion( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Exactely the same as <b><u>ST_Union</u></b>, but applied to a single Geometry.<br>
					(<i>set union of elementary Geometries within a MULTI- or GEOMETRYCOLLECTION complex Geometry</i>)<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>DrapeLine</b></td>
				<td>ST_DrapeLine( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_DrapeLine( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , tolerance <i>Double</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Will return a <i>3D Linestring</i> by draping <i>geom1</i> over <i>geom2</i>:
				<ul>
					<li><b>geom1</b> is expected to be a <i>2D Linestring</i> (<i>XY</i> or <i>XYM</i> dimensions).</li>
					<li><b>geom2</b> is expected to be a <i>3D Linestring</i> (<i>XYZ</i> or <i>XYZM</i> dimensions).</li>
					<li>both <b>geom1</b> and <b>geom2</b> must share the same <b>SRID</b>.</li>
					<li>the option <b>tolerance</b> is the distance radius between corresponding 2D and 3d points.<br>
					    By default a <b>0.0</b> tolerance is intended, thus implying an exact coincidence of <b>X</b> and <b>Y</b> coordinates.</li>
				</ul>
				<u>Note</u>: The returned Linestring will contain all Vertices defined by <i>geom1</i> faithfully preserving their <b>X</b> and <b>Y</b> values; 
				<b>Z</b> and <b>M</b> values will be recovered from the corresponding 3D Vertex from <i>geom2</i>, or will be
				possibily interpolated if no direct match exists.<br>
				If neither a direct match nor interpolation can be applied then <b>Z</b> and <b>M</b> will assume a conventional <b>0.0</b> value.<hr>
				NULL will be returned on invalid arguments or if any error is encountered.</td></tr>
			<tr><td><b>DrapeLineExceptions</b></td>
				<td>ST_DrapeLineExceptions( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_DrapeLineExceptions( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , tolerance <i>Double</i> ) : <i>Geometry</i><hr>
					ST_DrapeLineExceptions( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , tolerance <i>Double</i> , interpolated <i>Bool</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Will return a <i>3D MultiPoint</i> containing all undraped Vertices encountered when draping <i>geom1</i> over <i>geom2</i>:
				<ul>
					<li><i>geom1</i>, <i>geom2</i> and <i>tolerance</i> exactly have the same interpretation as in <b>ST_DrapeLine()</b>.</li>
					<li>the option <b>interpolated</b> argument has the following interpreation:
						<ul>
							<li>if <i>FALSE</i> all 2D Vertices lacking a matching 3D Vertex will be inserted into the returned MultiPoint, even when <b>Z</b> and/or <b>M</b> values
							have been succesfully interpolated.</li>
							<li>if <i>TRUE</i> only 2D Vertices completely lacking <b>Z</b> and/or <b>M</b> values (defaulting to <b>0.0</b>) will be inserted into the returned MultiPoint.</li>
							<li>if not specified then <i>TRUE</i> is assumed by default.</li>
						</ul>
					</li>
				</ul>
				NULL will be returned on invalid arguments, or if any error is encountered or if there aren't undraped Vertices.</td></tr>
			<tr><td><b>DissolveSegments</b></td>
				<td>DissolveSegments( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_DissolveSegments( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i>, <i>MULTILINESTRING</i> or <i>GEOMETRYCOLLECTION</i>) 
				will be returned.<br>
				The input Geometry is arbitrary: any <i>POINT</i> will remain unaffected, but any <i>LINESTRING</i>
				or <i>RING</i> will be dissolved into elementary segments.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>DissolvePoints</b></td>
				<td>DissolvePoints( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_DissolvePoints( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>POINT</i> or <i>MULTIPOINT</i>) 
				will be returned.<br>
				The input Geometry is arbitrary: any <i>POINT</i> will remain unaffected, but any <i>LINESTRING</i>
				or <i>RING</i> will be dissolved into elementary Points corresponding to each Vertex.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>LinesFromRings</b></td>
				<td>LinesFromRings( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_LinesFromRings( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i> or <i>MULTILINESTRING</i>) 
				will be returned.<br>
				The input Geometry is expected to be a <i>POLYGON</i> or <i>MULTIPOLYGON</i>;
				any <i>RING</i> will then be transformed into the corresponding <i>LINESTRING</i>.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>LinesCutAtNodes</b></td>
				<td>LinesCutAtNodes( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_LinesCutAtNodes( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i> or <i>MULTILINESTRING</i>) 
				will be returned.<br>
				The first input Geometry is expected to be a <i>LINESTRING</i> or <i>MULTILINESTRING</i> (<b>Lines</b>);
				the second input Geometry is expected to be a <i>POINT</i> or <i>MULTIPOINT</i> (<b>Nodes</b>).<br>
				any <i>Line</i> will then be possibly split in two halves where some vertex exactly intercepts a <i>Node</i>.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>RingsCutAtNodes</b></td>
				<td>RingsCutAtNodes( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_RingsCutAtNodes( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i> or <i>MULTILINESTRING</i>) 
				will be returned.<br>
				The input Geometry is expected to be a <i>POLYGON</i> or <i>MULTIPOLYGON</i> (<b>Rings</b>);
				any self-intersection or intersection between Rings is assumed to represent a <b>Node</b>.<br>
				any <i>Ring</i> will then be possibly split in two halves where some vertex exactly intercepts a <i>Node</i>.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>CollectionExtract</b></td>
				<td>CollectionExtract( geom <i>Geometry</i> , type <i>Integer</i> ) : <i>Geometry</i><hr>
					ST_CollectionExtract( geom <i>Geometry</i> , type <i>Integer</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Given any arbitrary GEOMETRY will return a derived geometry consisting only of the specified type.
				Sub-geometries that are not the specified type are ignored.<br>
				<ul>
					<li><b>1</b> = POINT-type</li>
					<li><b>2</b> = LINESTRING-type</li>
					<li><b>3</b> = POLYGON-type</li>
				</ul>
				NULL will be returned if any error is encountered (or when no item of required type is found)<br>
				The Type of the returned Geometry could be e.g. <b>POINT</b> or <b>MULTIPOINT</b> depending on actual items count.</td></tr>
			<tr><td><b>ExtractMultiPoint</b></td>
				<td>ExtractMultiPoint( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Given any arbitrary GEOMETRY will return a derived <b>MULTIPOINT</b> geometry.
				Sub-geometries not being of the <b>POINT</b> type will be ignored.<br>
				NULL will be returned if any error is encountered (or when no POINT is found).</td></tr>
			<tr><td><b>ExtractMultiLinestring</b></td>
				<td>ExtractMultiLinestring( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Given any arbitrary GEOMETRY will return a derived <b>MULTILINESTRING</b> geometry.
				Sub-geometries not being of the <b>LINESTRING</b> type will be ignored.<br>
				NULL will be returned if any error is encountered (or when no LINESTRING is found).</td></tr>
			<tr><td><b>ExtractMultiPolygon</b></td>
				<td>ExtractMultiPolygon( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Given any arbitrary GEOMETRY will return a derived <b>MULTIPOLYGON</b> geometry.
				Sub-geometries not being of the <b>POLYGON</b> type will be ignored.<br>
				NULL will be returned if any error is encountered (or when no POLYGON is found).</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p14c">SQL functions that implement spatial operators<br>[GEOS advanced features]</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>DelaunayTriangulation</b></td>
				<td>DelaunayTriangulation( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ) : <i>Geometry</i><hr>
					ST_DelaunayTriangulation( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0b0">GEOS-advanced</td>
				<td>return a geometric object representing the Delaunay Triangulation corresponding to the input Geometry<hr>
					The input Geometry could have any arbitrary type; eventually all Linestring's / Polygon's vertices will be dissolved into Points, so to implicitly always get a MultiPoint.<br>
					The returned Geometry will usually be of the <b>MultiPolygon</b> type (a collection of Triangles), but will be a <b>MultiLinestring</b> if the optional <b>edges_only</b> argument is set to <b>TRUE</b><br>
                                        The optional argument <b>tolerance</b> is intended to normalize the input Geometry, suppressing repeated (or too close) Points.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>VoronojDiagram</b></td>
				<td>VoronojDiagram( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , frame_extra_size <i>Double precision</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i><hr>
					ST_VoronojDiagram( geom <i>Geometry</i> [ , edges_only <i>Boolean</i>  [ , frame_extra_size <i>Double precision</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0b0">GEOS-advanced</td>
				<td>return a geometric object representing the Voronoj Diagram corresponding to the input Geometry<hr>
					The input Geometry could have any arbitrary type; eventually all Linestring's / Polygon's vertices will be dissolved into Points, so to implicitly always get a MultiPoint.<br>
					The returned Geometry will usually be of the <b>MultiPolygon</b> type, but will be a <b>MultiLinestring</b> if the optional <b>edges_only</b> argument is set to <b>TRUE</b><br>
                                        The optional argument <b>extra_frame_size</b> allows to arbitrarily set the <i>percent</i> extension of the bounding frame: the default value is <b>5%</b>.<br>
                                        The optional argument <b>tolerance</b> is intended to normalize the input Geometry, suppressing repeated (or too close) Points.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>ConcaveHull</b></td>
				<td>ConcaveHull( geom <i>Geometry</i> [ , factor <i>Double precision</i> [ , allow_holes <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i><hr>
					ST_ConcaveHull( geom <i>Geometry</i> [ , factor <i>Double precision</i> [ , allow_holes <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0b0">GEOS-advanced</td>
				<td>return a geometric object representing the ConcaveHull corresponding to the input Geometry<hr>
					The input Geometry could have any arbitrary type; eventually all Linestring's / Polygon's vertices will be dissolved into Points, so to implicitly always get a MultiPoint.<br>
					The returned Geometry will always be of the <b>Polygon</b> or <b>MultiPolygon</b> type.<br>
                                        The default <b>factor</b> applies a <b>3&sigma;</b> filtering; by declaring some <i>lower</i> factor you can get a more aggressive filtering effect.<br>
                                        By setting the optional <b>allow_holes</b> argument to <b>TRUE</b> all <i>interior holes</i> will be preserved.<br>
                                        The optional argument <b>tolerance</b> is intended to normalize the input Geometry, suppressing repeated (or too close) Points.<br>
					NULL is returned on failure.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p14d">SQL functions that implement spatial operators<br>[RTTOPO features]</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>MakeValid</b></td>
				<td>MakeValid( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_MakeValid( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return a geometric object representing the <i>repaired</i> version of the input Geometry.<br>
                                        If the input Geometry was already valid, then it will be returned exactly as it was.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>MakeValidDiscarded</b></td>
				<td>MakeValidDiscarded( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_MakeValidDiscarded( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return a geometric object containing all elements that would be eventually <i>discarded</i> by ST_MakeValid() while validating the same input Geometry.<br>
					NULL is returned on failure, or if no <i>discarded</i> item exists.</td></tr>
			<tr><td><b>Segmentize</b></td>
				<td>Segmentize( geom <i>Geometry</i>, dist <i>Double precision</i>  ) : <i>Geometry</i><hr>
					ST_Segmentize( geom <i>Geometry</i> , dist <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return a new Geometry corresponding to the input Geometry; as much Linestring / Ring vertices 
                                        as required will be eventually interpolated so to ensure that no segment will be longer than <i>dist</i>.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>Split</b></td>
				<td>Split( geom <i>Geometry</i>, blade <i>Geometry</i>  ) : <i>Geometry</i><hr>
					ST_Split( geom <i>Geometry</i> , blade <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return a new Geometry collecting all items resulting by splitting the input Geometry by the <i>blade</i>.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>SplitLeft</b></td>
				<td>SplitLeft( geom <i>Geometry</i>, blade <i>Geometry</i>  ) : <i>Geometry</i><hr>
					ST_SplitLeft( geom <i>Geometry</i> , blade <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return a new Geometry collecting all items resulting by splitting the input Geometry by the <i>blade</i> and falling on the <i>left side</i>.<br>
                                        All items not affected by the split operation (i.e. not intersecting the <i>blade</i>) will be returned into the <i>left</i> collection.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>SplitRight</b></td>
				<td>SplitRight( geom <i>Geometry</i>, blade <i>Geometry</i>  ) : <i>Geometry</i><hr>
					ST_SplitRight( geom <i>Geometry</i> , blade <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return a new Geometry collecting all items resulting by splitting the input Geometry by the <i>blade</i> and falling on the <i>right side</i>.<br>
					NULL is returned on failure (or if the <i>right side</i> is empty).</td></tr>
			<tr><td><b>Azimuth</b></td>
				<td>Azimuth( pt1 <i>Geometry</i>, pt2 <i>Geometry</i>  ) : <i>Double precision</i><hr>
					ST_Azimuth( pt1 <i>Geometry</i> , pt2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return the angle (in radians) from the horizontal of the vector defined by <b>pt1</b> and <b>pt2</b>.<br>
                                        Both <b>pt1</b> and <b>pt2</b> are expected to be simple Points.<br>
					Starting since <u>4.1.0</u> if both points supports <u>long/lat</u> coords the returned Azimuth will be precisely computed on the ellipsoid.<br>
					NULL is returned on failure.<hr>
                                        On the clock: 12=0; 3=PI/2; 6=PI; 9=3PI/2</td></tr>
			<tr><td><b>Project</b></td>
				<td>Project( start_point <i>Geometry</i>, distance <i>Double precision</i>, azimuth <i>Double precision</i>  ) : <i>Geometry</i><hr>
					ST_Project( start_point <i>Geometry</i>, distance <i>Double precision</i>, azimuth <i>Double precision</i>  ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return a new Point projected from a start point using a bearing and distance.<br>
                                        <b>start_point</b> is expected to be simple <u>long/lat</u> Point.<br>
					<b>distance</b> is expected to be measured in <u>meters</u>; <b>azimuth</b> (aka <u>bearing</u> or <u>heading</u>) has the same identical meaning as in <b>ST_Azimuth()</b>.<br>
					NULL is returned on failure or on invalid arguments.</td></tr>
			<tr><td><b>SnapToGrid</b></td>
				<td>SnapToGrid( geom <i>Geometry</i> , size <i>Double precision</i>  ) : <i>Geometry</i><br>
				        SnapToGrid( geom <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> ) : <i>Geometry</i><br>
				        SnapToGrid( geom <i>Geometry</i> , origin_x <i>Double precision</i> , origin_y <i>Double precision</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> ) : <i>Geometry</i><br>
                                        SnapToGrid( geom <i>Geometry</i> , origin <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> , size_z <i>Double precision</i> , size_m <i>Double precision</i> ) : <i>Geometry</i><hr>
					ST_SnapToGrid( geom <i>Geometry</i> , size <i>Double precision</i>  ) : <i>Geometry</i><br>
					ST_SnapToGrid( geom <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> )  ) : <i>Geometry</i><br>
                                        ST_SnapToGrid( geom <i>Geometry</i> , origin_x <i>Double precision</i> , origin_y <i>Double precision</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> )  ) : <i>Geometry</i><br>
                                        ST_SnapToGrid( geom <i>Geometry</i> , origin <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> , size_z <i>Double precision</i> , size_m <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a new Geometry corresponding to the input Geometry; all points and vertices will be snapped to the grid defined by its origin and size(s).<br>
                                        Removes all consecutive points falling on the same cell.<br>
                                        All collapsed geometries will be stripped from the returned Geometry.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>GeoHash</b></td>
				<td>GeoHash( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i><hr>
					ST_GeoHash( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>Return a GeoHash representation (geohash.org) of the geometry.<br>
                                    A GeoHash encodes a point into a text form that is sortable and searchable based on prefixing.<br>
                                    <ul>
										<li>If no <i>precision</i> is specficified ST_GeoHash returns a GeoHash based on full precision of the input geometry type.<br>
                                        Points return a GeoHash with 20 characters of precision (about enough to hold the full double precision of the input).</li>
                                        <li>Other types return a GeoHash with a variable amount of precision, based on the size of the feature.
                                        Larger features are represented with less precision, smaller features with more precision.
                                        The idea is that the box implied by the GeoHash will always contain the input feature.</li>
                                        <li>When explicitly set the <i>precision</i> argument will determine how many characters should by used by the returned GeoHash.</li>
                                    </ul><hr>
                                    ST_GeoHash will not work with geometries that are not in geographic (lon/lat) coordinates</td></tr>
			<tr><td><b>AsX3D</b></td>
				<td>AsX3D( geom <i>Geometry</i> ) : <i>String</i><br>
				AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> ) : <i>String</i><br>
				AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> ) : <i>String</i><br>
				AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> , refid <i>String</i> ) : <i>String</i><hr>
				ST_AsX3D( geom <i>Geometry</i> ) : <i>String</i><br>
				ST_AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> ) : <i>String</i><br>
				ST_AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> ) : <i>String</i><br>
				ST_AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> , refid <i>String</i> ) : <i>String</i>
</td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>Returns a geometry as an X3D XML formatted node element.</td></tr>
			<tr><td><b>MaxDistance</b></td>
				<td>MaxDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i><hr>
					ST_MaxDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return the max distance between geom1 and geom2</td></tr>
			<tr><td><b>3DDistance</b></td>
				<td>ST_3DDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return the 3D-distance between geom1 and geom2 (Z coordinates will be considered)</td></tr>
			<tr><td><b>3DMaxDistance</b></td>
				<td>ST_3DMaxDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return the max 3D-distance between geom1 and geom2 (Z coordinates will be considered)</td></tr>
			<tr><td><b>3dLength</b></td>
				<td>ST_3dLength( geom <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>return the total 2D or 3D-length of <i>Linestring</i> or <i>MultiLinestring</i> geometry.<br>
				Z coordinates if eventually present will be considered leading to a 3D measured length; otherwise a 2D length will be computed.</td></tr>
			<tr><td><b>ST_Node</b></td>
				<td>ST_Node( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>Fully nodes a set of linestrings using the least possible number of nodes while preserving all of the input ones.<br>
                                <b>NULL</b> will be returned if the input Geometry isn't a set of linestrings or if any other error occurs.</td></tr>
			<tr><td><b>SelfIntersections</b></td>
				<td>SelfIntersections( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
                                	ST_SelfIntersections( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td>Returns a MultiPoint Geometry representing any self-intersection found within the input geometry
					[expected to be of the Linestring or MultiLinestring type].<br>
                                <b>NULL</b> will be returned for invalid arguments, or when no self-intersections were found.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p15">SQL functions for coordinate transformations</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Transform</b></td>
				<td>Transform( geom <i>Geometry</i> , newSRID <i>Integer</i> ) : <i>Geometry</i><hr>
					ST_Transform( geom <i>Geometry</i> , newSRID <i>Integer</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ</td>
				<td>return a geometric object obtained by reprojecting coordinates into the Reference System identified by newSRID</td></tr>
			<tr><td><b>TransformXY</b></td>
				<td>TransformXY( geom <i>Geometry</i> , newSRID <i>Integer</i> ) : <i>Geometry</i><hr>
					ST_TransformXY( geom <i>Geometry</i> , newSRID <i>Integer</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ</td>
				<td>this is a <i>special flavor</i> of <b>ST_Transform()</b>; just <b>X</b> and <b>Y</b> coordinates will be transformed,
				<b>Z</b> and <b>M</b> values (if eventually present) will be left untouched.<br>
				<table bgcolor="#ffb080"><tr><td>
				Mainly intended as a workaround for (possibly) imprecise <i><u>+towsg84 PROJ</u></i> definitions; should never be used as a<i>ST_Transform()</i>
				replacement without a very careful evaluation.</td></tr></table>
				</td></tr>
			<tr><td><b>SridFromAuthCRS</b></td>
				<td>SridFromAuthCRS( auth_name <i>String</i> , auth_SRID <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the internal SRID corresponding to <b>auth_name</b> and <b>auth_SRID</b><br>
				<b>-1</b> will be returned if no such CRS is defined </td></tr>
			<tr><td><b>ShiftCoords</b><br><b>ShiftCoordinates</b></td>
				<td>ShiftCoords( geom <i>Geometry</i> , shiftX <i>Double precision</i> , shiftY <i>Double precision</i> ) : <i>Geometry</i><hr>
					ShiftCoordinates( geom <i>Geometry</i> , shiftX <i>Double precision</i> , shiftY <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by translating coordinates according to shiftX and shiftY values</td></tr>
			<tr><td><b>ST_Translate</b></td>
				<td>ST_Translate( geom <i>Geometry</i> , shiftX <i>Double precision</i> , shiftY <i>Double precision</i> , shiftZ <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by translating coordinates according to shiftX, shiftY and shiftZ values</td></tr>
			<tr><td><b>ST_Shift_Longitude</b></td>
				<td>ST_Shift_Longitude( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by translating any negative longitude by 360.<hr>
				Only meaningful for geographic (longitude/latitude) coordinates.<br>
                                Negative longitudes (-180/0) will be shifted by 360, thus allowing to represent longitudes in the 0/360 range and effectively crossing the International Date Line. </td></tr>
			<tr><td><b>NormalizeLonLat</b></td>
				<td>NormalizeLonLat( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by normalizing any longitude in the range
                                [-180 / +180] and any latitude in the range [-90 / + 90].<hr>
				Only meaningful for geographic (longitude/latitude) coordinates.</td></tr>
			<tr><td><b>ScaleCoords</b><br><b>ScaleCoordinates</b></td>
				<td>ScaleCoords( geom <i>Geometry</i> , scaleX <i>Double precision</i> [ , scaleY <i>Double precision</i> ] ) : <i>Geometry</i><hr>
					ScaleCoordinates( geom <i>Geometry</i> , scaleX <i>Double precision</i> [ , scaleY <i>Double precision</i> ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by scaling coordinates according to scaleX and scaleY values<hr>
					if only one scale factor is specified, then an <i>isotropic</i> scaling occurs 
					[i.e. the same scale factor is applied to both axis]<br>
					otherwise an <i>anisotropic</i> scaling occurs [i.e. each axis is scaled according to its own scale factor]</td></tr>
			<tr><td><b>RotateCoords</b><br><b>RotateCoordinates</b></td>
				<td>RotateCoords( geom <i>Geometry</i> , angleInDegrees <i>Double precision</i> ) : <i>Geometry</i><hr>
					RotateCoordinates( geom <i>Geometry</i> , angleInDegrees <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by rotating coordinates according to angleInDegrees value.<hr>
Positive angle = clockwise rotation.<br>
Negative angle = counterclockwise rotation.</td></tr>
			<tr><td><b>ReflectCoords</b><br><b>ReflectCoordinates</b></td>
				<td>ReflectCoords( geom <i>Geometry</i> , xAxis <i>Integer</i> , yAxis <i>Integer</i> ) : <i>Geometry</i><hr>
					ReflectCoordinates( geom <i>Geometry</i> , xAxis <i>Integer</i> , yAxis <i>Integer</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by reflecting coordinates according to xAxis and yAxis switches<hr>
					i.e. if xAxis is 0 (FALSE), then x-coordinates remains untouched; otherwise x-coordinates will be reflected</td></tr>
			<tr><td><b>SwapCoords</b><br><b>SwapCoordinates</b></td>
				<td>SwapCoords( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					SwapCoordinates( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by swapping x- and y-coordinates</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">	
				<h3><a name="p14e">SQL functions supporting Geodesic Arcs</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>GeodesicArcLength</b></td>
				<td>GeodesicArcLength( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i><hr>
				    GeodesicArcLength( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , meters <i>Boolean</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ GEODESIC</td>
				<td>returns  the Arc length (distance) between <i>geom1</i> and <i>geom2</i> as the <b>surface</b> measurement of the outer circle arc / earth surface.<br>
				if <i>meters = 0</i> the result will be in degrees, otherwise meters [<b>default</b>].
				<hr>
				will return <b>NULL</b> on invalid arguments, or if PROJ GEODESIC is not supported.</td></tr>
			<tr><td><b>GeodesicChordLength</b></td>
				<td>GeodesicChordLength( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i><hr>
				    GeodesicChordLength( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , meters <i>Boolean</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ GEODESIC</td>
				<td>returns the length of the shortest line (distance) between <i>geom1</i> and <i>geom2</i> <b>through</b> the outer circle / earth surface.<br>
				if <i>meters = 0</i> the result will be in degrees, otherwise meters [<b>default</b>].
				<hr>
				will return <b>NULL</b> on invalid arguments, or if PROJ GEODESIC is not supported.</td></tr>
			<tr><td><b>GeodesicCentralAngle</b></td>
				<td>GeodesicCentralAngle( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i><hr>
				    GeodesicCentralAngle( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , radians <i>Boolean</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ GEODESIC</td>
				<td>returns the angle from the circle center to the <i>geom1</i> and <i>geom2</i> on the outer circle / earth surface.<br>
				if <i>radians = 0</i> the result will be in degrees, otherwise radians [<b>default</b>].
				<hr>
				will return <b>NULL</b> on invalid arguments, or if PROJ GEODESIC is not supported.</td></tr>
			<tr><td><b>GeodesicArcArea</b></td>
				<td>GeodesicArcArea( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ GEODESIC</td>
				<td>returns the area of the segment/arc  between the <b>Chord</b> and <b>Arc</b>, created by <i>geom1</i> and <i>geom2</i>, inside the outer circle / earth surface.<br>
				Since the <b>Radius</b> is in meters, only meter values can be returned.
				<hr>
				will return <b>NULL</b> on invalid arguments, or if PROJ GEODESIC is not supported.</td></tr>
			<tr><td><b>GeodesicArcHeight</b></td>
				<td>GeodesicArcHeight( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ GEODESIC</td>
				<td>returns  the height of the segment/arc (short-Sagitta) between the <b>Chord</b> and <b>Arc</b>, created by <i>geom1</i> and <i>geom2</i>, inside the outer circle / earth surface.<br>
				Since the <b>Radius</b> is in meters, only meter values can be returned.
				<hr>
				will return <b>NULL</b> on invalid arguments, or if PROJ GEODESIC is not supported.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">	
				<h3><a name="p15plus">SQL functions supporting Affine Transformations and Ground Control Points</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>ATM_Create</b></td>
				<td>ATM_Create( <i>void</i> ) : <i>AffineMatrix</i><hr>
				ATM_Create( a <i>Integer</i> , b <i>Integer</i> , d <i>Integer</i> , e <i>Integer</i> , xoff <i>Integer</i> , yoff <i>Integer</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_Create( a <i>Integer</i> , b <i>Integer</i> , c <i>Integer</i> , d <i>Integer</i> , e <i>Integer</i>  , f <i>Integer</i> , 
				g <i>Integer</i> , h <i>Integer</i> , i <i>Integer</i> , xoff <i>Integer</i> , yoff <i>Integer</i> , zoff <i>Integer</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix.
				<ul>
					<li>the first form (no arguments) will return an <b>Identity</b> matrix.</li>
					<li>the second and third forms will respectively return a fully initialized <b>2D</b> or <b>3D</b> Affine Transformation matrix.</li>
				</ul><hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_CreateTranslate</b></td>
				<td>ATM_CreateTranslate( tx <i>Double precision</i> , ty <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_CreateTranslate( tx <i>Double precision</i> , ty <i>Double precision</i> , tz <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>2D</b> or <b>3D Translate</b> transformation.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_CreateScale</b></td>
				<td>ATM_CreateScale( sx <i>Double precision</i> , sy <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_CreateScale( sx <i>Double precision</i> , sy <i>Double precision</i> , sz <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>2D</b> or <b>3D Scale</b> transformation.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_CreateRotate</b></td>
				<td>ATM_CreateRotate( angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_CreateZRoll( angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>Rotate</b> transformation (along the <b>Z axis</b>).<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_CreateXRoll</b></td>
				<td>ATM_CreateXRoll( angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>Rotate</b> transformation (along the <b>X axis</b>).<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_CreateYRoll</b></td>
				<td>ATM_CreateYRoll( angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>Rotate</b> transformation (along the <b>Y axis</b>).<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_Multiply</b></td>
				<td>ATM_Multiply( matrixA <i>AffineMatrix</i> , matrixB <i>AffineMatrix</i> ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing the result of multiplying <b>matrixA</b> by <b>matrixB</b>.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_Translate</b></td>
				<td>ATM_Translate( matrix <i>AffineMatrix</i> , tx <i>Double precision</i> , ty <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_CreateTranslate( matrix <i>AffineMatrix</i> , tx <i>Double precision</i> , ty <i>Double precision</i> , tz <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>2D</b> or <b>3D Translate</b> to a previous transformation matrix.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_Scale</b></td>
				<td>ATM_Scale( matrix <i>AffineMatrix</i> , sx <i>Double precision</i> , sy <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_Scale( matrix <i>AffineMatrix</i> , sx <i>Double precision</i> , sy <i>Double precision</i> , sz <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>2D</b> or <b>3D Scale</b> to a previous transformation matrix.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_Rotate</b></td>
				<td>ATM_Rotate( matrix <i>AffineMatrix</i> , angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_ZRoll( matrix <i>AffineMatrix</i> , angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>Rotate</b> (along the <b>Z axis</b>) to a previous transformation matrix.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_XRoll</b></td>
				<td>ATM_XRoll( matrix <i>AffineMatrix</i> , angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>Rotate</b> (along the <b>X axis</b>) to a previous transformation matrix.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_YRoll</b></td>
				<td>ATM_YRoll( matrix <i>AffineMatrix</i> , angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>Rotate</b> (along the <b>Y axis</b>) to a previous transformation matrix.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_Determinant</b></td>
				<td>ATM_Determinant( matrix <i>AffineMatrix</i> ] ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the Determinant from an Affine Transformation matrix.<hr>
				will return <b>0.0</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_IsInvertible</b></td>
				<td>ATM_IsInvertible( matrix <i>AffineMatrix</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return <b>1</b> if the Affine Transformation matrix can be inverted, <b>0</b> if not.<hr>
				will return <b>-1</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_Invert</b></td>
				<td>ATM_Invert( matrix <i>AffineMatrix</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return an inverted Affine Transformation matrix.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_IsValid</b></td>
				<td>ATM_IsValid( matrix <i>AffineMatrix</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return <b>1</b> if the BLOB argument really contains a valid Affine Transformation matrix, <b>0</b> if not.<hr>
				will return <b>-1</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_AsText</b></td>
				<td>ATM_AsText( matrix <i>AffineMatrix</i> ] ) : <i>Text</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a serialized text string corresponding to an Affine Transformation matrix.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_Transform</b></td>
				<td>ATM_Transform( geom <i>Geometry</i> , matrix <i>AffineMatrix</i> [ , newSRID <i>Integer</i> ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by applying an Affine Transformation; if the optional arg newSRID is defined then the returned Geometry will assume the corresponding 
				Reference System, otherwise it will preserve the same Reference System of the input Geometry.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>GCP_Compute</b></td>
				<td>GCP_Compute( pointA <i>Geometry</i> , pointB <i>Geometry</i> [ order <i>Integer</i>] ) : <i>PolynomialCoeffs</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return BLOB-encoded objects containing Polynomial coefficients computed from a set of matching <b>Ground Control Points</b> pairs.
				<ul>
					<li><b>pointA</b> corresponds to the origin Reference System; <b>pointB</b> corresponds to the destination target.</li>
					<li>the input Geometries must be of the <b>Point</b> type and must have the same dimensions</li>
					<li>if the points have <b>XYZ</b> or <b>XYZM</b> dimensions then <b>3D coeffs</b> will be returned, otherwise <b>2D</b> coeffs will be return.</li>
					<li>the optional <b>order</b> argument can assume the following values:
					<ul>
						<li><b>0</b>: a set of <b>2D coeffs</b> will be returned by applying the <b>Thin Plate Spline</b> method.</li>
						<li><b>1</b>: (<i>default setting</i>) a set of <b>2D</b> or <b>3D</b> Polynomial coeffs of the <b>1st order</b> will be returned.</li>
						<li><b>2</b>: a set of <b>2D</b> or <b>3D</b> Polynomial coeffs of the <b>2nd order</b> will be returned.</li>
						<li><b>3</b>: a set of <b>2D</b> or <b>3D</b> Polynomial coeffs of the <b>3rd order</b> will be returned.</li>
					</ul></li>
				</ul><hr>
				will return <b>NULL</b> on invalid arguments<hr>
				<u><b>aggreagate function</b></u></td></tr>
			<tr><td><b>GCP_IsValid</b></td>
				<td>GCP_IsValid( matrix <i>PolynomialCoeffs</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return <b>1</b> if the BLOB argument really contains valid Polynomial coeffs, <b>0</b> if not.<hr>
				will return <b>-1</b> on invalid argument.</td></tr>
			<tr><td><b>GCP_AsText</b></td>
				<td>GCP_AsText( matrix <i>PolynomialCoeffs</i> ] ) : <i>Text</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return a serialized text string corresponding to the Polynomial coeffs.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>GCP2ATM</b></td>
				<td>GCP2ATM( matrix <i>PolynomialCoeffs</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return an Affine Transformation matrix corresponding to the Polynomial coeffs.<br>
				Only a set of Polynomial coeffs of the <b>1st order</b> can be converted to an Affine Transformation matrix.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>GCP_Transform</b></td>
				<td>GCP_Transform( geom <i>Geometry</i> , coeffs <i>PolynomialCoeffs</i> [ , newSRID <i>Integer</i> ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return a geometric object obtained by applying a Transformation based on Polynomial coefficients of the <b>1st</b>, <b>2nd</b> or <b>3rd order</b>; if the optional arg newSRID is defined then the returned Geometry will assume the corresponding 
				Reference System, otherwise it will preserve the same Reference System of the input Geometry.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16">SQL functions for Spatial-MetaData and Spatial-Index handling</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>InitSpatialMetaData</b></td>
				<td>InitSpatialMetaData( void ) : <i>Integer</i><hr>
					InitSpatialMetaData( transaction <i>Integer</i> ) : <i>Integer</i><hr>
					InitSpatialMetaData( mode <i>String</i> ) : <i>Integer</i><hr>
					InitSpatialMetaData( transaction <i>Integer</i> , mode <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates the <b>geometry_columns</b> and <b>spatial_ref_sys</b> metadata tables<br>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE
<ul>
	<li>if the <i>optional</i> argument <b>transaction</b> is set to <b>TRUE</b> the whole operation will be handled as a single <i>Transaction</i> (faster): the default setting is <b>transaction=FALSE</b> (slower, but safer).</li>
	<li>if the <i>optional</i> argument <b>mode</b> is not specified then any possible ESPG SRID definition will be inserted into the <b>spatial_ref_sys</b> table.</li>
	<li>if the <b>mode</b> arg <b>'WGS84'</b> (alias <b>'WGS84_ONLY'</b>) is specified, then only WGS84-related EPSG SRIDs will be inserted</li>
	<li>if the <b>mode</b> arg <b>'NONE'</b> (alias <b>'EMPTY'</b>) is specified, no EPSG SRID will be inserted at all</li>
</ul></td></tr>
			<tr><td><b>InitSpatialMetaDataFull</b></td>
				<td>InitSpatialMetaDataFull( void ) : <i>Integer</i><hr>
					InitSpatialMetaDataFull( transaction <i>Integer</i> ) : <i>Integer</i><hr>
					InitSpatialMetaDataFull( mode <i>String</i> ) : <i>Integer</i><hr>
					InitSpatialMetaDataFull( transaction <i>Integer</i> , mode <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This one simply is a <i>convenience function</i> accepting the same arguments of <b>InitSpatialMetaData()</b> (with identical meaning).<br>
				The intended scope is to fully initialize all <i>metadata tables</i> required by <i>libspatialite 5.0.0</i> (and following versions).
				This function will internally call in a single pass:
				<ul>
					<li><i>InitSpatialMetaData()</i></li>
					<li><i>CreateRasterCoveragesTable()</i></li>
					<li><i>CreateVectorCoveragesTables()</i></li>
					<li><i>CreateStylingTables()</i></li>
				</ul>the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>InsertEpsgSrid</b></td>
				<td>InsertEpsgSrid( srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Attempts to insert into <b>spatial_ref_sys</b> the EPSG definition uniquely identified by <b>srid</b><br>
				[the corresponding EPSG SRID definition will be copied from the inlined dataset defined in <b>libspatialite</b>]<hr>
the return type is Integer, with a return value of 1 for success or 0 for failure</td></tr>
			<tr><td><b>AddGeometryColumn</b></td>
				<td>AddGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> ,
geom_type <i>String</i> [ , dimension <i>String</i> [ , not_null <i>Integer</i> ] ] ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates a new <u>geometry column</u> updating the Spatial Metadata tables and creating any
required <u>trigger</u> in order to enforce constraints<hr>
				<b>geom_type</b> has to be one of the followings:<ul>
				<li>'POINT', 'POINTZ', 'POINTM', 'POINTZM'</li>
				<li>'LINESTRING', 'LINESTRINGZ', 'LINESTRINGM', 'LINESTRINGZM'</li>
				<li>'POLYGON', 'POLYGONZ', 'POLYGONM', 'POLYGONZM'</li>
				<li>'MULTIPOINT', 'MULTIPOINTZ', 'MULTIPOINTM', 'MULTIPOINTZM'</li>
				<li>'MULTILINESTRING', 'MULTILINESTRINGZ', 'MULTILINESTRINGM', 'MULTILINESTRINGZM'</li>
				<li>'MULTIPOLYGON', 'MULTIPOLYGONZ', 'MULTIPOLYGONM', 'MULTIPOLYGONZM'</li>
				<li>'GEOMETRYCOLLECTION', 'GEOMETRYCOLLECTIONZ', 'GEOMETRYCOLLECTIONZM', 'GEOMETRYCOLLECTIONZM'</li>
				<li>'GEOMETRY', 'GEOMETRYZ', 'GEOMETRYM', 'GEOMETRYZM'</li>
				</ul><b>dimension</b> has to be one of the followings:
				<ul>
				<li><b>'XY'</b> or <b>2</b>: 2D points, identified by <b>X</b> and <b>Y</b> coordinates</li>
				<li><b>'XYM'</b>: 2D points, identified by <b>X</b> and <b>Y</b> coordinates. 
				Each point stores an <b>M</b>-value (<i>measure</i>) as well</li>
				<li><b>'XYZ'</b> or <b>3</b>: 3D points, identified by <b>X</b>, <b>Y</b> and <b>Z</b> coordinates</li>
				<li><b>'XYZM'</b> or <b>4</b>: 3D points, identified by <b>X</b>, <b>Y</b> and <b>Z</b> coordinates. 
				Each point stores an <b>M</b>-value (<i>measure</i>) as well</li>
				</ul>
                                Please note: the <b>dimension</b> argument is optional; anyway, if specified, iy's expected to be consistent with the declared <b>geom_type</b><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<hr>
the optional 6th arg [<b>not_null</b>] is a non-standard extension required by the peculiar SQLite arch:<ul>
				<li>if set to <b>0</b> [<i>false</i>], then the Geometry column will accept NULL values as well.
					This is the <u>default</u> behaviour</li>
				<li>if set to any <b>&lt;&gt; 0 value</b> [<i>true</i>], then the Geometry will be defined using a <b>NOT NULL</b> clause</li>
				</ul></td></tr>
			<tr><td><b>RecoverGeometryColumn</b></td>
				<td>RecoverGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> ,
geom_type <i>String</i> [ , dimension <i>Integer</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Validates an existing ordinary column in order to possibly transform it in a real <u>geometry column</u>,
thus updating the Spatial Metadata tables and creating any required <u>trigger</u> in order to enforce constraints<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>DiscardGeometryColumn</b></td>
				<td>DiscardGeometryColumn( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Removes a <u>geometry column</u> from Spatial MetaData tables and drops any related <u>trigger</u><br>
the column itself still continues to exist untouched as an ordinary, unconstrained column<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>RegisterVirtualGeometry</b></td>
				<td>RegisterVirtualGeometry( table <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Registers a <u>VirtualShape</u> table into Spatial MetaData tables; the VirtualShape table should be previously created by invoking <b>CREATE VIRTUAL TABLE ... USING VirtualShape(...)</b><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>DropVirtualGeometry</b></td>
				<td>DropVirtualGeometry( table <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Removes a <u>VirtualShape</u> table from Spatial MetaData tables, dropping the VirtualShape table as well.<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>CreateSpatialIndex</b></td>
				<td>CreateSpatialIndex( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Builds an RTree <b>Spatial Index</b> on a <u>geometry column</u>, creating any required <u>trigger</u>
required in order to enforce full data coherency between the main table and Spatial Index<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<hr>
-1 will be returned if any physical column named "rowid" (caseless) shadowing the real ROWID is detected.</td></tr>
			<tr><td><b>CreateMbrCache</b></td>
				<td>CreateMbrCache( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Builds an <b>MbrCache</b> on a <u>geometry column</u>, creating any required <u>trigger</u>
required in order to enforce full data coherency between the main table and the MbrCache<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>DisableSpatialIndex</b></td>
				<td>DisableSpatialIndex( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Disables an RTree <b>Spatial Index</b> or <b>MbrCache</b>, removing any related <u>trigger</u><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
		<tr><td><b>CheckShadowedRowid</b></td>
				<td>CheckShadowedRowid( table <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks if some table has a physical column named "rowid" (caseless) shadowing the real ROWID.<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
NULL will be returned if the requested table doesn't exist.</td></tr>
		<tr><td><b>CheckWithoutRowid</b></td>
				<td>CheckWithoutRowid( table <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks if some table was created by specifying a <b>WITHOUT ROWID</b> clause.<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
NULL will be returned if the requested table doesn't exist.</td></tr>
		<tr><td><b>CheckSpatialIndex</b></td>
				<td>CheckSpatialIndex( void ) : <i>Integer</i><hr>
					CheckSpatialIndex( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks an RTree <b>Spatial Index</b> for validity and consistency
				<ul>
					<li>if no arguments are passed, then any RTree defined into <b>geometry_columns</b> will be checked</li>
					<li>otherwise only the RTree corresponding to <b>table</b> and <b>column</b> will be checked</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
NULL will be returned if the requested RTree doesn't exist<hr>
-1 will be returned if any physical column named "rowid" (caseless) shadowing the real ROWID is detected.</td></tr>
		<tr><td><b>RecoverSpatialIndex</b></td>
				<td>RecoverSpatialIndex( [ no_check : <i>Integer</i> ] ) : <i>Integer</i><hr>
					RecoverSpatialIndex( table <i>String</i> , column <i>String</i> [ , no_check : <i>Integer</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Recovers a (<i>possibly broken</i>) RTree <b>Spatial Index</b>
				<ul>
					<li>if no arguments are passed, then any RTree defined into <b>geometry_columns</b> will be recovered</li>
					<li>otherwise only the RTree corresponding to <b>table</b> and <b>column</b> will be recovered</li>
					<li>the <i>optional</i> argument <b>no_check</b> will be interpreted as follows:
						<ul>
							<li>if <b>no_check = FALSE</b> (<i>default</i>) the RTree will be checked first:
								and only an invalid RTree will be then actually rebuilt</li>
							<li>if <b>no_check = TRUE</b> the RTree will be unconditionally rebuilt from scratch</li>
						</ul></li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
NULL will be returned if the requested RTree doesn't exist<hr>
-1 will be returned if any physical column named "rowid" (caseless) shadowing the real ROWID is detected.</td></tr>
		<tr><td><b>GetSpatialIndexExtent</b></td>
				<td>GetSpatialIndexExtent( db_prefix <i>String</i> , table <i>String</i> , column <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Retrieves the Full Extent from an RTree <b>Spatial Index</b> supporting a <b>SpatialTable</b>/<b>SpatialView</b> or a <b>GeoPackage-Geometry</b>.
				<ul>
					<li>The <b>db_prefix</b> argument specifies which one of the ATTACHED databases is expected to contain the RTree; if <b>NULL</b> then the <b>MAIN</b> database will be assumed by default.</li>
					<li>The <b>table</b> and <b>column</b> arguments specifying which Table and Geometry is intended.</li>
				</ul>
				<hr>
				returns a Rectangle (Polygon Geometry). The Polygon is defined by the corner points of the RTree's Full Extent [(MINX, MINY),(MAXX, MINY), (MAXX, MAXY), (MINX, MAXY), (MINX, MINY)].<br>
				<b>NULL</b> will be returned on invalid arguments, or on a not existing Table/Geometry, or if no coresponding Spatial Index exists.<hr>
				<u>Plase note</u>: retrieving the Full Extenxt from an RTree is a very quick operation even when performed on a Table/Geometry containing many million rows.<br>
				<u>Also</u>: The returned Geometry will be a Spatialite-Binary, even when a GeoPackage-Table/Geometry has been requested.</td></tr>
		<tr><td><b>InvalidateLayerStatistics</b></td>
				<td>InvalidateLayerStatistics( [ void ) : <i>Integer</i><hr>
					InvalidateLayerStatistics( table <i>String</i> [ , column <i>String</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Immediately and unconditionally invalidates the internal Layer Statistics<ul>
					<li>if no arguments are passed, then internal statistics will be invalidated 
						for any possible Geometry Column defined in the current DB</li>
					<li>otherwise statistics will be updated only for Geometry Columns
						corresponding to the given table</li>
					</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<hr>
				<u>Please note</u>: will effectively work only on behalf DB-files supporting the more recent metatables layout introduced 
				starting since version <b>4.x</b>; in any other case will always return an error and no action will happen.</td></tr>
		<tr><td><b>UpdateLayerStatistics</b></td>
				<td>UpdateLayerStatistics( void ) : <i>Integer</i><hr>
					UpdateLayerStatistics( table <i>String</i> [ , column <i>String</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Updates the internal Layer Statistics [Feature Count and Total Extent]<ul>
					<li>if no arguments are passed, then internal statistics will be updated 
						for any possible Geometry Column defined in the current DB</li>
					<li>otherwise statistics will be updated only for Geometry Columns
						corresponding to the given table</li>
					</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
		<tr><td><b>GetLayerExtent</b></td>
				<td>GetLayerExtent( table <i>String</i> [ , column <i>String</i> [ , mode <i>Boolean</i>] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Return the Envelope corresponding to the Total Extent (<i>bounding box</i>] of some Layer;
                                    if the Table/Layer only contains a single Geometry column passing the column name isn't strictly required.<br>
                                    The returned extent will be retrieved from the Statistics tables:<ul>
					<li>if the third argument <b>mode</b> is set to TRUE a <b>PESSIMISTIC</b>
                                            strategy will be applied, i.e. an attempt will be made in order to update the Statistics tables before returning the Envelope.</li>
					<li>otherwise the returned Envelope will simply reflect the current values stored into the Statics tables as they are (<b>OPTIMISTIC</b> strategy, adopted by default).</li>
					</ul><hr>
                                        NULL will be returned if any error occurs or if the required table isn't a Layer.</td></tr>
		<tr><td><b>CreateRasterCoveragesTable</b></td>
				<td>CreateRasterCoveragesTable( <i>void</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates the <b>raster_coverages</b> table required by <b>RasterLite-2</b><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure)</td></tr>
		<tr><td><b>CreateVectorCoveragesTables</b></td>
				<td>CreateVectorCoveragesTables( <i>void</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates the <b>vector_coverages</b> and <b>vector_coverages_srid</b> tables required by <b>RasterLite-2</b><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure)</td></tr>
			<tr><td><b>RebuildGeometryTriggers</b></td>
				<td>RebuildGeometryTriggers( table_name <i>String</i> , geometry_column_name <i>String</i> ) : <i>integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will reinstall all geometry-related Triggers for the named table.<hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure)</td></tr>
			<tr><td><b>UpgradeGeometryTriggers</b></td>
				<td>UpgradeGeometryTriggers(  transaction <i>Integer</i>  ) : <i>integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will upgrade all geometry-related Triggers to the latest version 
				(all DB tables declaring at least one Geometry will be affected by the upgrade).<br>
				If the <b>transaction</b> argument is set to TRUE then the whole upgrade will be safely
				executed within an internally defined SQL transaction.<hr>
				<u>Please note</u>: DB-files created using obsolete versions of SpatiaLite (< 4.0.0) will not be upgraded.<hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure)</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16metacatalog">SQL functions supporting the MetaCatalog and related Statistics</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CreateMetaCatalogTables</b></td>
				<td>CreateMetaCatalogTables( transaction <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates both <b>splite_metacatalog</b> and <b>splite_metacatalog_statistics</b> tables;
                                <i>splite_metacatalog</i> will be populated so to describe every table/column currently defined within the DB.<br>
                                if the first argument <b>transaction</b> is set to <b>TRUE</b> the whole operation will be
                                handled as a single <i>Transaction</i> (faster): the default setting is <b>transaction=FALSE</b> (slower, but safer).<br>
                                the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>UpdateMetaCatalogStatistics</b></td>
				<td>UpdateMetaCatalogStatistics( transaction <i>Integer</i> , table_name <i>String</i> , column_name <i>String</i> ) : <i>Integer</i><hr>
                                UpdateMetaCatalogStatistics( transaction <i>Integer</i> , master_table <i>String</i> , table_name <i>String</i> , column_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Updates the <b>splite_metacatalog_statistics</b> table by computing the statistic summary for the required table/column.<br>
                                if the first argument <b>transaction</b> is set to <b>TRUE</b> the whole operation will be
                                handled as a single <i>Transaction</i> (faster): the default setting is <b>transaction=FALSE</b> (slower, but safer).<hr>
                                the first form (using <i>three</i> arguments) will simply attempt to update the statistic summary for a single 
                                table/column as identified by their names: a matching row is expected to be found in <i>splite_metacatalog</i>.<hr>
                                the second form (using <i>four</i> arguments) allows to update the statistic summary for many table/columns in a single pass.<br>
                                in this case <i>master_table</i> should identify an existing table: <i>table_name</i> and <i>column_name</i> should identify two columns belonging to this tables.<br>
                                the statistic summary for every table/columns fetched from the master table will then be updated:
                                any mismatching table/column will be simply ignored.<hr>
                                the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16style">SQL functions supporting SLD/SE Styled Layers</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
		<tr><td><b>CreateStylingTables</b></td>
				<td>CreateStylingTables() : <i>Integer</i><hr>
					CreateStylingTables( relaxed <i>Integer</i> ) : <i>Integer</i><hr>
					CreateStylingTables( relaxed <i>Integer</i> , transaction <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a set of tables supporting <b>SLD/SE Styled Layers</b>.
				<ul>
					<li>if the <i>optional</i> argument <b>relaxed</b> is explicitly set as <b>TRUE</b> then
					a <i>relaxed</i> version of the validating Triggers will be installed (not checking for strict <i><u>XSD schema validation</u></i>).</li>
					<li>if the <i>optional</i> argument <b>transaction</b> is explicitly set as <b>TRUE</b> then 
					the whole operation will be atomically confined within a monolithic SQL transaction</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.<hr>
<i>Please note</i>: will implicitly invoke <b>CreateRasterCoveragesTable()</b> and <b>CreateVectorCoveragesTables()</b> so to create the corresponding tables if not already defined.</td></tr>
		<tr><td><b>SE_RegisterVectorCoverage</b></td>
				<td>SE_RegisterVectorCoverage( coverage_name <i>String</i> , f_table_name <i>String</i> , f_geometry_column <i>String</i> ) : <i>Integer</i><hr>
					SE_RegisterVectorCoverage( coverage_name <i>String</i> , f_table_name <i>String</i> , f_geometry_column <i>String</i> , title <i>String</i> , abstract <i>String </i> ) : <i>Integer</i><hr>
					SE_RegisterVectorCoverage( coverage_name <i>String</i> , f_table_name <i>String</i> , f_geometry_column <i>String</i> , title <i>String</i> , abstract <i>String </i> ,
					is_queryable <i>Boolen</i> , is_editable <i>Boolean</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a <b>Vector Coverage</b> based on an already existing Spatial Table.
				<ul>
					<li><b>coverage_name</b> is the symbolic name uniquely identifying each Vector Coverage (<i>Primary Key</i>).</li>
					<li><b>f_table_name</b> and <b>f_geometry_column</b> are expected to match the corresponding entries in the <i>geometry_columns</i> table.</li>
					<li>the optional arguments <b>title</b> and <b>abstract</b> could be eventually be specified for better human readability.</li>
					<li>if both optional arguments <b>is_queryable</b> and <b>is_editable</b> are left unspecified the Vector Coverage will then be neither queryable nor editable.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterSpatialViewCoverage</b></td>
				<td>SE_RegisterSpatialViewCoverage( coverage_name <i>String</i> , view_name <i>String</i> , view_geometry <i>String</i> ) : <i>Integer</i><hr>
					SE_RegisterSpatialViewCoverage( coverage_name <i>String</i> , view_name <i>String</i> , view_geometry <i>String</i> , title <i>String</i> , abstract <i>String </i> ) : <i>Integer</i><hr>
					SE_RegisterSpatialViewCoverage( coverage_name <i>String</i> , view_name <i>String</i> , view_geometry <i>String</i> , title <i>String</i> , abstract <i>String </i> ,
					is_queryable <i>Boolen</i> , is_editable <i>Boolean</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a <b>Vector Coverage</b> based on an already existing Spatial View.
				<ul>
					<li><b>coverage_name</b> is the symbolic name uniquely identifying each Vector Coverage (<i>Primary Key</i>).</li>
					<li><b>view_name</b> and <b>view_geometry</b> are expected to match the corresponding entries in the <i>views_geometry_columns</i> table.</li>
					<li>the optional arguments <b>title</b> and <b>abstract</b> could be eventually be specified for better human readability.</li>
					<li>if both optional arguments <b>is_queryable</b> and <b>is_editable</b> are left unspecified the Vector Coverage will then be neither queryable nor editable.</li>
					<li><b>Note</b>: a Spatial View Coverage declared to be editable will not fully support editing operations if the underlying Spatial View is of the <b>read-only</b> type (read-only=<b>1</b>).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterVirtualShapeCoverage</b></td>
				<td>SE_RegisterVirtualShapeCoverage( coverage_name <i>String</i> , virt_name <i>String</i> , virt_geometry <i>String</i> ) : <i>Integer</i><hr>
					SE_RegisterVirtualShapeCoverage( coverage_name <i>String</i> , virt_name <i>String</i> , virt_geometry <i>String</i> , title <i>String</i> , abstract <i>String </i> ) : <i>Integer</i><hr>
					SE_RegisterVirtualShapeCoverage( coverage_name <i>String</i> , virt_name <i>String</i> , virt_geometry <i>String</i> , title <i>String</i> , abstract <i>String </i> ,
					is_queryable <i>Boolen</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a <b>Vector Coverage</b> based on an already existing VirtualShape Table.
				<ul>
					<li><b>coverage_name</b> is the symbolic name uniquely identifying each Vector Coverage (<i>Primary Key</i>).</li>
					<li><b>virt_name</b> and <b>virt_geometry</b> are expected to match the corresponding entries in the <i>virts_geometry_columns</i> table.</li>
					<li>the optional arguments <b>title</b> and <b>abstract</b> could be eventually be specified for better human readability.</li>
					<li>if the optional argument <b>is_queryable</b> is left unspecified tjem the Vector Coverage will not be queryable.</li>
					<li><b>Note</b>: VirtualShape Coverages are always not editable.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterTopoGeoCoverage</b></td>
				<td>SE_RegisterTopoGeoCoverage( coverage_name <i>String</i> , topology_name <i>String</i> ) : <i>Integer</i><hr>
					SE_RegisterTopoGeoCoverage( coverage_name <i>String</i> , topology_name <i>String</i> , title <i>String</i> , abstract <i>String </i> ) : <i>Integer</i><hr>
					SE_RegisterTopoGeoCoverage( coverage_name <i>String</i> , topology_name <i>String</i> , title <i>String</i> , abstract <i>String </i> ,
					is_queryable <i>Boolen</i> , is_editable <i>Boolean</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a <b>Vector Coverage</b> based on an already existing Topology-Geometry.
				<ul>
					<li><b>coverage_name</b> is the symbolic name uniquely identifying each Vector Coverage (<i>Primary Key</i>).</li>
					<li><b>topogeo_name</b> is expected to match the corresponding entries in the <i>topologies</i> table.</li>
					<li>the optional arguments <b>title</b> and <b>abstract</b> could be eventually be specified for better human readability.</li>
					<li>if both optional arguments <b>is_queryable</b> and <b>is_editable</b> are left unspecified the Vector Coverage will then be neither queryable nor editable.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterTopoNetCoverage</b></td>
				<td>SE_RegisterTopoNetCoverage( coverage_name <i>String</i> , network_name <i>String</i> ) : <i>Integer</i><hr>
					SE_RegisterTopoNetCoverage( coverage_name <i>String</i> , network_name <i>String</i> , title <i>String</i> , abstract <i>String </i> ) : <i>Integer</i><hr>
					SE_RegisterTopoNetCoverage( coverage_name <i>String</i> , network_name <i>String</i> , title <i>String</i> , abstract <i>String </i> ,
					is_queryable <i>Boolen</i> , is_editable <i>Boolean</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a <b>Vector Coverage</b> based on an already existing Topology-Network.
				<ul>
					<li><b>coverage_name</b> is the symbolic name uniquely identifying each Vector Coverage (<i>Primary Key</i>).</li>
					<li><b>toponet_name</b> is expected to match the corresponding entries in the <i>networks</i> table.</li>
					<li>the optional arguments <b>title</b> and <b>abstract</b> could be eventually be specified for better human readability.</li>
					<li>if both optional arguments <b>is_queryable</b> and <b>is_editable</b> are left unspecified the Vector Coverage will then be neither queryable nor editable.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorCoverage</b></td>
				<td>SE_UnregisterVectorCoverage( coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Completely removes an already defined <b>Vector Coverage</b> this including any furher depency; the underlying Spatial Table will be absolutely unaffected.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Coverage.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetVectorCoverageInfos</b></td>
				<td>SE_SetVectorCoverageInfos( coverage_name <i>String</i> , title <i>String</i> , abstract <i>String</i> ) : <i>Integer</i><hr>
				    SE_SetVectorCoverageInfos( coverage_name <i>String</i> , title <i>String</i> , abstract <i>String</i> , is_queryable <i>Boolen</i> , is_editable <i>Boolean</i> ): <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates the descriptive infos associated to a <b>Vector Coverage</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Coverage.</li>
					<li><b>title</b> and <b>abstract</b> represent the descriptive infos to be set.</li>
					<li>the optional arguments <b>is_queryable</b> and <b>is_editable</b> can be explicitly set so to determine if the Vector Coverage is queryable and/or editable.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetVectorCoverageCopyright</b></td>
				<td>SE_SetVectorCoverageCopyright( coverage_name <i>String</i> , copyright <i>String</i> ) : <i>Integer</i><hr>
				    SE_SetVectorCoverageCopyright( coverage_name <i>String</i> , copyright <i>String</i> , license <i>String</i> ): <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates Copyright and License infos associated to a <b>Vector Coverage</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Coverage.</li>
					<li><b>copyright</b> identifies the Copyright holder; if <b>NULL</b> the current value will be preserved.</li>
					<li>the optional argument <b>license</b> must reference one the Data Licenses registered into the <b>data_licenses</b> table, as e.g. <i>CC0 1.0</i> or <i>CC BY 4.0</i>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterVectorCoverageSrid</b></td>
				<td>SE_RegisterVectorCoverageSrid( coverage_name <i>String</i> , srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Adds an alternative <b>SRID</b> to an already defined Vector Coverage.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Coverage.</li>
					<li><b>srid</b> is expected to match the corresponding entries in the <b>spatial_ref_sys</b> table.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorCoverageSrid</b></td>
				<td>SE_UnregisterVectorCoverageSrid( coverage_name <i>String</i> , srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already defined alternative <b>SRID</b> from a Vector Coverage.
				<ul>
					<li><b>coverage_name</b> and <b>srid</b> must identify some previously defined alternative SRID.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UpdateVectorCoverageExtent</b></td>
				<td>SE_UpdateVectorCoverageExtent() : <i>Integer</i><hr>
				    SE_UpdateVectorCoverageExtent( transaction <i>Integer</i> ) : <i>Integer</i><hr>
				    SE_UpdateVectorCoverageExtent( coverage_name <i>String</i> ) : <i>Integer</i><hr>
				    SE_UpdateVectorCoverageExtent( coverage_name <i>String</i> , transaction <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates the <b>Extent</b> boundary supporting a Vector Coverage, this including any eventually defined alternative SRID.
				<ul>
					<li>if the optional <b>coverage_name</b> argument is set then only that single Vector Coverage will be updated; 
					otherwise all registered Vector Coverages will be processed in a single pass (may require a long time).</li>
					<li>if the optional <b>transaction</b> argument is set to <b>TRUE</b> then the whole operation will be internally
					handled as a single SQL Transaction.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterVectorCoverageKeyword</b></td>
				<td>SE_RegisterVectorCoverageeKeyword( coverage_name <i>String</i> , keyword <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Adds a <b>keyword</b> to an already defined Vector Coverage.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Coverage.</li>
					<li><b>keyword</b> must not be already defined for the same Coverage.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorCoverageKeyword</b></td>
				<td>SE_UnregisterVectorCoverageKeyword( coverage_name <i>String</i> , keyword <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already defined <b>keyword</b> from a Vector Coverage.
				<ul>
					<li><b>coverage_name</b> and <b>keyword</b> must identify some previously defined keyword.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterExternalGraphic</b></td>
				<td>SE_RegisterExternalGraphic( xlink_href <i>String</i> , resource <i>BLOB</i> ) : <i>Integer</i><hr>
					SE_RegisterExternalGraphic( xlink_href <i>String</i> , resource <i>BLOB</i> , title <i>String</i> , abstract <i>String</i> , file_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts (or updates) an <b>External Graphic Resource</b>.
				<ul>
					<li><b>xlink_href</b> uniquely identifies each Resource (<i>Primary Key</i>).</li>
					<li><b>resource</b> is expected to be a BLOB containing an <i>image/gif</i>, <i>image/png</i>, <i>image/jpeg</i> or <i>image/svg+xml</i> payload.</li>
					<li>the optional arguments <b>title</b>, <b>abstract</b> and <b>file_name</b> could be eventually be specified for better human readability.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterExternalGraphic</b></td>
				<td>SE_UnregisterExternalGraphic( xlink_href <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Deletes an already existing <b>External Graphic Resource</b>.
				<ul>
					<li><b>xlink_href</b> the External Resource to be deleted.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterVectorStyle</b></td>
				<td>SE_RegisterVectorStyle( style <i>BLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts a new <b>Vector Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD/SE Style of the Vector type.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The registered Style will be identified either by its unique <b>Style ID</b> or by its <b>Style Name</b> automatically retrieved from SLD/SE XML.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorStyle</b></td>
				<td>SE_UnregisterVectorStyle( style_id <i>Integer</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</i><hr>
					SE_UnregisterVectorStyle( style_name <i>Text</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already registered <b>Vector Style</b> definition.
				<ul>
					<li>The Style to be removed could be referenced either by its unique <b>Style Id</b> or by its <b>Style Name</b>.<br>
					Anyway any attempt to remove a Style identified by its <b>Name</b> will be rejected if the if two (or more) Styles share the same <b>Name</b> thus causing ambiguity.</li>
					<li>when the <i>optional</i> argument <b>remove_all</b> is explicitly set to <b>TRUE</b> the Style will be removed even if it's already referenced by some
					<b>VectorStyledLayer</b> and all dependings references will be removed at the same time.<br>
					In any other case any attempt to unregister a Style already referenced by one (or more) <b>VectorStyleLayer</b> will be rejected.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_ReloadVectorStyle</b></td>
				<td>SE_ReloadVectorStyle( style_id <i>Integer</i> , style <i>BLOB</i> ) : <i>Integer</i><hr>
					SE_ReloadVectorStyle( style_name <i>Text</i> , style <i>BLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates an already existing <b>Vector Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD/SE Style of the Vector type.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The updated Style will continue to be identified by its current unique <b>Style ID</b> but the <b>Style Name</b> will be automatically updated accordingly to SLD/SE XML.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterVectorStyledLayer</b></td>
				<td>SE_RegisterVectorStyledLayer( coverage_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_RegisterVectorStyledLayer( coverage_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Associates a <b>Vector Style</b> to a <b>Vector Styled Layer</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Layer.</li>
					<li>An already registered Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorStyledLayer</b></td>
				<td>SE_UnregisterVectorStyledLayer( coverage_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_UnregisterVectorStyledLayer( coverage_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an association between a <b>Vector Style</b> and a <b>Vector Styled Layer</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Layer.</li>
					<li>An already associated Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterRasterStyle</b></td>
				<td>SE_RegisterRasterStyle( style <i>BLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts a new <b>Raster Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD/SE Style of the Raster type.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The registered Style will be identified either by its unique <b>Style ID</b> or by its <b>Style Name</b> automatically retrieved from SLD/SE XML.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterRasterStyle</b></td>
				<td>SE_UnregisterRasterStyle( style_id <i>Integer</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</i><hr>
					SE_UnregisterRasterStyle( style_name <i>Text</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already registered <b>Raster Style</b> definition.
				<ul>
					<li>The Style to be removed could be referenced either by its unique <b>Style Id</b> or by its <b>Style Name</b>.<br>
					Anyway any attempt to remove a Style identified by its <b>Name</b> will be rejected if the if two (or more) Styles share the same <b>Name</b> thus causing ambiguity.</li>
					<li>when the <i>optional</i> argument <b>remove_all</b> is explicitly set to <b>TRUE</b> the Style will be removed even if it's already referenced by some
					<b>RasterStyledLayer</b> and all dependings references will be removed at the same time.<br>
					In any other case any attempt to unregister a Style already referenced by one (or more) <b>RasterStyleLayer</b> will be rejected.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_ReloadRasterStyle</b></td>
				<td>SE_ReloadRasterStyle( style_id <i>Integer</i> , style <i>BLOB</i> ) : <i>Integer</i><hr>
					SE_ReloadRasterStyle( style_name <i>Text</i> , style <i>BLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates an already existing <b>Raster Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD/SE Style of the Raster type.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The updated Style will continue to be identified by its current unique <b>Style ID</b> but the <b>Style Name</b> will be automatically updated accordingly to SLD/SE XML.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterRasterStyledLayer</b></td>
				<td>SE_RegisterRasterStyledLayer( coverage_name <i>String</i> , style_id <i>Integer</i>  ) : <i>Integer</i><hr>
					SE_RegisterRasterStyledLayer( coverage_name <i>String</i> , style_name <i>Text</i>  ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Associates a <b>Raster Style</b> to a <b>Raster Styled Layer</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Raster Layer.</li>
					<li>An already registered Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterRasterStyledLayer</b></td>
				<td>SE_UnregisterRasterStyledLayer( coverage_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_UnregisterRasterStyledLayer( coverage_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an association between a <b>Raster Style</b> and a <b>Raster Styled Layer</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Raster Layer.</li>
					<li>An already associated Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterRasterCoverageSrid</b></td>
				<td>SE_RegisterRasterCoverageSrid( coverage_name <i>String</i> , srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Adds an alternative <b>SRID</b> to an already defined Raster Coverage.
				<ul>
					<li><b>coverage_name</b> must identify an existing Raster Coverage.</li>
					<li><b>srid</b> is expected to match the corresponding entries in the <b>spatial_ref_sys</b> table.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterRasterCoverageSrid</b></td>
				<td>SE_UnregisterRasterCoverageSrid( coverage_name <i>String</i> , srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already defined alternative <b>SRID</b> from a Raster Coverage.
				<ul>
					<li><b>coverage_name</b> and <b>srid</b> must identify some previously defined alternative SRID.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UpdateRasterCoverageExtent</b></td>
				<td>SE_UpdateRasterCoverageExtent() : <i>Integer</i><hr>
				    SE_UpdateRasterCoverageExtent( transaction <i>Integer</i> ) : <i>Integer</i><hr>
				    SE_UpdateRasterCoverageExtent( coverage_name <i>String</i> ) : <i>Integer</i><hr>
				    SE_UpdateRasterCoverageExtent( coverage_name <i>String</i> , transaction <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates the <b>Extent</b> boundary supporting a Raster Coverage, this including any eventually defined alternative SRID.
				<ul>
					<li>if the optional <b>coverage_name</b> argument is set then only that single Raster Coverage will be updated; 
					otherwise all registered Raster Coverages will be processed in a single pass (may require a long time).</li>
					<li>if the optional <b>transaction</b> argument is set to <b>TRUE</b> then the whole operation will be internally
					handled as a single SQL Transaction.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterRasterCoverageKeyword</b></td>
				<td>SE_RegisterRasterCoverageKeyword( coverage_name <i>String</i> , keyword <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Adds a <b>keyword</b> to an already defined Raster Coverage.
				<ul>
					<li><b>coverage_name</b> must identify an existing Raster Coverage.</li>
					<li><b>keyword</b> must not be already defined for the same Coverage.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterRasterCoverageKeyword</b></td>
				<td>SE_UnregisterRasterCoverageKeyword( coverage_name <i>String</i> , keyword <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already defined <b>keyword</b> from a Raster Coverage.
				<ul>
					<li><b>coverage_name</b> and <b>keyword</b> must identify some previously defined keyword.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetStyledGroupInfos</b></td>
				<td>SE_SetStyledGroupInfos( group_name <i>String</i> , title <i>String</i> , abstract <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts (or updates) the descriptive infos associated to a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify a Styled Group: if the Styled Group doesn't yet exists it will be implicitly created.</li>
					<li><b>title</b> and <b>abstract</b> represent the descriptive infos to be set.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroup</b></td>
				<td>SE_UnregisterStyledGroup( group_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Completely removes a <b>Styled Group</b> and any related item.
				<ul>
					<li><b>group_name</b> must identify an existing Styled Group.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterStyledGroupVector</b></td>
				<td>SE_RegisterStyledGroupVector( group_name <i>String</i> , coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Registers a <b>Vector</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify a Styled Group: if the Styled Group doesn't yet exists it will be implicitly created.</li>
					<li><b>coverage_name</b> must identify an existing Vector Layer.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterStyledGroupRaster</b></td>
				<td>SE_RegisterStyledGroupRaster( group_name <i>String</i> , coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Registers a <b>Raster</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify a Styled Group: if the Styled Group doesn't yet exists it will be implicitly created.</li>
					<li><b>coverage_name</b> must identify an existing Raster Layer.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetStyledGroupLayerPaintOrder</b></td>
				<td>SE_SetStyledGroupLayerPaintOrder( item_id <i>Integer</i> , paint_order <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Explictly assigns the <b>paint_order</b> for a <b>Raster</b> or <b>Vector</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li>If <b>paint_order</b> is a negative value then the next available order position will be automatically assigned (<i>top level</i>).<br>
					<u>Please note</u>: the painting order will always follow the Painter rule, i.e. a lower paint-order value will always be painted before painting any higher value. </li>
					<li>An already defined Vector or Raster Layer Item within a Styled Group can always be referenced its unique <b>item_id</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetStyledGroupVectorPaintOrder</b></td>
				<td>SE_SetStyledGroupVectorPaintOrder( group_name <i>Text</i> , coverage_name <i>String</i> , paint_order <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Explictly assigns the <b>paint_order</b> for a <b>Vector</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li>If <b>paint_order</b> is a negative value then the next available order position will be automatically assigned (<i>top level</i>).<br>
					<u>Please note</u>: the painting order will always follow the Painter rule, i.e. a lower paint-order value will always be painted before painting any higher value. </li>
					<li>An already defined Vector Layer Item can be safely referenced by its <b>Name</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetStyledGroupRasterPaintOrder</b></td>
				<td>SE_SetStyledGroupRasterPaintOrder( group_name <i>Text</i> , coverage_name <i>String</i> , paint_order <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Explictly assigns the <b>paint_order</b> for a <b>Raster</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li>If <b>paint_order</b> is a negative value then the next available order position will be automatically assigned (<i>top level</i>).<br>
					<u>Please note</u>: the painting order will always follow the Painter rule, i.e. a lower paint-order value will always be painted before painting any higher value. </li>
					<li>An already defined Raster Layer Item can be safely referenced by its <b>Name</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroupLayer</b></td>
				<td>SE_UnregisterStyledGroupLayer( item_id <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes a reference to a <b>Raster</b> or <b>Vector</b> Layer from within a <b>Styled Group</b>.
				<ul>
					<li>An already defined Vector or Raster Layer Item within a Styled Group can always be referenced its unique <b>item_id</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroupVector</b></td>
				<td>SE_UnregisterStyledGroupVector( group_name <i>Text</i> , coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes a reference to a <b>Vector</b> Layer from within a <b>Styled Group</b>.
				<ul>
					<li>An already defined Vector Layer Item can be safely referenced by its <b>Name</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroupRaster</b></td>
				<td>SE_UnregisterStyledGroupRaster( group_name <i>Text</i> , coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes a reference to a <b>Raster</b> Layer from within a <b>Styled Group</b>.
				<ul>
					<li>An already defined Raster Layer Item can be safely referenced by its <b>Name</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterGroupStyle</b></td>
				<td>SE_RegisterGroupStyle( style <i>BLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts a new <b>Group Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD complex Style.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The registered Style will be identified either by its unique <b>Style ID</b> or by its unique <b>Style Name</b> automatically retrieved from SLD/SE XML.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterGroupStyle</b></td>
				<td>SE_UnregisterGroupStyle( style_id <i>Integer</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</i><hr>
					SE_UnregisterGroupStyle( style_name <i>Text</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already registered <b>Group Style</b> definition.
				<ul>
					<li>The Style to be removed could be referenced either by its unique <b>Style Id</b> or by its <b>Style Name</b>.<br>
					Anyway any attempt to remove a Style identified by its <b>Name</b> will be rejected if the if two (or more) Styles share the same <b>Name</b> thus causing ambiguity.</li>
					<li>when the <i>optional</i> argument <b>remove_all</b> is explicitly set to <b>TRUE</b> the Style will be removed even if it's already referenced by some
					<b>RasterStyledLayer</b> and all dependings references will be removed at the same time.<br>
					In any other case any attempt to unregister a Style already referenced by one (or more) <b>RasterStyleLayer</b> will be rejected.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_ReloadGroupStyle</b></td>
				<td>SE_ReloadGroupStyle( style_id <i>Integer</i> , style <i>BLOB</i> ) : <i>Integer</i><hr>
					SE_ReloadGroupStyle( style_name <i>Text</i> , style <i>BLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates an already existing <b>Group Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD complex Style.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The updated Style will continue to be identified by its current unique <b>Style ID</b> but the <b>Style Name</b> will be automatically updated accordingly to SLD/SE XML.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterStyledGroupStyle</b></td>
				<td>SE_RegisterStyledGroupStyle( group_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_RegisterStyledGroupStyle( group_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Associates a <b>Group Style</b> to a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify an existing Styled Group.</li>
					<li>An already registered Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroupStyle</b></td>
				<td>SE_UnregisterStyledGroupStyle( group_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_UnregisterStyledGroupStyle( group_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an association between a <b>Group Style</b> and a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify an existing Styled Group.</li>
					<li>An already associated Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16isometa">SQL functions supporting ISO Metadata</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
		<tr><td><b>CreateIsoMetadataTables</b></td>
				<td>CreateIsoMetadataTables() : <i>Integer</i><hr>
					CreateIsoMetadataTables( relaxed <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a set of tables supporting <b>ISO Metadata</b>.
				<ul>
					<li>if the <i>optional</i> argument <b>relaxed</b> is specified (any value), then
					a <i>relaxed</i> version of the validating Triggers will be installed.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>RegisterIsoMetadata</b></td>
				<td>RegisterIsoMetadata( scope <i>String</i> , metadata <i>BLOB</i> ) : <i>Integer</i><hr>
				RegisterIsoMetadata( scope <i>String</i> , metadata <i>BLOB</i> , id Integer ) : <i>Integer</i><hr>
				RegisterIsoMetadata( scope <i>String</i> , metadata <i>BLOB</i> , fileIdentifier <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts (or updates) an <b>ISO Metadata</b> definition.
				<ul>
					<li><b>scope</b> can be one of <i>undefined</i>, <i>fieldSession</i>, <i>collectionSession</i>, 
					<i>series</i>, <i>dataset</i>, <i>featureType</i>, <i>feature</i>, <i>attributeType</i>, <i>attribute</i>, 
					<i>tile</i>, <i>model</i>, <i>catalogue</i>, <i>schema</i>, <i>taxonomy</i>, <i>software</i>,
					<i>service</i>, <i>collectionHardware</i>, <i>nonGeographicDataset</i>, <i>dimensionGroup</i>.</li>
					<li><b>metadata</b> is expected to be a valid XmlBLOB storing some IsoMetadata payload.</li>
					<li>the first form (two arguments only) always performs an <i>INSERT</i>; if one the optional arguments <b>id</b> or <b>fileIdentifier</b> an <i>UPDATE</i> could be eventually performed if a corresponding metadata row is already defined.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>GetIsoMetadataId</b></td>
				<td>GetIsoMetadataId( fileIdentifier <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Return the unique <b>id</b> corresponding to the <b>ISO Metadata</b> definition identified by <b>fileIdentifier</b>.<hr>
				If no corresponding ISO Metadata definition exists, this function will always return <i>ZERO</i>; <i>-1</i> will be returned for invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16fdo">SQL functions implementing FDO/OGR compatibility</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CheckSpatialMetaData</b></td>
				<td>CheckSpatialMetaData( void ) : <i>Integer</i><hr>
				    CheckSpatialMetaData( db_prefix <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks the Spatial Metadata type, then returning:<ul>
				<li><b>-1</b> - on invalid args or if no ATTACHED-DB identified by <b>db_prefix</b> exists.</li>
				<li><b>0</b> - if the <b>geometry_columns</b> or <b>spatial_ref_sys</b> table does not exists, or if their actual layout doesn't corresponds to any known implementation</li>
				<li><b>1</b> - if both tables exist, and their layout is the one previously used by <b>SpatiaLite legacy</b> (<i>older versions including 3.1.0 any earlier</i>)</li>
				<li><b>2</b> - if both tables exist, and their layout is the one used by <b>FDO/OGR</b></li>
				<li><b>3</b> - if both tables exist, and their layout is the one currently used by <b>SpatiaLite</b> (<i>4.0.0 or any subsequent version</i>)</li>
				<li><b>4</b> - if the DB layout is the one defined by the <b>OGC GPKG</b> specification (<i>GeoPackage</i>)</li>
				</ul><hr>
				The optional <b>db_prefix</b> argument specifies which one of the ATTACHED databases is intended to be checked; if unspecified or <b>NULL</b> then 
				the <b>MAIN</b> database will be assumed by default.</td></tr>
			<tr><td><b>AutoFDOStart</b></td>
				<td>AutoFDOStart( void ) : <i>Integer</i><hr>
				    AutoFDOStart( db_prefix <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will inspect the Spatial Metadata, then automatically creating/refreshing a <b>VirtualFDO</b>
				wrapper for each FDO/OGR geometry table<hr>
				the return type is Integer [how many VirtualFDO tables have been created]<hr>
				The optional <b>db_prefix</b> argument specifies which one of the ATTACHED databases is intended to be targeted; if unspecified or <b>NULL</b> then 
				the <b>MAIN</b> database will be assumed by default.</td></tr>
			<tr><td><b>AutoFDOStop</b></td>
				<td>AutoFDOStop( void ) : <i>Integer</i><hr>
				    AutoFDOStop( db_prefix <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will inspect the Spatial Metadata, then automatically destroying any <b>VirtualFDO</b>
				wrapper found<hr>
				the return type is Integer [how many VirtualFDO tables have been destroyed]<hr>
				the return type is Integer [how many VirtualFDO tables have been created]<hr>
				The optional <b>db_prefix</b> argument specifies which one of the ATTACHED databases is intended to be targeted; if unspecified or <b>NULL</b> then 
				the <b>MAIN</b> database will be assumed by default.</td></tr>
			<tr><td><b>InitFDOSpatialMetaData</b></td>
				<td>InitFDOSpatialMetaData( void ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates the <b>geometry_columns</b> and <b>spatial_ref_sys</b> metadata tables<br>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<hr>
<u>Please note:</u> Spatial Metadata created using this function will have the FDO/OGR layout, and not the standard SpatiaLite layout</td></tr>
			<tr><td><b>AddFDOGeometryColumn</b></td>
				<td>AddFDOGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> ,
geom_type <i>Integer</i> , dimension <i>Integer</i>, geometry_format <i>String</i> ) : <i>Integer</i> </td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates a new <u>geometry column</u> updating the FDO/OGR Spatial Metadata tables<hr>
				<b>geom_type</b> has to be one of the followings:<ul>
				<li><b>1</b> <i>POINT</i></li>
				<li><b>2</b> <i>LINESTRING</i></li>
				<li><b>3</b> <i>POLYGON</i></li>
				<li><b>4</b> <i>MULTIPOINT</i></li>
				<li><b>5</b> <i>MULTILINESTRING</i></li>
				<li><b>6</b> <i>MULTIPOLYGON</i></li>
				<li><b>7</b> <i>GEOMETRYCOLLECTION</i></li>
				</ul><b>dimension</b> may be <b>2</b>, <b>3</b> or <b>4</b>, accordingly to OGR/FDO specs<br>
				<b>geometry_format</b> has to be one of the followings:<ul>
				<li>'WKB'</li>
				<li>'WKT'</li>
				<li>'FGF'</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>RecoverFDOGeometryColumn</b></td>
				<td>RecoverFDOGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> ,
geom_type <i>String</i> , dimension <i>Integer</i>, geometry_format <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Validates an existing ordinary column in order to possibly transform it in a real <u>geometry column</u>,
thus updating the FDO/OGR Spatial Metadata tables<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>DiscardFDOGeometryColumn</b></td>
				<td>DiscardFDOGeometryColumn( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Removes a <u>geometry column</u> from FDO/OGR Spatial MetaData tables<br>
the column itself still continues to exist untouched as an ordinary column<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16gpkg">SQL functions implementing OGC GeoPackage compatibility</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CheckGeoPackageMetaData</b></td>
				<td>CheckGeoPackageMetaData( void ) : <i>Integer</i><hr>
				    CheckGeoPackageMetaData ( db_prefix <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will inspect the DB layout checking if it corresponds to the GPKG own style.<br>
				The optional <b>db_prefix</b> argument specifies which one of the ATTACHED databases is intended to be checked; if unspecified or <b>NULL</b> then 
				the <b>MAIN</b> database will be assumed by default.<hr>
the return type is Integer, with a return value of 1 for TRUE, 0 for FALSE and -1 on invalid args or if no ATTACHED-DB identified by <b>db_prefix</b> exists.</td></tr>
			<tr><td><b>AutoGPKGStart</b></td>
				<td>AutoGPKGStart( void ) : <i>Integer</i><hr>
				    AutoGPKGStart( db_prefix <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will inspect the DB layout, then automatically creating/refreshing a <b>VirtualGPKG</b>
				wrapper for each GPKG geometry table<hr>
				the return type is Integer [how many VirtualGPKG tables have been created]<hr>
				The optional <b>db_prefix</b> argument specifies which one of the ATTACHED databases is intended to be targeted; if unspecified or <b>NULL</b> then 
				the <b>MAIN</b> database will be assumed by default.</td></tr>
			<tr><td><b>AutoGPKGStop</b></td>
				<td>AutoGPKGStop( void ) : <i>Integer</i><hr>
				    AutoGPKGStop( db_prefix <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will inspect the DB layout, then automatically destroying any <b>VirtualGPKG</b>
				wrapper found<hr>
				the return type is Integer [how many VirtualGPKG tables have been destroyed]<hr>
				The optional <b>db_prefix</b> argument specifies which one of the ATTACHED databases is intended to be targeted; if unspecified or <b>NULL</b> then 
				the <b>MAIN</b> database will be assumed by default.</td></tr>
			<tr><td><b>gpkgCreateBaseTables</b></td>
				<td>gpkgCreateBaseTables( void ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create base tables for an "empty" GeoPackage<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgInsertEpsgSRID</b></td>
				<td>gpkgInsertEpsgSRID( srid <i>Integer</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add a spatial reference system entry for the specified EPSG identifier;
				it is an error to try to add the entry if it already exists<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgCreateTilesTable</b></td>
				<td>gpkgCreateTilesTable( tile_table_name <i>String</i> , srid <i>Integer</i> , min_x <i>Double precision</i> ,
				min_y <i>Double precision</i> , max_x <i>Double precision</i> , max_y <i>Double precision</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a new (empty) Tiles table and the triggers for that table;
				It also adds in the matching entries into gpkg_contents and gpkg_tile_matrix_set.<br>
				This function assumes usual tile conventions, including that the tiles are power-of-two-zoom.<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgCreateTilesZoomLevel</b></td>
				<td>gpkgCreateTilesZoomLevel( tile_table_name <i>String</i>, zoom_level <i>Integer</i> , extent_width <i>Double precision</i> ,
				extent_height <i>Double precision</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add a zoom level for the specified table.<br>
				This function assumes usual tile conventions, including that the tiles are power-of-two-zoom,
				256x256 pixels, 1 tile at the top level (zoom level 0).<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgAddTileTriggers</b></td>
				<td>gpkgAddTileTriggers( tile_table_name <i>String</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add Geopackage tile table triggers for the named table.<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgGetNormalZoom</b></td>
				<td>gpkgGetNormalZoom( tile_table_name <i>String</i> , inverted_zoom_level <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will return the normal integer zoom level for data stored in the specified table.<br>
				Note that this function can also be used to convert from a normal zoom level
				to an inverted zoom level - this conversion is symmetric.<hr>
				Raises a SQL exception if inverted zoom level is outside the range of
				tile_matrix_metadata table normal zoom levels defined for the tile_table</td></tr>
			<tr><td><b>gpkgGetNormalRow</b></td>
				<td>gpkgGetNormalRow( tile_table_name <i>String</i> , normal_zoom_level <i>Integer</i> , inverted_row_number <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will return the normal integer row number for the specified table, normal zoom level
				and inverted row number.<br>
				Note that this function can also be used to convert from a normal row number
				to an inverted row number - this conversion is symmetric.<hr>
				Raises a SQL exception if no zoom level row record in tile_matrix_metadata</td></tr>
			<tr><td><b>gpkgGetImageType</b></td>
				<td>gpkgGetImageType( image <i>Blob</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will return the image type (as a string) of the blob argument, or "unknown" if
				the image type is not one of the PNG, JPEG, TIFF or WebP format types that are supported in GeoPackage.
				The result will be one of:
				<ul>
				<li><b>"png"</b> for PNG</li>
				<li><b>"jpeg"</b> for JPEG</li>
				<li><b>"tiff"</b> for TIFF</li>
				<li><b>"x-webp"</b> for WebP</li>
				</ul>
				These are the mime type for the image format (without the "image/" prefix).<hr>
				This function raises exception on error (e.g. wrong argument type).</td></tr>
			<tr><td><b>gpkgAddGeometryColumn</b></td>
				<td>gpkgAddGeomtryColumn( table_name <i>String</i>, geometry_column_name <i>String</i> , geometry_type <i>String</i> , 
					with_z <i>Integer</i> , with_m <i>Integer</i> , srs_id <i>Integer</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>Adds a geometry column to the specified table:
				<ul>
					<li><b>geometry_type</b> is a normal WKT name:
						<ul>
							<li><b>"GEOMETRY"</b></li>
							<li><b>"POINT"</b></li>
							<li><b>"LINESTRING"</b></li>
							<li><b>"POLYGON"</b></li>
							<li><b>"MULTIPOINT"</b></li>
							<li><b>"MULTILINESTRING"</b></li>
							<li><b>"MULTIPOLYGON"</b></li>
							<li><b>"GEOMCOLLECTION"</b></li>
						</ul></li>
					<li><b>with_z</b> is a flag (0 for no z values, 1 for mandatory z values, 2 for optional z values)</li>
					<li><b>with_m</b> is a flag (0 for no m values, 1 for mandatory m values, 2 for optional m values)</li>
				</ul><hr>
				returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgAddGeometryTriggers</b></td>
				<td>gpkgAddGeometryTriggers( table_name <i>String</i> , geometry_column_name <i>String</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add Geopackage geometry table triggers for the named table.<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgAddSpatialIndex</b></td>
				<td>gpkgAddSpatialIndex( table_name <i>String</i> , geometry_column_name <i>String</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add Geopackage Spatial Index support for the named table.<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgMakePoint</b></td>
				<td>gpkgMakePoint (x <i>Double precision</i> , y <i>Double precision</i> ) : <i>GPKG Blob Geometry</i><hr>
				gpkgMakePoint (x <i>Double precision</i> , y <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a GeoPackage geometry POINT.<hr>
				Raises a SQL exception on error</td></tr>
			<tr><td><b>gpkgMakePointZ</b></td>
				<td>gpkgMakePointZ (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> ) : <i>GPKG Blob Geometry</i><hr>
				gpkgMakePointZ (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a GeoPackage geometry POINT Z.<hr>
				Raises a SQL exception on error</td></tr>
			<tr><td><b>gpkgMakePointM</b></td>
				<td>gpkgMakePointM (x <i>Double precision</i> , y <i>Double precision</i> , m <i>Double precision</i> ) : <i>GPKG Blob Geometry</i><hr>
				gpkgMakePointM (x <i>Double precision</i> , y <i>Double precision</i> , m <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a GeoPackage geometry POINT M.<hr>
				Raises a SQL exception on error</td></tr>
			<tr><td><b>gpkgMakePointZM</b></td>
				<td>gpkgMakePointZM (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , m <i>Double precision</i> ) : <i>GPKG Blob Geometry</i><hr>
				gpkgMakePointZM (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , m <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a GeoPackage geometry POINT ZM.<hr>
				Raises a SQL exception on error</td></tr>
			<tr><td><b>IsValidGPB</b></td>
				<td>IsValidGPB( geom <i>Blob</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will inspect a BLOB then checking if it really corresponds to a GPKG own Geometry<hr>
the return type is Integer, with a return value of 1 for TRUE, 0 for FALSE</td></tr>
			<tr><td><b>AsGPB</b></td>
				<td>AsGPB( geom <i>BLOB encoded geometry</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will convert a SpatiaLite geometry blob into a GeoPackage format geometry blob.<hr>
				Will return NULL if any error is encountered</td></tr>
			<tr><td><b>GeomFromGPB</b></td>
				<td>GeomFromGPB( geom <i>GPKG Blob Geometry</i> ) : <i>BLOB encoded geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will convert a GeoPackage format geometry blob into a SpatiaLite geometry blob.<hr>
				Will return NULL if any error is encountered</td></tr>
			<tr><td><b>CastAutomagic</b></td>
				<td>CastAutomagic( geom <i>Blob</i> ) : <i>BLOB encoded geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will indifferently accept on input:
				<ul>
					<li>a SpatiaLite own BLOB Geometry</li>
					<li>a GPKG own BLOB Geometry</li>
				</ul>
				then returning a SpatiaLite own BLOB geometry.<hr>
				Will return NULL if any error is encountered or on invalid / mismatching argument</td></tr>	
			<tr><td><b>GPKG_IsAssignable</b></td>
				<td>GPKG_IsAssignable( expected_type_name <i>String</i> , actual_type_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will check if <b>expected_type</b> is the same or is a super-type of <b>actual_type</b>;
				this function is required by the standard implementation of GPKG Geometry validation Triggers.<hr>
the return type is Integer, with a return value of 1 for TRUE, 0 for FALSE</td></tr>					
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p17">SQL functions for MbrCache-based queries</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>FilterMbrWithin</b></td>
				<td>FilterMbrWithin(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Retrieves from an MbrCache any entity whose MBR falls <u><i>within</i></u>
				the rectangle identified by extreme points <b>x1 y1</b> and <b>x2 y2</b></td></tr>
			<tr><td><b>FilterMbrContains</b></td>
				<td>FilterMbrContains(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Retrieves from an MbrCache any entity whose MBR <u><i>contains</i></u>
				the rectangle identified by extreme points <b>x1 y1</b> and <b>x2 y2</b></td></tr>
			<tr><td><b>FilterMbrIntersects</b></td>
				<td>FilterMbrIntersects(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Retrieves from an MbrCache any entity whose MBR <u><i>intersects</i></u>
				the rectangle identified by extreme points <b>x1 y1</b> and <b>x2 y2</b></td></tr>
			<tr><td><b>BuildMbrFilter</b></td>
				<td>BuildMbrFilter(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates an MBR identified by extreme points <b>x1 y1</b> and <b>x2 y2</b><hr>
				This fuction is used internally by <u><i>triggers</i></u> related to MbrCache management,
				and is not intended for any other usage</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p18">SQL functions for R*Tree-based queries (Geometry Callbacks)</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>RTreeIntersects</b></td>
				<td>RTreeIntersects(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0d0d0">geocallbacks</td>
				<td>Retrieves from an R*Tree Spatial Index any entity whose MBR <u><i>intersect</i></u>
				the rectangle identified by extreme points <b>x1 y1</b> and <b>x2 y2</b></td></tr>
			<tr><td><b>RTreeWithin</b></td>
				<td>RTreeWithin(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0d0d0">geocallbacks</td>
				<td><b>Deprecated function</b><br>
					Still maintained so to avoid backward compatibility issues, but now simply is an 
					<i>alias-name</i> for <b>RTreeIntersects</b></td></tr>
			<tr><td><b>RTreeContains</b></td>
				<td>RTreeContains(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0d0d0">geocallbacks</td>
				<td><b>Deprecated function</b><br>
					Still maintained so to avoid backward compatibility issues, but now simply is an 
					<i>alias-name</i> for <b>RTreeIntersects</b></td></tr>
			<tr><td><b>RTreeDistWithin</b></td>
				<td>RTreeDistWithin(  x <i>Double precision</i> , y <i>Double precision</i> ,
				radius <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0d0d0">geocallbacks</td>
				<td>Retrieves from an R*Tree Spatial Index any entity whose MBR <u><i>intersect</i></u>
				the square circumscribed on the given circle (<b>x y</b> center, <b>radius)</b></td></tr>
            <tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="xmlBlob">SQL functions supporting XmlBLOB</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>XB_Create</b></td>
				<td>XB_Create(  xmlPayload <i>BLOB</i> ) : <i>XmlBLOB</i><hr>
				XB_Create(  xmlPayload <i>BLOB</i> , compressed <i>Boolean</i> ) : <i>XmlBLOB</i><hr>
				XB_Create(  xmlPayload <i>BLOB</i> , compressed <i>Boolean</i> ,
				schemaURI <i>Text</i> ) : <i>XmlBLOB</i><hr>
				XB_Create(  xmlPayload <i>BLOB</i> , compressed <i>Boolean</i> ,
				internalSchemaURI <i>Boolean</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Construct an XmlBLOB object starting from an XmlDocument.<ul>
				<li>If <b>compressed</b> is set to TRUE the XmlBlob object will be compressed (default setting).</li>
                                <li>If <b>schemaURI</b> is specified then the XmlDocument will be validated against the given Schema (default setting is skipping any XML validation).</li>
                                <li>If <b>internalSchemaURI</b> is set (any value), then the XmlDocument will be validated againt the Schema URI internally defined within the XmlDocument itself (if any).</li></ul><hr>
				<b>NULL</b> will be returned for not well-formed XmlDocuments, or when XML validation is required but XmlDocument fails to pass validation for any reason.</td></tr>
			<tr><td><b>XB_GetPayload</b></td>
				<td>XB_GetPayload( xmlObject <i>XmlBLOB</i> [ , indent <i>Integer</i> ] ) : <i>BLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Extracts a generic BLOB from an XmlBLOB object, exactly corresponding to the original XmlDocument and fully preserving the original character encoding.<br>
				If the optional argument <b>indent</b> is set to some <i>positive</i> value then the returned XmlDocument
                                will be nicely formatted and properly indented by the required factor; <i>ZERO</i> will cause the whole 
                                XmlDocument to be returned as a single line. (default setting is <i>negative</i> indenting, i.e. not reformatting at all).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_GetDocument</b></td>
				<td>XB_GetDocument( xmlObject <i>XmlBLOB</i> [ , indent <i>Integer</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Extracts an XmlDocument from an XmlBLOB object; the returned XmlDocument will always be UTF-8 encoded (<b>TEXT</b>), irrespectively from the original internal encoding declaration.<br>
				If the optional argument <b>indent</b> is set to some <i>positive</i> value then the returned XmlDocument
                                will be nicely formatted and properly indented by the required factor; <i>ZERO</i> will cause the whole
                                XmlDocument to be returned as a single line. (default setting is <i>negative</i> indenting, i.e. not reformatting at all).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_SchemaValidate</b></td>
				<td>XB_SchemaValidate(  xmlObject <i>XmlBLOB</i> , schemaURI <i>Text</i> [ , compressed <i>Boolean</i> ] ) : <i>XmlBLOB</i><hr>
				XB_SchemaValidate(  xmlObject <i>XmlBLOB</i> , internalSchemaURI <i>Boolean</i> [ , compressed <i>Boolean</i> ] ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Construct an XML validated XmlBLOB object starting from an XmlDocument.<ul>
				<li>If <b>compressed</b> is set to TRUE the XmlBlob object will be compressed (default setting).</li>
                                <li>If <b>schemaURI</b> is specified then the XmlDocument will be validated against the given Schema (default setting is skipping any XML validation).</li>
                                <li>If <b>internalSchemaURI</b> is set (any value), then the XmlDocument will be validated againt the Schema URI internally defined within the XmlDocument itself (if any).</li></ul><hr>
				<b>NULL</b> will be returned if the input XmlBLOB fails to pass validation for any reason.</td></tr>
			<tr><td><b>XB_Compress</b></td>
				<td>XB_Compress( xmlObject <i>XmlBLOB</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>A new compressed XmlBLOB object will be returned.<br>
                                If the input XmlBLOB is already compressed this one is a harmless no-op.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_Uncompress</b></td>
				<td>XB_Uncompress( xmlObject <i>XmlBLOB</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>A new uncompressed XmlBLOB object will be returned.<br>
                                If the input XmlBLOB is already uncompressed this one is a harmless no-op.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_IsValid</b></td>
				<td>XB_IsValid( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.</td></tr>
			<tr><td><b>XB_IsCompressed</b></td>
				<td>XB_IsCompressed( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.</td></tr>
			<tr><td><b>XB_IsSchemaValidated</b></td>
				<td>XB_IsSchemaValidated( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.</td></tr>
			<tr><td><b>XB_IsIsoMetadata</b></td>
				<td>XB_IsIsoMetadata( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.</td></tr>
			<tr><td><b>XB_IsSldSeVectorStyle</b></td>
				<td>XB_IsSldSeVectorStyle( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.</td></tr>
			<tr><td><b>XB_IsSldSeRasterStyle</b></td>
				<td>XB_IsSldSeRasterStyle( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.</td></tr>
			<tr><td><b>XB_IsSvg</b></td>
				<td>XB_IsSvg( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.</td></tr>
			<tr><td><b>XB_IsGpx</b></td>
				<td>XB_IsGpx( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.</td></tr>
			<tr><td><b>XB_GetDocumentSize</b></td>
				<td>XB_GetDocumentSize( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the size in bytes of the corresponding uncompressed XmlDocument.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_GetEncoding</b></td>
				<td>XB_GetEncoding( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the character encoding internally declared by the XmlDocument corresponding to the input XmlBLOB.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when the XmlDocument doesn't explicitly declares any encoding.</td></tr>
			<tr><td><b>XB_GetSchemaURI</b></td>
				<td>XB_GetSchemaURI( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Schema URI effectively used to validate an XmlBLOB.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when the XmlBLOB isn't validated.</td></tr>
			<tr><td><b>XB_GetInternalSchemaURI</b></td>
				<td>XB_GetInternalSchemaURI( xmlPayload <i>BLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Schema URI internally declared by the input XmlDocument
				(<b>xsi:noNamespeceSchemaLocation</b> or <b>xsi:schemaLocation</b>).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when the XmlDocument doesn't declares any Schema at all.</td></tr>
			<tr><td><b>XB_GetFileId</b></td>
				<td>XB_GetFileId( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the FileIdentifier defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no FileIdentifier is defined.<hr>Supported only on ISO Metadata XML Documents.</td></tr>
			<tr><td><b>XB_SetFileId</b></td>
				<td>XB_SetFileId( xmlObject <i>XmlBLOB</i> , fileId <i>String</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return a new XmlBLOB by replacing the FileIdentifier value.<br>
				The input XmlBLOB is expected to be of the <u>ISO Metadata</u> type and must containt an already defined <u>FileIdentifier</u>.<hr>
				<b>NULL</b> will be returned for any invalid input.</td></tr>
			<tr><td><b>XB_AddFileId</b></td>
				<td>XB_AddFileId( xmlObject <i>XmlBLOB</i> , fileId <i>String</i> , IdNameSpacePrefix <i>String</i> , IdNameSpaceURI <i>String</i> , CsNameSpacePrefix <i>String</i> , CsNameSpaceURI <i>String</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return a new XmlBLOB by inserting a FileIdentifier value.<br>
				The input XmlBLOB is expected to be of the <u>ISO Metadata</u> type and must not containt an already defined <u>FileIdentifier</u>.<hr>
				<b>IdNameSpacePrefix</b> and <b>IdNameSpaceURI</b> are expected to represent the <u>namespace</u> (if any) corresponding to the <b>&lt;fileIdentifier&gt;</b> tag (could be eventually <b>NULL</b>).<br>
				<b>CsNameSpacePrefix</b> and <b>CsNameSpaceURI</b> are expected to represent the <u>namespace</u> (if any) corresponding to the <b>&lt;CharacterString&gt;</b> tag (could be eventually <b>NULL</b>).<hr>
				<b>NULL</b> will be returned for any invalid input.</td></tr>
			<tr><td><b>XB_GetParentId</b></td>
				<td>XB_GetParentId( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the ParentIdentifier defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no ParentIdentifier is defined.<hr>Supported only on ISO Metadata XML Documents.</td></tr>
			<tr><td><b>XB_SetParentId</b></td>
				<td>XB_SetParentId( xmlObject <i>XmlBLOB</i> , parentId <i>String</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return a new XmlBLOB by replacing the ParentIdentifier value.<br>
				The input XmlBLOB is expected to be of the <u>ISO Metadata</u> type and must containt an already defined <u>ParentIdentifier</u>.<hr>
				<b>NULL</b> will be returned for any invalid input.</td></tr>
			<tr><td><b>XB_AddParentId</b></td>
				<td>XB_AddParentId( xmlObject <i>XmlBLOB</i> , parentId <i>String</i> , IdNameSpacePrefix <i>String</i> , IdNameSpaceURI <i>String</i> , CsNameSpacePrefix <i>String</i> , CsNameSpaceURI <i>String</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return a new XmlBLOB by inserting a ParentIdentifier value.<br>
				The input XmlBLOB is expected to be of the <u>ISO Metadata</u> type and must not containt an already defined <u>ParentIdentifier</u>.<hr>
				<b>IdNameSpacePrefix</b> and <b>IdNameSpaceURI</b> are expected to represent the <u>namespace</u> (if any) corresponding to the <b>&lt;parentIdentifier&gt;</b> tag (could be eventually <b>NULL</b>).<br>
				<b>CsNameSpacePrefix</b> and <b>CsNameSpaceURI</b> are expected to represent the <u>namespace</u> (if any) corresponding to the <b>&lt;CharacterString&gt;</b> tag (could be eventually <b>NULL</b>).<hr>
				<b>NULL</b> will be returned for any invalid input.</td></tr>
			<tr><td><b>XB_GetTitle</b></td>
				<td>XB_GetTitle( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Title defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no Title is defined.<hr>Supported only on ISO Metadata and SLD/SE Styles.</td></tr>
			<tr><td><b>XB_GetAbstract</b></td>
				<td>XB_GetAbstract( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Abstract defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no Abstract is defined.<hr>Supported only on ISO Metadata and SLD/SE Styles.</td></tr>
			<tr><td><b>XB_GetGeometry</b></td>
				<td>XB_GetGeometry( xmlObject <i>XmlBLOB</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Geometry (Bounding Box) defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no Bounding Box is defined.<hr>Supported only on ISO Metadata XML Documents.</td></tr>
			<tr><td><b>XB_MLineFromGPX</b></td>
				<td>XB_MLineFromGPX( xmlObject <i>XmlBLOB</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return a Geometry of the <b>MULTILINESTRING XYZM</b> type by parsing an XmlBLOB corresponding to a GPX document.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when a valid XmlBLOB does not contains a GPX document, or when a valid GPX
				does not contains any <b>&lt;trk&gt;</b> tag.</td></tr>
			<tr><td><b>XB_GetLastParseError</b></td>
				<td>XB_GetLastParseError( <i>void</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the most recent XML parsing error (if any).<hr>
				<b>NULL</b> will be returned if there is no pending parsing error.</td></tr>
			<tr><td><b>XB_GetLastValidateError</b></td>
				<td>XB_GetLastValidateError( <i>void</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the most recent XML validating error (if any).<hr>
				<b>NULL</b> will be returned if there is no pending validating error.</td></tr>
			<tr><td><b>XB_IsValidXPathExpression</b></td>
				<td>XB_IsValidXPathExpression( expr <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					when called with a NULL argument.</td></tr>
			<tr><td><b>XB_GetLastXPathError</b></td>
				<td>XB_GetLastXPathError( <i>void</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the most recent XPath error (if any).<hr>
				<b>NULL</b> will be returned if there is no pending XPath error.</td></tr>
			<tr><td><b>XB_CacheFlush</b></td>
				<td>XB_CacheFlush( <i>void</i> ) : <i>Boolean</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Reset the internal XML Schema cache to its initial empty state.</td></tr>
			<tr><td><b>XB_LoadXML</b></td>
				<td>XB_LoadXML( filepath-or-URL <i>String</i> ) : <i>BLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>If <i>filepath-or-URL</i> corresponds to some valid local pathname, and the corresponding file (expected to contain a well-formed XML Document)
					can be actually accessed in read mode, then the whole file content will be returned as a
					BLOB value.<br>
					This function is even able to acces a remote XML Document identified by an <b>URL</b>.<br>
					Otherwise NULL will be returned.<br>
					<u>Please note:</u> SQLite doesn't support BLOB values bigger than SQLITE_MAX_LENGTH (usually, 1 GB).<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.<br>
					Please see: <b>CountUnsafeTriggers()</b></td></tr>
			<tr><td><b>XB_StoreXML</b></td>
				<td>XB_StoreXML( XmlObject <i>XmlBLOB</i> , filepath <i>String</i> ) : <i>Integer</i><hr>
				XB_StoreXML( XmlObject <i>XmlBLOB</i> , filepath <i>String</i> , indent <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>If <i>XmlObject</i> is of the XmlBLOB-type, and if <i>filepath</i> corresponds to some valid pathname 
					(accessible in write/create mode), then the corresponding file will be created/overwritten so to
					contain the corresponding XML Document (fully preserving the original character encoding).<br>
				If the optional argument <b>indent</b> is set to some <i>positive</i> value then the returned XmlDocument
                                will be nicely formatted and properly indented by the required factor; <i>ZERO</i> will cause the whole 
                                XmlDocument to be returned as a single line. (default setting is <i>negative</i> indenting, i.e. not reformatting at all).<hr>
					The return type is Integer, with a return value of 1 for success, 0 for failure and -1 for invalid arguments.<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.<br>
					Please see: <b>CountUnsafeTriggers()</b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="srid">SQL functions supporting SRID inspection</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0" colspan="3">Summary</th></tr>
			<tr><td><b>SridIsGeographic</b></td>
				<td>SridIsGeographic( SRID <i>Integer</i> ) : <i>Integer</i></td>
				<td colspan="3">Will inspect the SRID definitions checking if the SRID is of the <b>Geographic</b> type;<br>
					will return <b>1</b> (i.e. <b>TRUE</b>) or <b>0</b> (i.e. <b>FALSE</b>).<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridIsProjected</b></td>
				<td>SridIsProjected( SRID <i>Integer</i> ) : <i>Integer</i></td>
				<td colspan="3">Will inspect the SRID definitions checking if the SRID is of the <b>Projected</b> type;<br>
					will return <b>1</b> (i.e. <b>TRUE</b>) or <b>0</b> (i.e. <b>FALSE</b>).<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridHasFlippedAxes</b></td>
				<td>SridHasFlippedAxes( SRID <i>Integer</i> ) : <i>Integer</i></td>
				<td colspan="3">Will inspect the SRID definitions checking if the SRID requires a flipped Axes configuration: i.e. <b>Y,X</b> instead of the most usual <b>X,Y</b>;<br>
					will return <b>1</b> (i.e. <b>TRUE</b>) or <b>0</b> (i.e. <b>FALSE</b>).<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetSpheroid</b></td>
				<td>SridGetSpheroid( SRID <i>Integer</i> ) : <i>Text</i><hr>
					SridGetEllipsoid( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Spheroid</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetPrimeMeridian</b></td>
				<td>SridGetPrimeMeridian( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Prime Meridian</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetDatum</b></td>
				<td>SridGetDatum( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Datum</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetUnit</b></td>
				<td>SridGetUnit( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Unit</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetProjection</b></td>
				<td>SridGetProjection( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Projection</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetAxis_1_Name</b></td>
				<td>SridGetAxis_1_Name( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Name</b> for its <b>first</b> axis.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetAxis_1_Orientation</b></td>
				<td>SridGetAxis_1_Orientation( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Orientation</b> for its <b>first</b> axis.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetAxis_2_Name</b></td>
				<td>SridGetAxis_2_Name( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Name</b> for its <b>second</b> axis.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetAxis_2_Orientation</b></td>
				<td>SridGetAxis_2_Orientation( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Orientation</b> for its <b>second</b> axis.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="topology">SQL functions supporting Topology-Geometry</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">ISO 13249-3<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0" colspan="3">Summary</th></tr>
			<tr><td><b>GetLastTopologyException</b></td>
				<td>GetLastTopologyException( toponame <i>Text</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will return the most recent exception raised by this Topo-Geo, or <b>NULL</b> if no exception is currently pending.</td></tr>
			<tr><td><b>CreateTopoTables</b></td>
				<td>CreateTopoTables( ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create both <b>topologies</b> and <b>networks</b> meta-tables.<hr>
					Will return <i>1</i> on success) or <i>0</i> on failure (including already existing tables).</td></tr>
			<tr><td><b>InitTopoGeo</b></td>
				<td>ST_InitTopoGeo( toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">This SQL function is explicitly required by <b>ISO 13249-3</b>, anyway it's simply implemented as an <i>alias-name</i> for <b>CreateTopology ( toponame )</b>.<hr>
					Will return <i>1</i> on success) or <i>0</i> on failure: <i>-1</i> will be returned on invalid arguments.</td></tr>
			<tr><td><b>CreateTopology</b></td>
				<td>CreateTopology( toponame <i>Text</i> ) : <i>Integer</i><hr>
				    CreateTopology( toponame <i>Text</i> , srid <i>Integer</i> ) : <i>Integer</i><hr>
				    CreateTopology( toponame <i>Text</i> , srid <i>Integer</i>  , has_z <i>Boolean</i> ) : <i>Integer</i><hr>
				    CreateTopology( toponame <i>Text</i> , srid <i>Integer</i>  , has_z <i>Boolean</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create all DBMS objects (tables, triggers, indices and alike) required in order to store a separate Topo-Geo.
				<ul>
					<li><i>toponame</i>: the individual unique name of this Topo-Geo: all subordinated tables will use it as a prefix.</li>
					<li><i>srid</i>: the Spatial Reference System supporting this Topo-Geo (<b>-1</b> by default).</li>
					<li><i>has_z</i>: if set to <b>TRUE</b> this Topo-Geo will support <b>3D - XYZ</b> coordinates (<b>FALSE</b> by default).</li>
					<li><i>tolerence</i>: the standard tolerance to be applied to this Topo-Geo. (<b>0.0</b> by default, i.e. no tolerance at all).</li>
				</ul>
					Will return <i>1</i> on success), <i>0</i> on failure, <i>-1</i> on invalid args: an exception will be raised while passing a <i>negative</i> tolerance value.</td></tr>
			<tr><td><b>DropTopology</b></td>
				<td>DropTopology( toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Completely removes a Topo-Geo (and all data it contains) from the DBMS: to be invoked very cautiously and only if you are absolutely sure of what you are doing.<hr>
					Will return <i>1</i> on success) or <i>0</i> on failure: <i>-1</i> will be returned on invalid arguments.</td></tr>
			<tr><td><b>AddIsoNode</b></td>
				<td>ST_AddIsoNode( toponame <i>Text</i> , face-id <i>Integer</i> , point <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will add a new isolated Node; <i>face-id</i> is expected to exactly match the ID of the Face containing <i>point</i>; by passing a 
					<b>NULL face-id</b> the function itself will take care to identify the appropriate Face.<hr>
					Will return the <b>ID</b> of the inserted Node on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>MoveIsoNode</b></td>
				<td>ST_MoveIsoNode( toponame <i>Text</i> , node-id <i>Integer</i> , point <i>Geometry</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will move an isolated Node from a point to another.<hr>
					Will return a <b>text message</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>RemIsoNode</b></td>
				<td>ST_RemIsoNode( toponame <i>Text</i> , node-id <i>Integer</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove an isolated Node.<hr>
					Will return a <b>text message</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>AddIsoEdge</b></td>
				<td>ST_AddIsoEdge( toponame <i>Text</i> , startnode-id <i>Integer</i> , endnode-id <i>Integer</i> , linestring <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will add a new isolated Edge connecting two isolated Nodes.<hr>
					Will return the <b>ID</b> of the inserted Edge on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>ChangeEdgeGeom</b></td>
				<td>ST_ChangeEdgeGeom( toponame <i>Text</i> , edge-id <i>Integer</i> , linestring <i>Geometry</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will change the geometry of an Edge without affecting Topology relationships.<hr>
					Will return a <b>text message</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>RemIsoEdge</b></td>
				<td>ST_RemIsoEdge( toponame <i>Text</i> , edge-id <i>Integer</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove an isolated Edge.<hr>
					Will return a <b>text message</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>NewEdgesSplit</b></td>
				<td>ST_NewEdgesSplit( toponame <i>Text</i> , edge-id <i>Integer</i> , point <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will split an Edge by creating a new intermediate Node. The original Edge will be deleted and will be replaced by two new Edges.<hr>
					Will return the <b>ID</b> of the inserted Node on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>ModEdgeSplit</b></td>
				<td>ST_ModEdgeSplit( toponame <i>Text</i> , edge-id <i>Integer</i> , point <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will split an Edge by creating a new intermediate Node. The original Edge will be modified and a new Edge will be inserted.<hr>
					Will return the <b>ID</b> of the inserted Node on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>NewEdgeHeal</b></td>
				<td>ST_NewEdgeHeal( toponame <i>Text</i> , edge1-id <i>Integer</i> , edge2-id <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will heal two Edges by deleting the Node connecting them. Both the original Edges will be deleted and will be replaced by
					a new Edge preserving the same orientation of the first Edge provided.<hr>
					Will return the <b>ID</b> of the removed Node on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>ModEdgeHeal</b></td>
				<td>ST_ModEdgeHeal( toponame <i>Text</i> , edge1-id <i>Integer</i> , edge2-id <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will heal two Edges by deleting the Node connecting them. The first Edge provided will be modified and the second deleted.<hr>
					Will return the <b>ID</b> of the removed Node on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>AddEdgeNewFaces</b></td>
				<td>ST_AddEdgeNewFaces( toponame <i>Text</i> , startnode-id <i>Integer</i> , endnode-id <i>Integer</i> , linestring <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will add a new Edge connecting two Nodes. If this new Edge splits a Face the original Face will be deleted and replaced by two new Faces.<hr>
					Will return the <b>ID</b> of the inserted Edge on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>AddEdgeModFace</b></td>
				<td>ST_AddEdgeModFace( toponame <i>Text</i> , startnode-id <i>Integer</i> , endnode-id <i>Integer</i> , linestring <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will add a new Edge connecting two Nodes. If this new Edge splits a Face the original Face will be modified and a new Face will be inserted.<hr>
					Will return the <b>ID</b> of the inserted Edge on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>RemEdgeNewFace</b></td>
				<td>ST_RemEdgeNewFace( toponame <i>Text</i> , edge-id <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove an Edge. If the removed Edge separated two Faces the original Faces will be deleted and replaced by a new Face.<hr>
					Will return the <b>ID</b> of the inserted Face on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>RemEdgeModFace</b></td>
				<td>ST_RemEdgeModFace( toponame <i>Text</i> , edge-id <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove an Edge. If the removed Edge separated two Faces one of then will be modified and the other deleted.<hr>
					Will return the <b>ID</b> of the surviving Face on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>GetFaceGeometry</b></td>
				<td>ST_GetFaceGeometry( toponame <i>Text</i> , face-id <i>Integer</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will return the exact Geometry of a Face.<hr>
					Will return a <b>Polygon</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>GetFaceEdges</b></td>
				<td>ST_GetFaceEdges( toponame <i>Text</i> , face-id <i>Integer</i> ) : <i>DB-table</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will update a DB-Table containing the ordered list of all Edges delimiting the given Face. 
					The orientation will always be counterclockwise, and all Edges traversed in the opposite direction (i.e. from <u>end</u> to <u>start</u>) will be marked by a <b>negative sign</b>.<hr>
					Will return <b>NULL</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>ValidateTopoGeo</b></td>
				<td>ST_ValidateTopoGeo( toponame <i>Text</i> ) : <i>DB-table</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create a DB-Table containing a validation report for the given TopoGeo: if the output table is empty and no exception was raised
					the Topology is assumed to be fully valid, otherwise a row will be inserted into the table for each detected Topology invalidity.<br>
					If the destination table already exists it will be dropped and created yet again.<hr>
					Will return <b>NULL</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>CreateTopoGeo</b></td>
				<td>ST_CreateTopoGeo( toponame <i>Text</i> , geometry <i>BLOB</i> )</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will populate a full Topology by importing a collection of arbitrary Geometries.<br>
					The destination Topology must already exists and must be empty; both SRID and dimensions of input Geometries must match SRID and dimensions declared by Topology.<hr>
					Will return <b>NULL</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>GetNodeByPoint</b></td>
				<td>GetNodeByPoint( toponame <i>Text</i> , point <i>Geometry</i> ) : <i>Integer</i><hr>
				    GetNodeByPoint( toponame <i>Text</i> , point <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to find the ID of a Node located at Point.
				    <ul><li>The optional argument <b>tolerance</b> if omitted will assume the corresponding value declared when creating the target Topology.</li></ul><hr>
					Will return the ID of the Node on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>GetEdgeByPoint</b></td>
				<td>GetEdgeByPoint( toponame <i>Text</i> , point <i>Geometry</i> ) : <i>Integer</i><hr>
				    GetEdgeByPoint( toponame <i>Text</i> , point <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to find the ID of an Edge intersecting the given Point.
				    <ul><li>The optional argument <b>tolerance</b> if omitted will assume the corresponding value declared when creating the target Topology.</li></ul><hr>
					Will return the ID of the Edge on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>GetFaceByPoint</b></td>
				<td>GetFaceByPoint( toponame <i>Text</i> , point <i>Geometry</i> ) : <i>Integer</i><hr>
				    GetFaceByPoint( toponame <i>Text</i> , point <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to find the ID of a Face intersecting the given Point.
				    <ul><li>The optional argument <b>tolerance</b> if omitted will assume the corresponding value declared when creating the target Topology.</li></ul><hr>
					Will return the ID of the Face on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_AddPoint</b></td>
				<td>TopoGeo_AddPoint( toponame <i>Text</i> , point <i>Geometry</i> ) : <i>Text</i><hr>
				    TopoGeo_AddPoint( toponame <i>Text</i> , point <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to add a <b>Point</b> (or even a <b>MultiPoint</b>) to an already existing Topology, possibly splitting existing Edges.
				    <ul><li>The optional argument <b>tolerance</b> if omitted will assume the corresponding value declared when creating the target Topology.</li></ul><hr>
					Will return a comma separated list of all IDs of corresponding Nodes on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_AddLineString</b></td>
				<td>TopoGeo_AddLineString( toponame <i>Text</i> , linestring <i>Geometry</i> ) : <i>Integer</i><hr>
				    TopoGeo_AddLineString( toponame <i>Text</i> , linestring <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to add a <b>Linestring</b> (or even a <b>MultiLinestring</b>) to an already existing Topology, possibly splitting existing Edges/Faces.
				    <ul><li>The optional argument <b>tolerance</b> if omitted will assume the corresponding value declared when creating the target Topology.</li></ul><hr>
					Will return a comma separated list of all IDs of the corresponding Edges on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_AddLineStringNoFace</b></td>
				<td>TopoGeo_AddLineStringNoFace( toponame <i>Text</i> , linestring <i>Geometry</i> ) : <i>Integer</i><hr>
				    TopoGeo_AddLineStringNoFace( toponame <i>Text</i> , linestring <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Very similar to <b>TopoGeo_AddLinestring</b> except for a very critical difference.
				This function is strongly optimized for maximum speed, and will just update Nodes and Edges purposely ignoring Faces.<br>
				Consequently it will always leave the target Topology in an <i>inconsistent state</i>; only after executing <b>TopoGeo_Polygonize()</b> all Faces will be
				properly restored and the target Topology will finally resume a consistent state.
				    <ul><li>The optional argument <b>tolerance</b> if omitted will assume the corresponding value declared when creating the target Topology.</li></ul><hr>
					Will return a comma separated list of all IDs of the corresponding Edges on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_TopoSnap</b></td>
				<td>TopoGeo_TopoSnap( toponame <i>Text</i> , input <i>Geometry</i> , iterate <i>Integer</i> ) : <i>Geometry</i><hr>
				    TopoGeo_TopoSnap( toponame <i>Text</i> , input <i>Geometry</i> , tolerance_snap <i>Double precision</i>  , tolerance_removal <i>Double precision</i> , iterate <i>Integer</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to snap (i.e. renode) the <i>input</i> Geometry (any type) against the Topology identified by <i>toponame</i>.
					<ul>
						<li>the arguments <b>iterate</b> is intended to be Boolean (<b>0</b> = <b>FALSE</b>, any other value = <b>TRUE</b>);
						    when set to <b>TRUE</b> the input Geometry will be iteratively processed until no more snaps are found.</li>
						<li>The optional argument <b>tolerance_snap</b> if omitted will assume the corresponding value declared when creating the target Topology.</li>
						<li>The optional argument <b>tolerance_removal</b> if omitted (or set to <b>NULL</b>) will suppress the removal phase.</li>
					</ul><hr>
					Will return a snapped Geometry on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_SnappedGeoTable</b></td>
				<td>TopoGeo_SnappedGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , output-table <i>Text</i> ,
				    iterate <i>Integer</i> ) : <i>Integer</i><hr>
				    TopoGeo_SnappedGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , output-table <i>Text</i> ,
				    tolerance_snap <i>Double precision</i> , tolerance_removal <i>Double precision</i> , iterate <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to create and populate an <i>output-table</i> by snapping against the Topology identified by <i>toponame</i> all Geometries 
				    from an input GeoTable identified by <i>db-prefix</i>, <i>table-name</i> and <i>column-name</i>.
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the input GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the input GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Topology.</li>
						<li>this function accepts input Geometries of any class: <b>Point</b>, <b>MultiPoint</b>, <b>Linestring</b>, <b>MultiLinestring</b>,
						<b>Polygon</b>, <b>MultiPolygon</b>, <b>GeometryCollection</b> and <b>Geometry</b>.</li>
						<li>argument <b>iterate</b>, <b>tolerance_snap</b> and <b>tolerance_removal</b> will be interpreted exactly in the same way adopted by <b>TopoGeo_TopoSnap()</b>.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_SubdivideLines</b></td>
				<td>TopoGeo_SubdivideLines( input <i>Geometry</i> , line_max_points <i>Integer</i> ) : <i>MultiLinestring</i><hr>
				    TopoGeo_SubdivideLines( input <i>Geometry</i> , line_max_points <i>Integer</i> , line_max_length <i>Double precision</i> ) : <i>MultiLinestring</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to split a <b>Linestring</b> (or even a <b>MultiLinestring</b>) into a collection 
					of shorter LineStrings fully respecting Topology consistency.
					<ul>
						<li>if argument <i>line_max_points</i> is set to a <u>positive</u> value (<b>&gt;= 2</b>) then all input Linestrings will be split into many
						shorter lines having no more than the required number of points.</li>
						<li>if argument <i>line_max_length</i> is set to a <u>positive</u> value, in units of the SRID, then a separate output line will be split every time
						that it becomes longer than the allowed limit.</li>
						<li>either <i>line_max_point</i> and <i>line_max_length</i> can assume a <b>NULL</b> value, this intending <u>ignore</u>.</li>
						<li>if both <i>line_max_point</i> and <i>line_max_length</i> are active at the same time then the first limit encountered will apply.</li>
						<li>in any other case all input Linestrings will be simply copied into the output collection exactly as they are.</li>
					</ul><hr>
					Will return a <b>MultiLinestring</b> Geometry on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_FromGeoTable</b></td>
				<td>TopoGeo_FromGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , line_max_points <i>Integer</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , line_max_points <i>Integer</i> , 
				    line_max_length <i>Double precision</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , line_max_points <i>Integer</i> , 
				    line_max_length <i>Double precision</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to import all Geometries from an input GeoTable identified by <i>db-prefix</i>, <i>table-name</i> and <i>column-name</i> into an already existing Topology-Geometry.
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the input GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the input GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Topology.</li>
						<li>this function accepts input Geometries of any class: <b>Point</b>, <b>MultiPoint</b>, <b>Linestring</b>, <b>MultiLinestring</b>,
						<b>Polygon</b>, <b>MultiPolygon</b>, <b>GeometryCollection</b> and <b>Geometry</b>.</li>
						<li>The optional arguments <i>line_max_points</i> and <i>line_max_length</i> will be interpreted in the same way adopted by <b>TopoGeo_SubdivideLines()</b> 
						(default for both: <b>NULL</b>, this meaning <u>ignore</u>).</li>
				        <li>The optional argument <i>tolerance</i> if omitted will assume the corresponding value declared when creating the target Topology.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_FromGeoTableNoFace</b></td>
				<td>TopoGeo_FromGeoTableNoFace( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTableNoFace( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , line_max_points <i>Integer</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTableNoFace( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , line_max_points <i>Integer</i> , 
				    line_max_length <i>Double precision</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTableNoFace( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , line_max_points <i>Integer</i> , 
				    line_max_length <i>Double precision</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Very similar to <b>TopoGeo_FromGeoTable</b> except for a very critical difference.
				This function is strongly optimized for maximum speed, and will just update Nodes and Edges purposely ignoring Faces.<br>
				Consequently it will always leave the target Topology in an <i>inconsistent state</i>; only after executing <b>TopoGeo_Polygonize()</b> all Faces will be
				properly restored and the target Topology will finally resume a consistent state.<hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_FromGeoTableExt</b></td>
				<td>TopoGeo_FromGeoTableExt( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , dustbin-table <i>Text</i> , 
				    dustbin-view <i>Text</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTableExt( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , dustbin-table <i>Text</i> , 
				    dustbin-view <i>Text</i> , line_max_points <i>Integer</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTableExt( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , dustbin-table <i>Text</i> , 
				    dustbin-view <i>Text</i> , line_max_points <i>Integer</i> , line_max_length <i>Double precision</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTableExt( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , dustbin-table <i>Text</i> , 
				    dustbin-view <i>Text</i> , line_max_points <i>Integer</i> , line_max_length <i>Double precision</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to import all Geometries from an input GeoTable identified by <i>db-prefix</i>, <i>table-name</i> and <i>column-name</i> into an already existing Topology-Geometry.
				    When some Topology expection is encounterd this function will never stop: the Primary Key corresponding to the failing feature will be saved into the <i>dustbin-table</i>,
				    and the loading process will restart from the next feature until all input features will be consumed. 
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the input GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the input GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Topology.</li>
						<li>the input GeoTable is absolutely required to declare a <b>Primary Key</b>.</li>
						<li>this function accepts input Geometries of any class: <b>Point</b>, <b>MultiPoint</b>, <b>Linestring</b>, <b>MultiLinestring</b>,
						<b>Polygon</b>, <b>MultiPolygon</b>, <b>GeometryCollection</b> and <b>Geometry</b>.</li>
						<li><i>dustbin-table</i> is the name of the table intended to store PK values corresponding to features failing to be imported; this table should not already exist
						and will be automatically created by the function itself.</li>
						<li><i>dustbin-view</i> is the name of the Spatial View supporting the above table; this view should not already exist
						and will be automatically created by the function itself.<br>
						<u>Note</u>: both the <i>dustbin-table</i> and the <i>dustbin-view</i> will be always created on the same DB containing the input GeoTable.</li>
						<li>The optional arguments <i>line_max_points</i> and <i>line_max_length</i> will be interpreted in the same way adopted by <b>TopoGeo_SubdivideLines()</b> 
						(default for both: <b>NULL</b>, this meaning <u>ignore</u>).</li>
				        <li>The optional argument <i>tolerance</i> if omitted will assume the corresponding value declared when creating the target Topology.</li>
					</ul><hr>
					Will return <b>0</b> on full success or a <b>positive</b> integer corresponding to the total count of failing features referenced by the <i>dustbin</i> table.<br>
					An exception will be raised only on wrong arguments.</td></tr>
			<tr><td><b>TopoGeo_FromGeoTableNoFaceExt</b></td>
				<td>TopoGeo_FromGeoTableNoFaceExt( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , dustbin-table <i>Text</i> , 
				    dustbin-view <i>Text</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTableNoFaceExt( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , dustbin-table <i>Text</i> , 
				    dustbin-view <i>Text</i> , line_max_points <i>Integer</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTableNoFaceExt( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , dustbin-table <i>Text</i> , 
				    dustbin-view <i>Text</i> , line_max_points <i>Integer</i> , line_max_length <i>Double precision</i> ) : <i>Integer</i><hr>
				    TopoGeo_FromGeoTableNoFaceExt( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> , dustbin-table <i>Text</i> , 
				    dustbin-view <i>Text</i> , line_max_points <i>Integer</i> , line_max_length <i>Double precision</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Very similar to <b>TopoGeo_FromGeoTableExt</b> except for a very critical difference.
				This function is strongly optimized for maximum speed, and will just update Nodes and Edges purposely ignoring Faces.<br>
				Consequently it will always leave the target Topology in an <i>inconsistent state</i>; only after executing <b>TopoGeo_Polygonize()</b> all Faces will be
				properly restored and the target Topology will finally resume a consistent state.<hr>
					Will return <b>0</b> on full success or a <b>positive</b> integer corresponding to the total count of failing features referenced by the <i>dustbin</i> table.<br>
					An exception will be raised only on wrong arguments.</td></tr>
			<tr><td><b>TopoGeo_Polygonize</b></td>
				<td>TopoGeo_Polygonize( toponame <i>Text</i> )<hr>
				    TopoGeo_Polygonize( toponame <i>Text</i> , force_rebuild <i>Boolean</i> )</td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove all existing Faces from a Topology then rebuilding all them by scratch.
				<ul>
					<li>If the Topology already is in a fully consistent state (i.e. all Edges are found to be assigned to their corresponding Faces) the function will immediately return 
					whithout taking any action.</li>
					<li>If the Topology is in an inconsistent state (i.e. some Edges are found lacking their corresponding Faces (preasumably due to previous calls to <b>TopoGeo_AddLinesStringNoFace</b>,
					<b>TopoGeo_FromGeoTableNoFace</b> and/or <b>TopoGeo_FromGeoTableNoFaceExt</b>) the function will effectively rebuild all Faces from scratch.</li>
					<li>If the optional argument <i>force_rebuild</i> is set to <b>TRUE</b> (not <b>0</b>) all Faces will be unconditionally rebuilt.</li>
				</ul>
				<i>Caveat</i>: for efficiency/speed reasons this function requires a substantial amount of available RAM: any attempt to process a very
				huge Topology on a platform supporting a very limited amount of RAM will probably fail due to <b>insufficient memory</b> errors.<hr>
					Will return <b>NULL</b> on full success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_RemoveSmallFaces</b></td>
				<td>TopoGeo_RemoveSmallFaces( toponame <i>Text</i> , min-circularity <i>Double precision</i> ) : <i>Integer</i><hr>
				    TopoGeo_RemoveSmallFaces( toponame <i>Text</i> , min-circularity <i>Double precision</i> , min-area <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove from the given Topology all Faces presenting <b>both</b> a Circularity index smaller than <i>min-circularity</i> <b>and</b> an area smaller than <i>min-area</i>.
				    <ul>
						<li>for a formal definition of the Circularity index please see <a href="#circularity">Circularity()</a></li>
						<li>the Circularity index ranges between <i>1.0</i> and <i>0.0</i>, so setting <b>min-circularity</b> to a value equal or greater than <i>1.0</i> will implicitly disable the
						    corresponding check.</li>
						<li>the <i>optional</i> argument <b>min-area</b> if not specified will assume a <i>0.0</i> value thus implicitly disabling the corresponding check.</li>
				    </ul><hr>
					Will return <b>1</b> on full success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_RemoveDanglingEdges</b></td>
				<td>TopoGeo_RemoveDanglingEdges( toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove from the given Topology all dangling Edges.<hr>
					Will return <b>1</b> on full success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_RemoveDanglingNodes</b></td>
				<td>TopoGeo_RemoveDanglingNodes( toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove from the given Topology all dangling Nodes.<hr>
					Will return <b>1</b> on full success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_NewEdgeHeal</b></td>
				<td>TopoGeo_NewEdgeHeal( toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove from the given Topology all unnecessary Nodes.<br>
				    An unnecessary Node is one connected to exactly two Edges whilst both Edges share the same two Faces; it's obvious that such a Node could be safely removed giving birth to a single Edge
				    without altering in any way the Topological self-consistency.<br>
				    All unnecessary Nodes identified by this function will be removed by implicitly calling <b>ST_NewEdgeHeal()</b><hr>
					Will return <b>1</b> on full success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_ModEdgeHeal</b></td>
				<td>TopoGeo_ModEdgeHeal( toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove from the given Topology all unnecessary Nodes.<br>
				    An unnecessary Node is one connected to exactly two Edges whilst both Edges share the same two Faces; it's obvious that such a Node could be safely removed giving birth to a single Edge
				    without altering in any way the Topological self-consistency.<br>
				    All unnecessary Nodes identified by this function will be removed by implicitly calling <b>ST_ModEdgeHeal()</b><hr>
					Will return <b>1</b> on full success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_NewEdgesSplit</b></td>
				<td>TopoGeo_NewEdgesSplit( toponame <i>Text</i> , line_max_points <i>Integer</i> ) : <i>Integer</i><hr>
				    TopoGeo_NewEdgesSplit( toponame <i>Text</i> , line_max_points <i>Integer</i> , line_max_length <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to split all <i>Edges</i> into a collection of shorter Edges fully respecting Topology consistency.<br>
					The interpretation of <b>line_max_points</b> and <b>line_max_lenght</b> arguments is the same adopted by <b>TopoGeo_SubdivideLines()</b><br>
				    Edges and Nodes will be handled by implicitly calling <b>ST_NewEdgesSplit()</b><hr>
					Will return <b>1</b> on full success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_ModEdgeSplit</b></td>
				<td>TopoGeo_ModEdgeSplit( toponame <i>Text</i> , line_max_points <i>Integer</i> ) : <i>Integer</i><hr>
				    TopoGeo_ModEdgeSplit( toponame <i>Text</i> , line_max_points <i>Integer</i> , line_max_length <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to split all <i>Edges</i> into a collection of shorter Edges fully respecting Topology consistency.<br>
					The interpretation of <b>line_max_points</b> and <b>line_max_lenght</b> arguments is the same adopted by <b>TopoGeo_SubdivideLines()</b><br>
				    Edges and Nodes will be handled by implicitly calling <b>ST_ModEdgeSplit()</b><hr>
					Will return <b>1</b> on full success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_Clone</b></td>
				<td>TopoGeo_Clone( db-prefix <i>Text</i> , toponame <i>Text</i> , new-toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will clone an existing Topology into another; the destionation Topology shall not exist and will be automatically created.
					<ul>
						<li><i>db-prefix</i> may be <b>NULL</b>, and in this case the input Topology will be searched within the "<b>MAIN</b>" database.
						The input Topology can be freely located within anyone of the currently <i>attached</i> databases.</li>
						<li>the output Topology will be always created within the "<b>MAIN</b>" database.</li>
					</ul>
					<hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_GetEdgeSeed</b></td>
				<td>TopoGeo_GetEdgeSeed( toponame <i>Text</i> , edge-id <i>Integer</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will return a Point Geometry uniquely identifying an Edge (i.e. spatially intersecting the Edge).<hr>
					Will return a <b>Point</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_GetFaceSeed</b></td>
				<td>TopoGeo_GetFaceSeed( toponame <i>Text</i> , face-id <i>Integer</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will return a Point Geometry uniquely identifying a Face (i.e. spatially intersecting the Face).<hr>
					Will return a <b>Point</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_SnapPointToSeed</b></td>
				<td>TopoGeo_SnapPointToSeed( point <i>Geometry</i> , toponame <i>Text</i> , distance <i>Double</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will possibly return a new <b>Point</b> precisely snapped to the nearset TopoNode within the given <b>distance</b>; if no such TopoNode exists <b>NULL</b> will be returned.<br>
				An exception will be raised on invalid arguments.</td></tr>
			<tr><td><b>TopoGeo_SnapLineToSeed</b></td>
				<td>TopoGeo_SnapLineToSeed( line <i>Geometry</i> , toponame <i>Text</i> , distance <i>Double</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will possibly return a new <b>Linestring</b> precisely snapped to the nearset Edge TopoSeed within the given <b>distance</b>; if no such TopoSeed exists <b>NULL</b> will be returned.<br>
				An exception will be raised on invalid arguments.</td></tr>
			<tr><td><b>TopoGeo_DisambiguateSegmentEdges</b></td>
				<td>TopoGeo_DisambiguateSegmentEdges( toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Ensures that all Edges on a Topology-Geometry will have not less than three vertices.
					<ul>
						<li>all Edges found already definining three or more vertices will be left untouched as they are.</li>
						<li>all Edges found simply being a two-points segment will be changed by interpolating a third intermediate vertex.</li>
						<li>this function is harmless (doesn't substantially alters the Topology in any way) and ensures that all <b>Seeds</b> will certainly be not ambiguous.</li>
					</ul>
					Will return the total number of changed Edges on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_UpdateSeeds</b></td>
				<td>TopoGeo_UpdateSeeds( toponame <i>Text</i> ) : <i>Integer</i><hr>
				    TopoGeo_UpdateSeeds( toponame <i>Text</i> , incremental-mode <i>Integer</i> ) : <i>Integer</i> </td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will update all persistent Edge- and Face-Seeds so to correctly represent the current state of the underlying Topology.
					<ul>
						<li>if the optional argument <i>incremental-mode</i> is set to TRUE an incremental update (faster) will be applied,
						otherwise all persistent Seeds will be rebuilt from scratch (slower).</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_PolyFacesList</b></td>
				<td>TopoGeo_PolyFacesList( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to export into an output Table all relationships between the Faces of some Topology-Geometry and Polygons/Multipolygons found within a given
				    Reference-GeoTable. 
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the reference GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>ref-column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the reference GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Topology.</li>
						<li>this function accepts input Geometries only of the <b>Polygon</b> or <b>MultiPolygon</b> types.</li>
						<li>the output Table will be always located on the <b>"MAIN"</b> DB and must not exists; it will be automatically created.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_LineEdgesList</b></td>
				<td>TopoGeo_LineEdgesList( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to export into an output Table all relationships between the Edges of some Topology-Geometry and Linestrings/Multilinestrings found within a given
				    Reference-GeoTable. 
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the reference GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>ref-column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the reference GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Topology.</li>
						<li>this function accepts input Geometries only of the <b>Linestring</b> or <b>MultiLinestring</b> types.</li>
						<li>the output Table will be always located on the <b>"MAIN"</b> DB and must not exists; it will be automatically created.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_ToGeoTable</b></td>
				<td>TopoGeo_ToGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> ) : <i>Integer</i><hr>
				    TopoGeo_ToGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> , with-spatial-index <i>Boolenan</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to export into an Output GeoTable all Geometries out from a Topology-Geometry matching (via Seed-based references) a given
				    Reference-GeoTable containing information attributes. 
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the reference GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>ref-column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the reference GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Topology.</li>
						<li>this function accepts input Geometries of any class: <b>Point</b>, <b>MultiPoint</b>, <b>Linestring</b>, <b>MultiLinestring</b>,
						<b>Polygon</b>, <b>MultiPolygon</b>, <b>GeometryCollection</b> and <b>Geometry</b>.</li>
						<li>the output GeoTable will be always located on the <b>"MAIN"</b> DB and must not exists; it will be automatically created with the same identical
						    attributes of the reference GeoTable.</li>
						<li>all spatial features found into the reference GeoTable will be copied into the output GeoTable. All information attributes will be preserved
						    exactly as they are, and the feature's Geometry will be built by aggregating all Topology objects matching the reference Geometry by Seed correspondences.<br>
						    If no matching Topology objectes are found the result will be a <b>NULL</b> output Geometry.</li>
						<li><i><u>Please note</u></i>: this function will automatically invoke <b>TopoGeo_UpdateSeeds()</b> (<i>incremental mode</i>).</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_ToGeoTableGeneralize</b></td>
				<td>TopoGeo_ToGeoTableGeneralize( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> , tolerance <i>Double precision</i> ) : <i>Integer</i><hr>
				    TopoGeo_ToGeoTableGeneralize( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> , tolerance <i>Double precision</i> , with-spatial-index <i>Boolean</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Exactly the same as <b>TopoGeo_ToGeoTable()</b> except in that all exported geometries will be simplified / generalized still maintaining full topological consistency. 
					<ul>
						<li><i>tolerance</i> represents the approximation radius required by the Douglas-Peuker simplification algorithm.<br>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_CreateTopoLayer</b></td>
				<td>TopoGeo_CreateTopoLayer( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, topolayer-name <i>Text</i> ) : <i>Integer</i><hr>
				    TopoGeo_CreateTopoLayer( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, topolayer-name <i>Text</i> , is-view <i>Boolean</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create a fully defined new <b>TopoLayer</b> starting from a reference GeoTable:
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the reference GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>ref-column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the reference GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Topology.</li>
						<li>this function accepts input Geometries of any class: <b>Point</b>, <b>MultiPoint</b>, <b>Linestring</b>, <b>MultiLinestring</b>,
						<b>Polygon</b>, <b>MultiPolygon</b>, <b>GeometryCollection</b> and <b>Geometry</b>.</li>
						<li>if the optional boolean argument <b>is-view</b> is set to <b>TRUE</b> (any other value different from zero) then a View or a Table containing a unregistered Geometry column will
						    be accepted (<b>FALSE</b> by default).<br>
						    In this case <b>ref-column</b> must be always explicitly defined, and must contain all Geometries matching both <b>SRID</b> and <b>dimensions</b> declared by the target Topology.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_InitTopoLayer</b></td>
				<td>TopoGeo_InitTopoLayer( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , topolayer-name <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will initialize a partialy defined new <b>TopoLayer</b> starting from a reference plain Table or View:
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the reference Table or View is expected to be located within the <b>"MAIN"</b> database.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_RemoveTopoLayer</b></td>
				<td>TopoGeo_RemoveTopoLayer( toponame <i>Text</i> , topolayer-name <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will completely remove an existing <b>TopoLayer</b>.<hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_ExportTopoLayer</b></td>
				<td>TopoGeo_ExportTopoLayer( toponame <i>Text</i> , topolayer-name <i>Text</i> , out-table <i>Text</i> ) : <i>Integer</i><hr>
				    TopoGeo_ExportTopoLayer( toponame <i>Text</i> , topolayer-name <i>Text</i> , out-table <i>Text</i> , with-spatial-index <i>Boolean</i> ) : <i>Integer</i><hr>
				    TopoGeo_ExportTopoLayer( toponame <i>Text</i> , topolayer-name <i>Text</i> , out-table <i>Text</i> , with-spatial-index <i>Boolean</i> , create-only <i>Boolean</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create and populate a GeoTable corresponding to a <b>TopoLayer</b>.
					<ul>
						<li>if the optional boolean argument <b>with-spatial-index</b> is set to <b>TRUE</b> (any other value different from zero) then a <b>Spatial Index</b> supporting
						the output GeoTable will be automatically created (<b>FALSE</b> by default).</li>
						<li>if the optional boolean argument <b>create-only</b> is set to <b>TRUE</b> (any other value different from zero) then the output GeoTable will be created 
						but will not be populated thus remaining completely empty (<b>FALSE</b> by default).</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoGeo_InsertFeatureFromTopoLayer</b></td>
				<td>TopoGeo_InsertFeatureFrom( toponame <i>Text</i> , topolayer-name <i>Text</i> , out-table <i>Text</i> , fid <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will inserting a single TopoFeature identified by is <b>fid</b> into a GeoTable corresponding to a <b>TopoLayer</b>.
					<ul>
						<li>the output GeoTable must exist and is expected to be created by a previous call to <b>TopoGeo_ExportTopoLayer()</b>.</li>
						<li>the TopoFeature identified by <b>fid</b> must exist and a corresponding row must not be already inserted into the output GeoTable.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="network">SQL functions supporting Topology-Network</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">ISO 13249-3<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0" colspan="3">Summary</th></tr>
			<tr><td><b>GetLastNetworkException</b></td>
				<td>GetLastNetworkException( netname <i>Text</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will return the most recent exception raised by this Topo-Net, or <b>NULL</b> if no exception is currently pending.</td></tr>
			<tr><td><b>InitTopoNet</b></td>
				<td>ST_InitTopoNet( netname <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">This SQL function is explicitly required by <b>ISO 13249-3</b>, anyway it's simply implemented as an <i>alias-name</i> for <b>CreateNetwork ( netname )</b>.<hr>
					Will return <i>1</i> on success) or <i>0</i> on failure: <i>-1</i> will be returned on invalid arguments.</td></tr>
			<tr><td><b>CreateNetwork</b></td>
				<td>CreateNetwork( netname <i>Text</i> ) : <i>Integer</i><hr>
				    CreateNetwork( netname <i>Text</i> , spatial <i>Boolean</i> ) : <i>Integer</i><hr>
				    CreateNetwork( netname <i>Text</i> , spatial <i>Boolean</i> , srid <i>Integer</i> ) : <i>Integer</i><hr>
				    CreateNetwork( netname <i>Text</i> , spatial <i>Boolean</i> , srid <i>Integer</i> , has_z <i>Boolean</i> ) : <i>Integer</i><hr>
				    CreateNetwork( netname <i>Text</i> , spatial <i>Boolean</i> , srid <i>Integer</i> , has_z <i>Boolean</i> , allow_coincident <i>Boolean</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create all DBMS objects (tables, triggers, indices and alike) required in order to store a separate Topo-Net.
				<ul>
					<li><i>netname</i>: the individual unique name of this Topo-Net: all subordinated tables will use it as a prefix.</li>
					<li><i>spatial</i>: if set to <b>TRUE</b> this Topo-Net will be considered a <b>Spatial-Network</b>, otherwise a <b>Logical-Network</b> will be assumed (<b>FALSE</b> by default).</li>
					<li><i>srid</i>: the Spatial Reference System supporting this Topo-Net (<b>-1</b> by default).</li>
					<li><i>has_z</i>: if set to <b>TRUE</b> this Topo-Net will support <b>3D - XYZ</b> coordinates (<b>FALSE</b> by default).</li>
					<li><i>allow_coincident</i>: if set to <b>FALSE</b> all <u>Node-on-Node</u>, <u>Link-on-Node</u> or <u>Node-on-Link</u> conditions will raise an exception (<b>TRUE</b> by default).</li>
				</ul>
					Will return <i>1</i> on success), <i>0</i> on failure, <i>-1</i> on invalid arguments.</td></tr>
			<tr><td><b>DropNetwork</b></td>
				<td>DropNetwork( netname <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Completely removes a Topo-Net (and all data it contains) from the DBMS: to be invoked very cautiously and only if you are absolutely sure of what you are doing.<hr>
					Will return <i>1</i> on success) or <i>0</i> on failure: <i>-1</i> will be returned on invalid arguments.</td></tr>
			<tr><td><b>AddIsoNetNode</b></td>
				<td>ST_AddIsoNetNode( netname <i>Text</i> , point <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will add a new isolated NetNode.<hr>
					Will return the <b>ID</b> of the inserted NetNode on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>MoveIsoNetNode</b></td>
				<td>ST_MoveIsoNetNode( netname <i>Text</i> , node-id <i>Integer</i> , point <i>Geometry</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will move an isolated NetNode from a point to another.<hr>
					Will return a <b>text message</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>RemIsoNetNode</b></td>
				<td>ST_RemIsoNetNode( netname <i>Text</i> , node-id <i>Integer</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove an isolated NetNode.<hr>
					Will return a <b>text message</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>AddLink</b></td>
				<td>ST_AddLink( netname <i>Text</i> , startnode-id <i>Integer</i> , endnode-id <i>Integer</i> , linestring <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will add a new Link connecting two NetNodes.<hr>
					Will return the <b>ID</b> of the inserted Link on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>ChangeLinkGeom</b></td>
				<td>ST_ChangeLinkGeom( netname <i>Text</i> , link-id <i>Integer</i> , linestring <i>Geometry</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will change the geometry of a Link without affecting Topology relationships.<hr>
					Will return a <b>text message</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>RemoveLink</b></td>
				<td>ST_RemoveLink( netname <i>Text</i> , link-id <i>Integer</i> ) : <i>Text</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will remove a Link.<hr>
					Will return a <b>text message</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>NewLogLinkSplit</b></td>
				<td>ST_NewLogLinkSplit( netname <i>Text</i> , link-id <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will split a Link (of the <u>Logical</u> type) by creating a new intermediate NetNode. The original Link will be deleted and will be replaced by two new Links.<hr>
					Will return the <b>ID</b> of the inserted Node on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>ModLogLinkSplit</b></td>
				<td>ST_ModLogLingSplit( netname <i>Text</i> , link-id <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will split a Link (of the <u>Logical</u> type) by creating a new intermediate NetNode. The original Link will be modified and a new Link will be inserted.<hr>
					Will return the <b>ID</b> of the inserted Node on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>NewGeoLinkSplit</b></td>
				<td>ST_NewGeoLinkSplit( netame <i>Text</i> , link-id <i>Integer</i> , point <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will split a Link (of the <u>Spatial</u> type) by creating a new intermediate NetNode. The original Link will be deleted and will be replaced by two new Links.<hr>
					Will return the <b>ID</b> of the inserted NetNode on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>ModGeoLinkSplit</b></td>
				<td>ST_ModGeoLingSplit( netame <i>Text</i> , link-id <i>Integer</i> , point <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will split a Link (of the <u>Spatial</u> type) by creating a new intermediate NetNode. The original Link will be modified and a new Link will be inserted.<hr>
					Will return the <b>ID</b> of the inserted NetNode on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>NewLinkHeal</b></td>
				<td>ST_NewLinkHeal( netname <i>Text</i> , link1-id <i>Integer</i> , link2-id <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will heal two Links by deleting the NetNode connecting them. Both the original Links will be deleted and will be replaced by
					a new Link preserving the same orientation of the first Link provided.<hr>
					Will return the <b>ID</b> of the removed NetNode on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>ModLinkHeal</b></td>
				<td>ST_ModLinkHeal( netname <i>Text</i> , link1-id <i>Integer</i> , link2-id <i>Integer</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will heal two Links by deleting the NetNode connecting them. The first Link provided will be modified and the second deleted.<hr>
					Will return the <b>ID</b> of the removed NetNode on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>LogiNetFromTGeo</b></td>
				<td>ST_LogiNetFromTGeo( netname <i>Text</i> , toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create a <b>Logical Topology-Network</b> from an existing <b>Topology-Geometry</b>.<br>
					The destination <i>TopoNet</i> is expected to exist and to be completely empty.<hr>
					Will return <b>1</b> on success; an exception will be raised on failure.<br>
					Calling this function on behalf of some Network of the Spatial type will raise an exception.</td></tr>
			<tr><td><b>SpatNetFromTGeo</b></td>
				<td>ST_SpatNetFromTGeo( netname <i>Text</i> , toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create a <b>Spatial Topology-Network</b> from an existing <b>Topology-Geometry</b>.<br>
					The destination <i>TopoNet</i> is expected to exist and to be completely empty.<hr>
					Will return <b>1</b> on success; an exception will be raised on failure.<br>
					Calling this function on behalf of some Network of the Logical type will raise an exception; both the <i>TopoNet</i>
					and the <i>TopoGeo</i> are expected to declared the same identical <b>SRID</b> and <b>dimensions</b> (<i>2D</i> or <i>3D</i>),
					otherwise an exception will be raised.</td></tr>
			<tr><td><b>SpatNetFromGeom</b></td>
				<td>ST_SpatNetFromGeom( netname <i>Text</i> , geometry <i>BLOB</i> )</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will populate a full Network by importing a collection of arbitrary Geometries.<br>
					The destination Network must already exists and must be empty; both SRID and dimensions of input Geometries must match SRID and dimensions declared by Network.<br>
					Calling this function on behalf of some Network of the Logical type will raise an exception<hr>
					Will return <b>NULL</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>ValidLogicalNet</b></td>
				<td>ST_ValidLogicalNet( netname <i>Text</i> ) : <i>DB-table</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create a DB-Table containing a validation report for the given TopoNet of the Logical type: if the output table is empty and no exception was raised
					the Network is assumed to be fully valid, otherwise a row will be inserted into the table for each detected Topology invalidity.<br>
					If the destination table already exists it will be dropped and created yet again.<hr>
					Will return <b>NULL</b> on success; an exception will be raised on failure.<br>
					Calling this function on behalf of some Network of the Spatial type will raise an exception.</td></tr>
			<tr><td><b>ValidSpatialNet</b></td>
				<td>ST_ValidSpatialNet( netname <i>Text</i> ) : <i>DB-table</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will create a DB-Table containing a validation report for the given TopoNet of the Spatial type: if the output table is empty and no exception was raised
					the Network is assumed to be fully valid, otherwise a row will be inserted into the table for each detected Topology invalidity.<br>
					If the destination table already exists it will be dropped and created yet again.<hr>
					Will return <b>NULL</b> on success; an exception will be raised on failure.<br>
					Calling this function on behalf of some Network of the Logical type will raise an exception.</td></tr>
			<tr><td><b>GetNetNodeByPoint</b></td>
				<td>GetNetNodeByPoint( netname <i>Text</i> , point <i>Geometry</i> ) : <i>Integer</i><hr>
				    GetNetNodeByPoint( netname <i>Text</i> , point <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to find the ID of a NetNode located at Point.
				    <ul><li>The optional argument <i>tolerance</i> if omitted will imply an exact coincidence (<b>0.0</b> by default).</li></ul><hr>
					Will return the ID of the NetNode on success; an exception will be raised on failure.<br>
					<b>Note</b>: this function cannot be applied to a <i>Logical Network</i></td></tr>
			<tr><td><b>GetLinkByPoint</b></td>
				<td>GetLinkByPoint( netname <i>Text</i> , point <i>Geometry</i> ) : <i>Integer</i><hr>
				    GetLinkByPoint( netname <i>Text</i> , point <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to find the ID of a Link intersecting the given Point.
				    <ul><li>The optional argument <i>tolerance</i> if omitted will imply an exact coincidence (<b>0.0</b> by default).</li></ul><hr>
					Will return the ID of the Link on success; an exception will be raised on failure.<br>
					<b>Note</b>: this function cannot be applied to a <i>Logical Network</i></td></tr>
			<tr><td><b>TopoNet_FromGeoTable</b></td>
				<td>TopoNet_FromGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , table-name <i>Text</i> , column-name <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to import all Geometries from an input GeoTable identified by <i>db-prefix</i>, <i>table-name</i> and <i>column-name</i> into an already existing Topology-Network.
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the input GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the input GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Topology.</li>
						<li>this function only accepts input Geometries of the <b>Linestring</b> or <b>MultiLinestring</b> classes.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoNet_Clone</b></td>
				<td>TopoNet_Clone( netname <i>Text</i> , new-netname <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will clone an existing Network into another; the destionation Network shall not exist and will be automatically created.<hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoNet_GetLinkSeed</b></td>
				<td>TopoNet_GetLinkSeed( netname <i>Text</i> , link-id <i>Integer</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will return a Point Geometry uniquely identifying a Link (i.e. spatially intersecting the Link).<hr>
					Will return a <b>Point</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoNet_DisambiguateSegmentLinks</b></td>
				<td>TopoNet_DisambiguateSegmentLinks( toponame <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Ensures that all Links on a Topology-Network will have not less than three vertices.
					<ul>
						<li>all Links found already definining three or more vertices will be left untouched as they are.</li>
						<li>all Links found simply being a two-points segment will be changed by interpolating a third intermediate vertex.</li>
						<li>this function is harmless (doesn't substantially alters the Network in any way) and ensures that all <b>Seeds</b> will certainly be not ambiguous.</li>
					</ul>
					Will return the total number of changed Links on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoNet_UpdateSeeds</b></td>
				<td>TopoNet_UpdateSeeds( netname <i>Text</i> ) : <i>Integer</i><hr>
				    TopoNet_UpdateSeeds( netname <i>Text</i> , incremental-mode <i>Integer</i> ) : <i>Integer</i> </td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPOM</td>
				<td colspan="3">Will update all persistent Link-Seeds so to correctly represent the current state of the underlying Network.
					<ul>
						<li>if the optional argument <i>incremental-mode</i> is set to TRUE an incremental update (faster) will be applied,
						otherwise all persistent Seeds will be rebuilt from scratch (slower).</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoNet_LineLinksList</b></td>
				<td>TopoNet_LineLinksList( netname <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to export into an output Table all relationships between the Links of some Topology-Network and Linestrings/Multilinestrings found within a given
				    Reference-GeoTable. 
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the reference GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>ref-column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the reference GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Network.</li>
						<li>this function accepts input Geometries only of the <b>Linestring</b> or <b>MultiLinestring</b> types.</li>
						<li>the output Table will be always located on the <b>"MAIN"</b> DB and must not exists; it will be automatically created.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoNet_ToGeoTable</b></td>
				<td>TopoNet_ToGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> ) : <i>Integer</i><hr>
				    TopoNet_ToGeoTable( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> , with-spatial-index <i>Boolean</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Will attempt to export into an Output GeoTable all Geometries out from a Topology-Network matching (via Seed-based references) a given
				    Reference-GeoTable containing information attributes. 
					<ul>
						<li><i>db-prefix</i> can be <b>NULL</b>, and in this case the reference GeoTable is expected to be located within the <b>"MAIN"</b> database.</li>
						<li><i>ref-column-name</i> too can be <b>NULL</b>, and in this case the name of the column containing Geometries will be automatically retrieved;
						if <b>"db"."table"</b> does not contains any Geometry column, or if it contains two or more Geometries an exception will be raised.</li>
						<li>the reference GeoTable must be properly registered and must match both <b>SRID</b> and <b>dimensions</b> declared by the target Network.</li>
						<li>this function accepts input Geometries of the following classes: <b>Point</b>, <b>MultiPoint</b>, <b>Linestring</b>, <b>MultiLinestring</b>,
						<b>GeometryCollection</b> and <b>Geometry</b>.<br>
						All areal Geometries (<i>Polygon</i>, <i>MultiPolygon</i>) will be always ignored.</li>
						<li>the output GeoTable will be always located on the <b>"MAIN"</b> DB and must not exists; it will be automatically created with the same identical
						    attributes of the reference GeoTable.</li>
						<li>all spatial features found into the reference GeoTable will be copied into the output GeoTable. All information attributes will be preserved
						    exactly as they are, and the feature's Geometry will be built by aggregating all Topology objects matching the reference Geometry by Seed correspondences.<br>
						    If no matching Topology objectes are found the result will be a <b>NULL</b> output Geometry.</li>
						<li><i><u>Please note</u></i>: this function will automatically invoke <b>TopoNet_UpdateSeeds()</b> (<i>incremental mode</i>).</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td><b>TopoNet_ToGeoTableGeneralize</b></td>
				<td>TopoNet_ToGeoTableGeneralize( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> , tolerance <i>Double precision</i> ) : <i>Integer</i><hr>
				    TopoNet_ToGeoTableGeneralize( toponame <i>Text</i> , db-prefix <i>Text</i> , ref-table-name <i>Text</i> , ref-column-name <i>Text</i>, out-table <i>Text</i> , tolerance <i>Double precision</i> , with-spatial-index <i>Boolean</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0"></td>
				<td align="center" bgcolor="#f0d0f0">RTTOPO</td>
				<td colspan="3">Exactly the same as <b>TopoNet_ToGeoTable()</b> except in that all exported geometries will be simplified / generalized still maintaining full topological consistency. 
					<ul>
						<li><i>tolerance</i> represents the approximation radius required by the Douglas-Peuker simplification algorithm.</li>
					</ul><hr>
					Will return <b>1</b> on success; an exception will be raised on failure.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="wms">SQL functions supporting WMS datasources</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0" colspan="3">Summary</th></tr>
			<tr><td><b>WMS_CreateTables</b></td>
				<td>WMS_CreateTables() : <i>Integer</i></td>
				<td colspan="3">Creates all DB Tables required for permanently egistering WMS datasources and their configurations.<hr>
					Will return <b>1</b> on success; <b>0</b> on failure.</td></tr>
			<tr><td><b>WMS_RegisterGetCapabilities</b></td>
				<td>WMS_RegisterGetCapabilities( url <i>Text</i> ) : <i>Integer</i><hr>
				    WMS_RegisterGetCapabilities( url <i>Text</i> , title <i>Text</i> , abstract <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Registers a WMS server.<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_UnRegisterGetCapabilities</b></td>
				<td>WMS_UnRegisterGetCapabilities( url <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Unregisters a WMS server (and all related children).<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_SetGetCapabilitiesInfos</b></td>
				<td>WMS_SetGetCapabilitiesInfos( url <i>Text</i> , title <i>Text</i> , abstract <i>Text</i> )</td>
				<td colspan="3">Sets or updates the <b>Title</b> and <b>Abstract</b> for the WMS server identified by <b>url</b>.<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_RegisterGetMap</b></td>
				<td>WMS_RegisterGetMap( getcapabilitites_url <i>Text</i> , getmap_url <i>Text</i> , layer_name <i>Text</i> , version <i>Text</i>, ref_sys <i>Text</i> ,
                    image_format <i>Text</i> , style <i>Text</i> , is_transparent <i>Boolean</i> , flip_axes <i>Boolean</i> ) : <i>Integer</i><hr>
				    WMS_RegisterGetMap( getcapabilitites_url <i>Text</i> , getmap_url <i>Text</i> , layer_name <i>Text</i> , version <i>Text</i>, ref_sys <i>Text</i> ,
                    image_format <i>Text</i> , style <i>Text</i> , is_transparent <i>Boolean</i> , flip_axes <i>Boolean</i> , is_tiled <i>Boolean</i> , 
                    is_cached <i>Boolean</i> , tile_width <i>Integer</i> , tile_height <i>Integer</i> ) : <i>Integer</i><hr>
				    WMS_RegisterGetMap( getcapabilitites_url <i>Text</i> , getmap_url <i>Text</i> , layer_name <i>Text</i> , title <i>Text</i> , abstract <i>Text</i> , 
				    version <i>Text</i>, ref_sys <i>Text</i> , image_format <i>Text</i> , style <i>Text</i> , is_transparent <i>Boolean</i> , flip_axes <i>Boolean</i> , 
				    is_tiled <i>Boolean</i> , is_cached <i>Boolean</i> , tile_width <i>Integer</i> , tile_height <i>Integer</i> , bgcolor <i>Text</i> ,
				    is_queryable <i>Boolean</i> , getfeatureinfo_url <b>Text</b> ) : <i>Integer</i></td>
				<td colspan="3">Registers a WMS layer.
					<ul>
						<li><b>getcapabilities_url</b>: URL referencing the parent <i>WMS GetCapabilities</i> request (must be already registered).</li>
						<li><b>getmap_url</b>: base URL corresponding to the <i>WMS GetMap</i> request.</li>
						<li><b>layer_name</b> name of the <i>WMS Layer</i>.</li>
						<li><b>title</b> (<i>optional arg</i>): Title of the WMS Service.</li>
						<li><b>abstract</b> (<i>optional arg</i>): Abstract of the WMS Service.</li>
						<li><b>version</b>: version of the WMS protocol to be used for <i>GetMap</i> requests (e.g. <b>'1.1.1'</b> or <b>'1.3.0'</b>).</li>
						<li><b>ref_sys</b>: reference system to be used for <i>GetMap</i> requests (e.g. <b>'EPSG:4326'</b> or <b>'EPSG:32632'</b>).</li>
						<li><b>image_format</b>: MIME type of the image returned by a <i>WMS GetMap</i> request (e.g. <b>'image/png'</b> or <b>'image/jpeg'</b>).</li>
						<li><b>style</b>: name of the style to be applied to the <i>WMS Layer</i> (could be <b>'default'</b>).</li>
						<li><b>is_transparent</b>: if the image returned by a <i>WMS GetMap</i> request should be opaque or transparent.</li>
						<li><b>flip_axes</b>: if a <i>WMS GetMap</i> request requires flipping the horizontal and vertical axes.</li>
						<li><b>is_tiled</b> (<i>optional arg</i>): if <i>WMS GetMap</i> requests should be handled <i>by tiles</i> or not.</li>
						<li><b>is_cached</b> (<i>optional arg</i>): if <i>WMS GetMap</i> results should be cached or not (applies only to <i>tiled</i> requests).</li>
						<li><b>tile_width</b> (<i>optional arg</i>): tile width expressed in <i>pixels</i> (applies only to <i>tiled</i> requests).</li>
						<li><b>tile_height</b> (<i>optional arg</i>): tile height expressed in <i>pixels</i> (applies only to <i>tiled</i> requests).</li>
						<li><b>bgcolor</b> (<i>optional arg</i>): image background color (<i>Hex RGB color</i> as e.g. <b>'ff8000'</b> or <b>'A8A8A8'</b>).</li>
						<li><b>is_queriable</b> (<i>optional arg</i>): if the <i>WMS Layer</i> supports or not <i>GetFeatureInfo</i> requests.</li>
						<li><b>getfeatureinfo_url</b> (<i>optional arg</i>): base URL corresponding to a <i>WMS GetFeatureInfo</i> request.</li>
					</ul><hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_UnRegisterGetMap</b></td>
				<td>WMS_UnRegisterGetMap( getmap_url <i>Text</i> , layer_name <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Unregisters a WMS Layer (and all related children).<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_SetGetMapInfos</b></td>
				<td>WMS_SetGetMapInfos( getmap_url <i>Text</i> , layer_name <i>Text</i> , title <i>Text</i> , abstract <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Sets or updates the <b>Title</b> and <b>Abstract</b> for the WMS Layer identified by <b>getmap_url</b> and <b>layer_name</b>.<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_SetGetMapCopyright</b></td>
					<td>WMS_SetGetMapCopyright( getmap_url <i>Text</i> , layer_name <i>String</i> , copyright <i>String</i> ) : <i>Integer</i><hr>
						WMS_SetGetMapCopyright( getmap_url <i>Text</i> , layer_name <i>String</i> , copyright <i>String</i> , license <i>String</i> ): <i>Integer</i></td>
					<td colspan="3">Updates Copyright and License infos associated to a <b>WMS Layer</b>.
					<ul>
						<li><b>getmap_url</b> and <b>layer_name</b> must identify an existing WMS Layer.</li>
						<li><b>copyright</b> identifies the Copyright holder; if <b>NULL</b> the current value will be preserved.</li>
						<li>the optional argument <b>license</b> must reference one the Data Licenses registered into the <b>data_licenses</b> table, as e.g. <i>CC0 1.0</i> or <i>CC BY 4.0</i>.</li>
					</ul><hr>
						the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be returned on invalid arguments.</td></tr>
			<tr><td><b>WMS_SetGetMapOptions</b></td>
				<td>WMS_SetGetMapOptions( getmap_url <i>Text</i> , layer_name <i>Text</i> , transparent <i>Boolean</i> , flip_axes <i>Boolean</i> )<hr>
				    WMS_SetGetMapOptions( getmap_url <i>Text</i> , layer_name <i>Text</i> , is_tiled <i>Boolean</i> , cached <i>Boolean</i> , tile_width <i>Integer</i> , tile_height <i>Integer</i>) : <i>Integer</i><hr>
				    WMS_SetGetMapOptions( getmap_url <i>Text</i> , layer_name <i>Text</i> , is_queryable <i>Boolean</i> , getfeatureinfo_url <i>Text</i> ) : <i>Integer</i><hr>
				    WMS_SetGetMapOptions( getmap_url <i>Text</i> , layer_name <i>Text</i> , bgcolor <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Sets or updates configurable options for the WMS Layer identified by <b>getmap_url</b> and <b>layer_name</b>.<br>
				    Please check <b>WMS_RegisterGetMap</b> for more informations about supported options.<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_RegisterSetting</b></td>
				<td>WMS_RegisterSetting( getmap_url <i>Text</i> , layer_name <i>Text</i> , key <i>Text</i> , value <i>Text</i> ) : <i>Integer</i><hr>
				    WMS_RegisterSetting( getmap_url <i>Text</i> , layer_name <i>Text</i> , key <i>Text</i> , value <i>Text</i> , is_default <i>Boolean</i> ) : <i>Integer</i></td>
				<td colspan="3">Registers an alternative setting for the WMS Layer identified by <b>getmap_url</b> and <b>layer_name</b>.
					<ul>
						<li><b>key</b>: identifies a specific multi-value setting, and should be one between <b>version</b>, <b>format</b> or <b>style</b>.</li>
						<li><b>value</b>: an alternative setting value. Examples:
							<ul>
								<li><i>key</i> = <b>'version'</b> , <i>value</i> = '<b>'1.0.0'</b></li>
								<li><i>key</i> = <b>'version'</b> , <i>value</i> = '<b>'1.1.0'</b></li>
								<li><i>key</i> = <b>'version'</b> , <i>value</i> = '<b>'1.1.1'</b></li>
								<li><i>key</i> = <b>'version'</b> , <i>value</i> = '<b>'1.3.0'</b></li>
							</ul>
						</li>
						<li><b>is_default</b> (<i>optional arg</i>): if the corresponding value will become the standard setting for the corresponding WMS Layer (<b>FALSE</b> if undefined).</li>
					</ul><hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_UnRegisterSetting</b></td>
				<td>WMS_UnRegisterSetting( getmap_url <i>Text</i> , layer_name <i>Text</i> , key <i>Text</i> , value <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Unregisters an alternative setting from the corresponding WMS Layer.<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_DefaultSetting</b></td>
				<td>WMS_DefaultSetting( getmap_url <i>Text</i> , layer_name <i>Text</i> , key <i>Text</i> , value <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Makes an alternative setting to become the standard setting for the corresponding WMS Layer.<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_RegisterRefSys</b></td>
				<td>WMS_RegisterRefSys( getmap_url <i>Text</i> , layer_name <i>Text</i> , ref_sys <i>Text</i> , minx <i>Double</i> , miny <i>Double</i> ,
				    maxx <i>Double</i> , maxy <i>Double</i> ) : <i>Integer</i><hr>
				    WMS_RegisterRefSys( getmap_url <i>Text</i> , layer_name <i>Text</i> , ref_sys <i>Text</i> , minx <i>Double</i> , miny <i>Double</i> ,
				    maxx <i>Double</i> , maxy <i>Double</i> , is_default <i>Boolean</i> ) : <i>Integer</i></td>
				<td colspan="3">Registers an alternative Reference System for the WMS Layer identified by <b>getmap_url</b> and <b>layer_name</b>
					<ul>
						<li><b>ref_sys</b>: name of Reference System (e.g. <b>'EPSG:4326'</b> or <b>'EPSG:32632'</b>).</li>
						<li><b>minx</b>, <b>miny</b>, <b>maxx</b> and <b>maxy</b>: the corresponding WMS Layer's Bounding Box (aka full extent).</li>
						<li><b>is_default</b> (<i>optional arg</i>): if the corresponding SRS will become the standard Reference System for the corresponding WMS Layer (<b>FALSE</b> if undefined).</li>
					</ul><hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_UnRegisterRefSys</b></td>
				<td>WMS_UnRegisterRefSys( getmap_url <i>Text</i> , layer_name <i>Text</i> , ref_sys <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Unregisters an alternative Reference System from the corresponding WMS Layer.<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_DefaultRefSys</b></td>
				<td>WMS_DefaultRefSys( getmap_url <i>Text</i> , layer_name <i>Text</i> , ref_sys <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Makes an alternative SRS to become the standard Reference System for the corresponding WMS Layer.<hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>WMS_GetMapRequestURL</b></td>
				<td>WMS_GetMapRequestURL( getmap_url <i>Text</i> , layer_name <i>Text</i> , width <i>Integer</i> , height <i>Integer</i> , minx <i>Double</i> , miny <i>Double</i> ,
				    maxx <i>Double</i> , maxy <i>Double</i> ) : <i>Text</i></td>
				<td colspan="3">Creates a <b>WMS GetMap</b> request URL for the WMS Layer identified by <b>getmap_url</b> and <b>layer_name</b> by applying the currently set options.
				    <ul>
						<li><b>width</b> and <b>height</b>: horizontal and vertical dimensions (expressed in pixels) of the returned map image.</li>
						<li><b>minx</b>, <b>miny</b>, <b>maxx</b> and <b>maxy</b>: the Bounding Box coverred by the returned map image.</li>
				    </ul><hr>
					Will return a <b>request URL</b> on success; <b>NULL</b> on failure or on invalid arguments.</td></tr>
			<tr><td><b>WMS_GetFeatureInfoRequestURL</b></td>
				<td>WMS_GetFeatureInfoRequestURL( getmap_url <i>Text</i> , layer_name <i>Text</i> , width <i>Integer</i> , height <i>Integer</i> , x <i>Integer</i>, y <i>Integer</i> ,
					minx <i>Double</i> , miny <i>Double</i> , maxx <i>Double</i> , maxy <i>Double</i> ) : <i>Text</i><hr>
					WMS_GetFeatureInfoRequestURL( getmap_url <i>Text</i> , layer_name <i>Text</i> , width <i>Integer</i> , height <i>Integer</i> , x <i>Integer</i>, y <i>Integer</i> ,
					minx <i>Double</i> , miny <i>Double</i> , maxx <i>Double</i> , maxy <i>Double</i> , feature_count <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Creates a <b>WMS GetFeatureInfo</b> request URL for the WMS Layer identified by <b>getmap_url</b> and <b>layer_name</b> by applying the currently set options.
				    <ul>
						<li><b>width</b> and <b>height</b>: horizontal and vertical dimensions (expressed in pixels) of the map image.</li>
						<li><b>x</b> and <b>y</b>: position of a Point on the map image to be queried: the map image coordidate origin <i>(0, 0)</i> is located on the
						<i>upper left corner</i>, the X axis increases going towards the right, the Y axis increases going towards the bottom. </li>
						<li><b>minx</b>, <b>miny</b>, <b>maxx</b> and <b>maxy</b>: the Bounding Box coverred by the map image.</li>
						<li><b>feature_count</b> (<i>optional arg</i>): maximum number of features allowed (<i>1</i> if unspecified).</li>
				    </ul><hr>
					Will return a <b>request URL</b> on success; <b>NULL</b> on failure or on invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="datalic">SQL functions supporting Data Licenses</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0" colspan="3">Summary</th></tr>
			<tr><td><b>RegisterDataLicense</b></td>
				<td>RegisterDataLicense( license_name <b>Text</b> ) : <i>Integer</i><hr>
					RegisterDataLicense( license_name <b>Text</b> , url <b>Text</b> ) : <i>Integer</i></td>
				<td colspan="3">Registers a Data License.
				<ul>
					<li><b>license_name</b> is expected to be a text string uniquely identifying a license/version.<br>
					<u>Note</u>: the following licenses are always self-defined when creating a new DB:
						<ul>
							<li><i>Undefined</i></li>
							<li><i>Proprietary - Non Free</i></li>
							<li><i>PD - Public Domain</i></li>
							<li><i>CC0 1.0</i></li>
							<li><i>CC BY 3.0</i></li>
							<li><i>CC BY 4.0</i></li>
							<li><i>CC BY-SA 3.0</i></li>
							<li><i>CC BY-SA 4.0</i></li>
							<li><i>CC BY-SA-NC 3.0</i></li>
							<li><i>CC BY-SA-NC 4.0</i></li>
						</ul>
					</li>
					<li>the optional argument <b>url</b> may eventually contain an URL pointing to the license's legal terms and conditions.</li>
				</ul><hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>UnRegisterDataLicense</b></td>
				<td>UnRegisterDataLicense( license_name <b>Text</b> ) : <i>Integer</i></td>
				<td colspan="3">Unregisters a Data License.
				<ul>
					<li><b>license_name</b> is expected to match an already registered license/version.</li>
				</ul><hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid argument.</td></tr>
			<tr><td><b>RenameDataLicense</b></td>
				<td>RenameDataLicense( old_name <b>Text</b> , new_name <b>Text</b> ) : <i>Integer</i></td>
				<td colspan="3">Renames a Data License.
				<ul>
					<li><b>old_name</b> is expected to match an already registered license/version.</li>
					<li><b>new_name</b> must not match any already registered license/version so to respect the unique constraint.</li>
				</ul><hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td><b>SetDataLicenseUrl</b></td>
				<td>SetDataLicenseURL( license_name <b>Text</b> , url <b>Text</b> ) : <i>Integer</i></td>
				<td colspan="3">Sets or updates the URL corresponding to a Data License.
				<ul>
					<li><b>license_name</b> is expected to match an already registered license/version.</li>
					<li><b>url</b> is expected to be an URL pointing to the license's legal terms and conditions.</li>
				</ul><hr>
					Will return <b>1</b> on success; <b>0</b> on failure; <b>-1</b> on invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="advanced">miscellaneous advanced SQL functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0" colspan="3">Summary</th></tr>
			<tr><td><b>CloneTable</b></td>
				<td>CloneTable( db-prefix <i>Text</i> , input_table <i>Text</i> , output_table <i>Text</i> , 
				transaction <i>Integer</i> ) : <i>Integer</i><hr>
				CloneTable(  db-prefix <i>Text</i> , input_table <i>Text</i> , output_table <i>Text</i> , 
				transaction <i>Integer</i> , option_1 <i>Text</i> [ , ... , option_10 <i>Text</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will clone (i.e. create+copy) an origin table into a destination table: 
				the origin could be eventually located into some <i>attached</i> DB, but the destination is always
				assumed to be located into the primary DB.<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>db-prefix</b> corresponding to the origin; the primary DB always corresponds to the <i>main</i> prefix.<br>
					    Can be legitimately set to <b>NULL</b>, and in this case <b>MAIN</b> will be implicitly assumed.</b></b></li>
					<li><b>input_table</b> name of the origin table</li>
					<li><b>output_table</b> name of the destination table</li>
					<li><b>transaction</b> a <i>boolean</i> values stating if the whole operation has to be atomically confined
					within a monolithic SQL transaction</li>
				</ul></li>
				<li>Optional arguments: a maximum of 10 further options could be eventually be specified. Valid options are:
				<ul>
					<li><b>::with-foreign-keys::</b></li>
					<li><b>::with-triggers::</b></li>
					<li><b>::resequence::</b></li>
					<li><b>::append::</b></li>
					<li><b>::ignore::</b><i>column_name</i></li>
					<li><b>::cast2multi::</b><i>geometry_column</i></li>
				</ul></li>
				</ul>
				<hr>
				Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success. <b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>CreateClonedTable</b></td>
				<td>CreateClonedTable( db-prefix <i>Text</i> , input_table <i>Text</i> , output_table <i>Text</i> , 
				transaction <i>Integer</i> ) : <i>Integer</i><hr>
				CreateClonedTable(  db-prefix <i>Text</i> , input_table <i>Text</i> , output_table <i>Text</i> , 
				transaction <i>Integer</i> , option_1 <i>Text</i> [ , ... , option_10 <i>Text</i> ] ) : <i>Integer</i></td>
				<td colspan="3">A strict derivative of <b>CloneTable()</b> accepting the same arguments with identical meaning.<br>
				The only difference is in that this second variant will just create the output Table completely avoiding to copy any row betweem the two tables. 
				<hr>
				Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success. <b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>CheckDuplicateRows</b></td>
				<td>CheckDuplicateRows( table <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Will check if the given <b>table</b> does contain duplicate rows, i.e. rows presenting identical 
				values for all columns (ignoring any Primary Key column).
				<hr>
				Will return the total number of duplicate rows found.<br> <b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>RemoveDuplicateRows</b></td>
				<td>RemoveDuplicateRows( table <i>Text</i> ) : <i>Integer</i><hr>
				RemoveDuplicateRows( table <i>Text</i> , transaction <i>Boolean</i> ) : <i>Integer</i></td>
				<td colspan="3">Will remove all duplicate rows from the given <b>table</b> preserving only a single occurrence.<br>
				The <i>optional</i> argument <b>transaction</b> determines if an internal SQL Transaction should be automatically
				started or not (the default setting if not explicitly overridden is <b>TRUE</b>).
				<hr>
				Will return the total number of deleted rows.<br> <b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>ElementaryGeometries</b></td>
				<td>ElementaryGeometries( in_table <i>Text</i> , geom_column <i>Text</i> , out_table <i>Text</i> ,
				out_pk <i>Text</i> , out_multi_id <i>Text</i> ) : <i>Integer</i><hr>
				ElementaryGeometries( in_table <i>Text</i> , geom_column <i>Text</i> , out_table <i>Text</i> ,
				out_pk <i>Text</i> , out_multi_id <i>Text</i> , transaction <i>Boolean</i> ) : <i>Integer</i><hr>
				ElementaryGeometries( in_table <i>Text</i> , geom_column <i>Text</i> , out_table <i>Text</i> ,
				out_pk <i>Text</i> , out_multi_id <i>Text</i> , transaction <i>Boolean</i> , 
				option_1 <i>Text</i> [ , ... , option_10 <i>Text</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will create a new <b>out_table</b> directly corresponding to <b>in_table</b>.
				The output table will be arranged in such a way that each row will always contain an elementary Geometry;
				so each time that a <b>MULTI-type</b> Geometry is found in the input table it will be split into many
				distinct rows.
				<ul>
					<li><b>out_pk</b> is the name to be set for the output Primary Key, and <b>out_multi_id</b> is the name to be set for a second column within the output table 
						where to store the a zero-based index from which Geometry the Element-Geometry comes from, that together with the original Primary Key can be identified.<br>
						<u>Note</u>: both <i>out_pk</i> and <i>out_multi_id</i> must not exist in the given <i>in_table</i> table.</li>
					<li>The <i>optional</i> argument <b>transaction</b> determines if an internal SQL Transaction should be automatically
						started or not (the default setting if not explicitly overridden is <b>TRUE</b>).</li>
				</ul>
				Optional arguments: a maximum of 10 further options could be eventually be specified. Valid options are:
				<ul>
					<li><b>::ignore::</b><i>column_name</i><br>
					<u>Note</u>: the <b>geom-column</b> will never be ignored, even if explicitly requested to be.</li>
					<li><b>::cast2multi::</b><br>
					Will automatically apply a <b>CastToMulti ( geom_column )</b> directive.</li>
					<li>All references to mismatching options or not existinting columns will be silently discarded.</li>
				</ul>
				<hr>
				Will return the total number of rows inserted into the output table.<br> <b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>DropGeoTable</b></td>
				<td>DropGeoTable( table <i>Text</i> ) : <i>Integer</i><hr>
				DropGeoTable( table <i>Text</i> , transaction <i>Boolean</i> ) : <i>Integer</i><hr>
				DropGeoTable( db-prefix <i>Text</i> , table <i>Text</i> ) : <i>Integer</i><hr>
				DropGeoTable( db-prefix <i>Text</i> , table <i>Text</i> , transaction <i>Boolean</i> ) : <i>Integer</i></td>
				<td colspan="3">Will completely remove a Geometry Table (or Spatial View) this including any eventual SpatialIndex,
				metadata and statistics definitions an alike.<br>
				The <i>optional</i> argument <b>transaction</b> determines if an internal SQL Transaction should be automatically
				started or not (the default setting if not explicitly overridden is <b>TRUE</b>).
				<hr>
				Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success..<br> 
				<b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>ImportSHP</b></td>
				<td>ImportSHP( filename <i>Text</i> , table <i>Text</i> , charset <i>Text</i> ) : <i>Integer</i><hr>
				ImportSHP( filename <i>Text</i> , table <i>Text</i> , charset <i>Text</i> [ , srid <i>Integer</i>  [ ,
				    geom_column <i>Text</i> [ , pk_column <i>Text</i> [ , geometry_type <i>Text</i> [ , coerce2D <i>Integer</i> 
				    [ , compressed <i>Integer</i> [ , spatial_index <i>Integer</i> [ , text_dates <i>Integer</i> 
				    [ , colname_case <i>Text</i> [ , update_statistics <i>Integer</i> [ , verbose <i>Integer</i> ] ] ] ] ] ] ] ] ] ] ] )
				    : <i>Integer</i></td>
				<td colspan="3">Will import an external Shapfile into an internal Table:
				<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>filename</b> absolute or relative path leading to the Shapefile (omitting any <i>.shp</i>, <i>.shx</i> or <i>.dbf</i> suffix).</li>
					<li><b>table</b> name of the table to be created.</li>
					<li><b>charset</b> the character encoding adopted by the DBF member, as e.g. <i>UTF-8</i> or <i>CP1252</i></li>
				</ul></li>
				<li>Optional arguments:
				<ul>
					<li><b>srid</b> EPSG SRID value; <i>-1</i> by default.</li>
					<li><b>geom_column</b> name to assigned to the Geometry column; <i>Geometry</i> by default.</li>
					<li><b>pk_column</b> name of a DBF column to be used in the Primary Key role; an <i>INTEGER AUTOINCREMENT</i> 
					PK will be created by default.</li>
					<li><b>geometry_type</b> one between: <i>AUTO</i>, <i>POINT|Z|M|ZM</i>, <i>LINESTRING|Z|M|ZM</i>,
						<i>POLYGON|Z|M|ZM</i>, <i>MULTIPOINT|Z|M|ZM</i>, <i>LINESTRING|Z|M|ZM</i>, <i>MULTIPOLYGON|Z|M|ZM</i>;
						 by default <i>AUTO</i>.</li>
					<li><b>coerce2D</b> boolean flag: casting to 2D or not; <i>0</i> by default.</li>
					<li><b>compressed</b> boolean flag; compressed geometries or not; <i>0</i> by default.</li>
					<li><b>spatial_index</b> boolean flag: immediately building a Spatial Index or not; <i>0</i> by default.</li>
					<li><b>text_dates</b> boolean flag: interpreting DBF dates as plaintext or not: <i>0</i> by default
					(i.e. as <i>Julian Day</i>).</li>
					<li><b>colname_case</b> one between:<ul>
						<li><i>LOWER</i> or <i>LOWERCASE</i>: all column names will be converted to lowercase (default option).</li>
						<li><i>UPPER</i> or <i>UPPERCASE</i>: all column names will be converted to uppercase.</li>
						<li><i>SAME</i> or <i>SAMECASE</i>: all column names will be left as they are.</li>
					</ul></li>
					<li><b>update_statistics</b> boolean flag: immediately updating Layer Statustics or not; <i>1</i> by default.</li>
					<li><b>verbose</b> boolean flag: verbose console output: <i>1</i> by default, you can explicitly pass <i>0</i>
					if you better whish a silent output.
				</ul></li>
				</ul>
				<hr>
				Will return the total number of imported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ExportSHP</b></td>
				<td>ExportSHP( table <i>Text</i> , geom_column <i>Text</i> , filename <i>Text</i> , charset <i>Text</i> ) : <i>Integer</i><hr>
				ExportSHP( table <i>Text</i> , geom_column <i>Text</i> , filename <i>Text</i> , charset <i>Text</i> , [ geom_type <i>Text</i>
				[ , colname_case <i>Text</i> ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will export an internal Table as an external Shapefile:
				<ul>
					<li><b>table</b> name of the table to be exported.</li>
					<li><b>geom_column</b> name of the Geometry column.</li>
					<li><b>filename</b> absolute or relative path leading to the Shapefile (omitting any <i>.shp</i>, <i>.shx</i> or <i>.dbf</i> suffix).</li>
					<li><b>charset</b> the character encoding adopted by the DBF member, as e.g. <i>UTF-8</i> or <i>CP1252</i></li>
					<li>the optional argument <b>geom_type</b> is useful when exporting unregistered Geometries, and
					can be one between: <i>POINT</i>, <i>LINESTRING</i>, <i>POLYGON</i> or <i>MULTIPOINT</i>.</li>
					<li><b>colname_case</b> (optional argument) can be one between:<ul>
						<li><i>LOWER</i> or <i>LOWERCASE</i>: all column names will be converted to lowercase (default option).</li>
						<li><i>UPPER</i> or <i>UPPERCASE</i>: all column names will be converted to uppercase.</li>
						<li><i>SAME</i> or <i>SAMECASE</i>: all column names will be left as they are.</li>
					</ul></li>
				</ul>
				<hr>
				Will return the total number of exported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportDBF</b></td>
				<td>ImportDBF( filename <i>Text</i> , table <i>Text</i> , charset <i>Text</i> ) : <i>Integer</i><hr>
				ImportDBF( filename <i>Text</i> , table <i>Text</i> , charset <i>Text</i> [ , pk_column <i>Text</i>  
				    [ , text_dates <i>Integer</i> [ , colname_case <i>Text</i> ] ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will import an external DBF file into an internal Table:
				<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>filename</b> absolute or relative path leading to the DBF (including the <i>.dbf</i> suffix).</li>
					<li><b>table</b> name of the table to be created.</li>
					<li><b>charset</b> the character encoding adopted by the DBF, as e.g. <i>UTF-8</i> or <i>CP1252</i></li>
				</ul></li>
				<li>Optional arguments:
				<ul>
					<li><b>pk_column</b> name of a DBF column to be used in the Primary Key role; an <i>INTEGER AUTOINCREMENT</i> 
					PK will be created by default.</li>
					<li><b>text_dates</b> boolean flag: interpreting DBF dates as plaintext or not: <i>0</i> by default
					(i.e. as <i>Julian Day</i>).</li>
					<li><b>colname_case</b> one between:<ul>
						<li><i>LOWER</i> or <i>LOWERCASE</i>: all column names will be converted to lowercase (default option).</li>
						<li><i>UPPER</i> or <i>UPPERCASE</i>: all column names will be converted to uppercase.</li>
						<li><i>SAME</i> or <i>SAMECASE</i>: all column names will be left as they are.</li>
					</ul></li>
				</ul></li>
				</ul>
				<hr>
				Will return the total number of imported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ExportDBF</b></td>
				<td>ExportDBF( table <i>Text</i> , filename <i>Text</i> , charset <i>Text</i> [ , colname_case <i>Text</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will export an internal Table as an external DBF file:
				<ul>
					<li><b>table</b> name of the table to be exported.</li>
					<li><b>filename</b> absolute or relative path leading to the DBF (including the <i>.dbf</i> suffix).</li>
					<li><b>charset</b> the character encoding adopted by the DBF, as e.g. <i>UTF-8</i> or <i>CP1252</i></li>
					<li><b>colname_case</b> (optional argument) can be one between:<ul>
						<li><i>LOWER</i> or <i>LOWERCASE</i>: all column names will be converted to lowercase (default option).</li>
						<li><i>UPPER</i> or <i>UPPERCASE</i>: all column names will be converted to uppercase.</li>
						<li><i>SAME</i> or <i>SAMECASE</i>: all column names will be left as they are.</li>
					</ul></li>
				</ul>
				<hr>
				Will return the total number of exported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ExportKML</b></td>
				<td>ExportKML( table <i>Text</i> , geo_column <i>Text</i> , filename <i>Text</i> ) : <i>Integer</i><hr>
				ExportKML( table <i>Text</i> , geo_column <i>Text</i> , filename <i>Text</i> [ , precision <i>Integer</i>
				[ , name_column <i>Text</i> [ , description <i>Text</i> ] ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will export an internal Table as an external KML file:
				<ul>
					<li>Mandatory aguments:
					<ul>
						<li><b>table</b> name of the table to be exported.</li>
						<li><b>geom_column</b> name of the Geometry column.</li>
						<li><b>filename</b> absolute or relative path leading to the KML file.</li>
					</ul></li>
					<li>Optional aguments:
					<ul>
						<li><b>precision</b> number of decimal digits to be exported; <i>8</i> by default.</li>
						<li><b>name_column</b> name of the table's column containing KML names.</li>
						<li><b>description_column</b> name of the table's column containing KML descriptions.</li>
					</ul></li>
				</ul>
				<hr>
				Will return the total number of exported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ExportGeoJSON</b></td>
				<td>ExportGeoJSON( table <i>Text</i> , geo_column <i>Text</i> , filename <i>Text</i> ) : <i>Integer</i><hr>
				ExportGeoJSON( table <i>Text</i> , geo_column <i>Text</i> , filename <i>Text</i> [ , format <i>Text</i>
				[ , precision <i>Integer</i> ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will export an internal Table as an external GeoJSON file:
				<ul>
					<li>Mandatory aguments:
					<ul>
						<li><b>table</b> name of the table to be exported.</li>
						<li><b>geom_column</b> name of the Geometry column.</li>
						<li><b>filename</b> absolute or relative path leading to the GeoJSON file.</li>
					</ul></li>
					<li>Optional aguments:
					<ul>
						<li><b>format</b> specifies one of the several alternative GeoJSON formats; allowed values are
						<i>none</i>, <i>MBR</i>, <i>withShortCRS</i>, <i>MBRwithShortCRS</i>, <i>withLongCRS</i>
						or <i>MBRwithLongCRS</i>.</li>
						<li><b>precision</b> number of decimal digits to be exported; <i>8</i> by default.</li>
					</ul></li>
				</ul>
				<hr>
				Will return the total number of exported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportXLS</b></td>
				<td>ImportXLS( filename <i>Text</i> , table <i>Text</i> ) : <i>Integer</i><hr>
				ImportXLS( filename <i>Text</i> , table <i>Text</i> [ , worksheet_index <i>Integer</i>  
				    [ , first_line_titles <i>Integer</i> ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will import an external spreadsheet file (<i>Microsoft .xls format</i>) into an internal Table:
				<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>filename</b> absolute or relative path leading to the spreadsheet file.</li>
					<li><b>table</b> name of the table to be created.</li>
				</ul></li>
				<li>Optional arguments:
				<ul>
					<li><b>worksheet_index</b> a positive integer selecting the target worksheet in the case of a multi-sheet: <i>0</i> by default..</li>
					<li><b>first_line_titles</b> boolean flag: the first line of the worksheet contains column names or not: <i>0</i> by default.</li>
				</ul></li>
				</ul>
				<hr>
				Will return the total number of imported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportWFS</b></td>
				<td>ImportWFS( filename_or_url <i>Text</i> , layer_name <i>Text</i> , table <i>Text</i> ) : <i>Integer</i><hr>
				ImportWFS( filename_or_url <i>Text</i> , layer_name <i>Text</i> , table <i>Text</i> [ , pk_column <i>Text</i>  
				    [ , swap_axes <i>Integer</i> [ , page_size <i>Integer</i> [ , spatial_index <i>Integer</i> ] ] ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will import data from a WFS datasource:
				<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>filename_or_url</b> absolute or relative path leading to the WFS file.<br>
					Alternatively an URL corresponding to a WFS service.</li>
					<li><b>layer_name</b> name of the WFS layer.</li>
					<li><b>table</b> name of the table to be created.</li>
				</ul></li>
				<li>Optional arguments:
				<ul>
					<li><b>pk_column</b> name of a WFS column to be used in the Primary Key role; an <i>INTEGER AUTOINCREMENT</i> 
					PK will be created by default.</li>
					<li><b>swap_axes</b> boolean flag: swapping the <i>X</i> and <i>Y</i> axes or not: <i>0</i> by default.</li>
					<li><b>page_size</b> : how many features for each WFS paged requests; a <i>negative</i> number or <i>zero</i> if
					you don't intend to activate WFS paging. <i>-1</i> by default.</li>
					<li><b>spatial_index</b> boolean flag: immediately building a Spatial Index or not; <i>0</i> by default.</li>
				</ul></li>
				</ul>
				<hr>
				Will return the total number of imported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportDXF</b></td>
				<td>ImportDXF( filename <i>String</i> ) : <i>Integer</i><hr>
					ImportDXF( filename <i>String</i> [ , srid <i>Integer</i>, append <i>Integer</i>, dimensions <i>Text</i>,
					mode <i>Text</i> , special_rings <i>Text</i> , table_prefix <i>Text</i> , layer_name <i>Text</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will import an external DXF file.<ul>
                    <li><b>filename</b> absolute or relative path leading to the DXF file.</li>
					<li><b>srid</b> EPSG SRID value; <i>-1</i> by default.</li>
					<li><b>append</b> boolean flag: enabling or not <i>append mode</i>: <i>0</i> by default.</li>
					<li><b>dimensions</b> one between <i>AUTO</i>, <i>2D</i> or <i>3D</i>.</li>
					<li><b>mode</b> one between <i>DISTINCT</i> or <i>MIXED</i>.</li>
					<li><b>special_rings</b> one between <i>NONE</i>, <i>LINKED</i> or <i>UNLINKED</i>.</li>
					<li><b>table_prefix</b>: a prefix for table names; <i>NULL</i> if no prefix is required.</li>
					<li><b>layer_name</b>: name of a single DXF layer to be imported: <i>NULL</i> will import all layers found.</li>
					</ul>
					Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportDXFfromDir</b></td>
				<td>ImportDXFfromDir( dir_path <i>String</i> ) : <i>Integer</i><hr>
					ImportDXFfromDir( dir_path <i>String</i> [ , srid <i>Integer</i>, append <i>Integer</i>, dimensions <i>Text</i>,
					mode <i>Text</i> , special_rings <i>Text</i> , table_prefix <i>Text</i> , layer_name <i>Text</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will import all DXF files found within a given Directory.<ul>
                    <li><b>dir_path</b> absolute or relative path leading to a directory containing all the <i>*.dxf</i> files to be imported.</li>
					<li><b>srid</b> EPSG SRID value; <i>-1</i> by default.</li>
					<li><b>append</b> boolean flag: enabling or not <i>append mode</i>: <i>0</i> by default.</li>
					<li><b>dimensions</b> one between <i>AUTO</i>, <i>2D</i> or <i>3D</i>.</li>
					<li><b>mode</b> one between <i>DISTINCT</i> or <i>MIXED</i>.</li>
					<li><b>special_rings</b> one between <i>NONE</i>, <i>LINKED</i> or <i>UNLINKED</i>.</li>
					<li><b>table_prefix</b>: a prefix for table names; <i>NULL</i> if no prefix is required.</li>
					<li><b>layer_name</b>: name of a single DXF layer to be imported: <i>NULL</i> will import all layers found.</li>
					</ul>
					Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>		
			<tr><td><b>ExportDXF</b></td>
				<td>ExportDXF( out_dir <i>String</i> , filename <i>String</i> , sql_query <i>String</i> , layer_col_name <i>String</i> , 
                geom_col_name <i>String</i> , label_col_name <i>String</i> , text_height_col_name <i>String</i> , 
                text_rotation_col_name <i>String</i> , geom_filter <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will export a whole DXF file.<ul>
                    <li>The output file path is controlled by <b>out_dir</b> and <b>filename</b>.</li>
					<li><b>sql_query</b> is a complete SQL Statement returning the dataset to be exported.</li>
					<li><b>layer_col_name</b>, <b>geom_col_name</b>, <b>label_col_name</b>, <b>text_height_col_name</b> 
					and <b>text_rotation_col_name</b> must specify the corresponding <u>column names</u> within the resultset
					returned by <b>sql_query</b> (<i>label_col_name</i>, <i>text_height_col_name</i> and <i>text_rotation_col_name</i> could be eventually <b>NULL</b>).</li>
					<li><b>geom_filter</b> acts as a <u>spatial filter</u> selecting which entities have to be exported (could be <b>NULL</b>).</li>
					<li>the optional argument <b>precision</b> specificies how many <u>decimal digits</u> are required for coordinate values: if not specified the default is <b>3</b>.</li>
					</ul>
					Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success.<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>		
			<tr><td><b>ST_Cutter()</b></td>
				<td>ST_Cutter( input-db-prefix <i>String</i> , input-table <i>String</i> , input-geometry <i>String</i> , blade-db-prefix <i>String</i> ,
				    blade-table <i>String</i> , blade-geom <i>String</i> , output-table <i>String</i>
				    [ , transaction <i>Boolean</i> [ , ram-temp-storage <i>Boolean</i> ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will precisely cut in a topological consistent way a whole <b>Input dataset</b> using a <b>Blade dataset</b> (i.e. an arbitrary <i>polygonal</i> dataset).<br>
				    All cut fragments will be stored into a further <b>Output dataset</b>, and all <i>mother-child relationships</i> will be fully preserved by saving the <i>Primary Key values</i> allowing
				    to trace back <i>Input</i> and <i>Blade</i> pairs giving birth to each single fragment.<br>
				    Any cut fragment stored into the <i>Output dataset</i> eventually falling outside any Blade will reference a conventional <b>NULL</b> Blade.
				    <ul>
                    <li>The <i>Input</i> dataset is always expected to declare a <b>Primary Key</b> and must declare a <i>POINT</i>, <i>LINESTRING</i>, <i>POLYGON</i>,
                    <i>MULTIPOINT</i>, <i>MULTILINESTRING</i> or <i>MULTIPOLYGON</i> Geometry type.<br>
                    It can be located either in the <b>MAIN</b> database or in any other <b>attached DB</b>, and must be fully identified by the <b>input-db-prefix</b>, 
                    <b>input-table</b> and <b>input-geometry</b> arguments.</li>
                    <li>The <i>Blade</i> dataset is always expected to be a <i>POLYGON</i> or <i>MULTIPOLYGON</i>, with a defined <b>Primary Key</b>.<br> 
                    It can be located either in the <b>MAIN</b> database or in any other <b>attached DB</b>, and is fully identified by the <b>blade-db-prefix</b>,
                    <b>blade-table</b> and <b>blade-geometry</b> arguments.<br>
                    <u>Note</u>: both the <i>Input</i> and <i>Blade</i> Geometries must have the same identical <i>SRID</i> value.</li>
                    <li>The <i>Output</i> dataset will be always created in the <b>MAIN</b> database.<br>
                    The Output Geometry will have the same name and SRID as the <b>input-geom</b>: the Geometry type will always be one of
                    <i>POINT</i>, <i>LINESTRING</i> or <i>POLYGON</i> (all cut fragments will be stored as simple features on distinct rows).</li>
					</ul>
					<ul>
					<li>Both the <b>input-db-prefix</b> and <b>blade-db-prefix</b> arguments could be set as <b>NULL</b>, where the <b>MAIN</b> database will then always be assumed.</li>
					<li>also the <b>input-geom</b> and <b>blade-geom</b> arguments can be set as <b>NULL</b>.<br>
					In such a case the appropriate Geometry column name will be chosen when only one Geometry column is defined, otherwise an exception will be raised.</li>
					<li>The <i>optional</i> argument <b>transaction</b> determines if an internal SQL Transaction should be automatically started or not (the default setting, if not explicitly overridden, is FALSE).</li>
					<li>The <i>optional</i> argument <b>ram-tmp-storage</b> determines if the intermediate <i>temporary tables</i> internally used by this function should be created in RAM or not 
					(the default setting if not explicitly overridden is FALSE).</li>
					</ul>
					Will return <b>-1</b> on invalid arguments, <b>0</b> on failure, <b>1</b> on full success and <b>2</b> on partial success (i.e.when the output table contains
					one or more <i>invalid geometries</i>).</td></tr>			
			<tr><td><b>GetCutterMessage()</b></td>
				<td>GetCutterMessage( <i>void</i> ) : <i>String</i></td>
				<td colspan="3">Will return the most <i>recent diagnostic message</i> emitted by <b>ST_Cutter()</b>.<br>
				<b>NULL</b> will be returned if no such message currently exists.</td></tr>			
			<tr><td><b>GetShapefileExtent()</b></td>
				<td>GetShapefileExtent( virtual_table_name <i>String</i> ) : <i>Geometry</i></td>
				<td colspan="3"><b>virtual_table_name</b> is expected to identify some Table of the <b>VirtualSHP</b> type.<br>
					An Envelope Geometry will be returned corresponding to the <b>Shapefile's Full Extent</b>;
				<b>NULL</b> will be returned if any error occurs (invalid argument type or not existing VirtualTable).</td></tr>	
			<tr><td><b>CreateRouting()</b></td>
				<td>CreateRouting( routing_data_table <i>String</i> , virtual_routing_table <i>String</i> , input_table <i>String</i> , from_column <i>String</i> , to_column <i>String</i> ,
				geom_column <i>String</i> , cost_column <i>String</i> ) : <i>Boolean</i><hr>
				CreateRouting( routing_data_table <i>String</i> , virtual_routing_table <i>String</i> , input_table <i>String</i> , from_column <i>String</i> , to_column <i>String</i> ,
				geom_column <i>String</i> , cost_column <i>String</i> , road_name_column <i>String</i> , a_star_enabled <i>Boolean</i> , bidirectional <i>Boolean</i> ) : <i>Boolean</i><hr>
				CreateRouting( routing_data_table <i>String</i> , virtual_routing_table <i>String</i> , input_table <i>String</i> , from_column <i>String</i> , to_column <i>String</i> ,
				geom_column <i>String</i> , cost_column <i>String</i> , road_name_column <i>String</i> , a_star_enabled <i>Boolean</i> , bidirectional <i>Boolean</i> , oneway_from <i>String</i> , 
				oneway_to <i>String</i> ) : <i>Boolean</i><hr>
				CreateRouting( routing_data_table <i>String</i> , virtual_routing_table <i>String</i> , input_table <i>String</i> , from_column <i>String</i> , to_column <i>String</i> ,
				geom_column <i>String</i> , cost_column <i>String</i> , road_name_column <i>String</i> , a_star_enabled <i>Boolean</i> , bidirectional <i>Boolean</i> , oneway_from <i>String</i> , 
				oneway_to <i>String</i> , overwrite <i>Boolean</i> ) : <i>Boolean</i></td>
				<td colspan="3">Will attempt to create a <b>VirtualRouting Table</b> (and the corresponding <b>Routing Binary Data Table</b>) starting from a topologically correct <b>Road Network</b>.<br>
				<ul>
					<li><b>routing_data_table</b>: name of the Routing Binary Data Table to be created.</li>
					<li><b>virtual_routing_table</b>: name of the VirtualRouting Table to be created.</li>
					<li><b>input_table</b>: name of the input Table containing the Road Network.</li>
					<li><b>from_column</b>: name of the input Table column containing FromNode values.</li>
					<li><b>to_column</b>: name of the input Table column containing ToNode values.</li>
					<li><b>geom_column</b>: name of the input Table column containing Geometries.<br>
						Could be eventually <b>NULL</b> for Networks just describing relations but lacking any Spatial representation.</li>
					<li><b>cost_column</b>: name of the input Table column containing Cost values.<br>
						Could be eventually <b>NULL</b> and in this case <b>ST_Length(geom_column)</b> will be assumed to be the Cost: in the case of Networks based on some <i>Geographic Reference System</i>
						(<b>long/lat</b>, as e.g. <b>SRID=4326</b>) a precise measure of lengths expressed in <b>meters</b> will be computed by using <i>geodesic formulas</i>.</li>
					<li><b>road_name_column</b>: name of the input Table column containing Road Name values. Could be eventually <b>NULL</b>.</li>
					<li><b>a_star_enabled</b>: if the <b>A*</b> algorithm should be enabled or not (default: <b>1</b>).</li>
					<li><b>bidirectional</b>: if arcs/links should be considered uni- or bi-directionals (default: <b>0</b>).</li>
					<li><b>oneway_from</b>: name of the input Table column containing OneWay flags in the From-To direction. Could be eventually <b>NULL</b>.</li>
					<li><b>oneway_to</b>: name of the input Table column containing OneWay flags in the To-From direction. Could be eventually <b>NULL</b>.</li>
					<li><b>overwrite</b>: if set to <b>TRUE</b> already existing Routing Binary Data and/or VirtualRouting Tables will be silently overwritten (default: <b>0</b>).</li>
				</ul><hr>
				<b>1</b> (aka <b>TRUE</b>) will be returned on success, an <b>exception</b> will be raised on failure.</td></tr>
			<tr><td><b>CreateRoutingNodes()</b></td>
				<td>CreateRoutingNodes( db_prefix <i>String</i> , spatial_table <i>String</i> , geom_column <i>String</i> ,  node_from <i>String</i> , node_to <i>String</i> ) : <i>Boolean</i></td>
				<td colspan="3">Will attempt to add both <b>node_from</b> and <b>nodes_to</b> columns to the Spatial Table identified by <b>db_prefix</b>, <b>spatial_table</b> and <b>geom_column</b>.
				These two columns will be populated by inserting appropriate <b>Node-IDs</b> (of the <i>INTEGER</i> type) fully respecting the topological consistency of the network.<br>
				<ul>
					<li><b>db_prefix</b> could be <b>NULL</b>, and in this case the <b>MAIN</b> DB is implicitly assumed.</li>
					<li>also <b>geom_column</b> could be <b>NULL</b>, and in this case the name of the Geometry column will be automatically detected if the Spatial Table has just a single Geometry.</li>
					<li><b>geom_column</b> must contain Geometries of the <b>LINESTRING</b> type.</li>
					<li>both <b>node_from</b> and <b>node_to</b> columns should not exist.</li>
				</ul><hr>
				<b>1</b> (aka <b>TRUE</b>) will be returned on success, an <b>exception</b> will be raised on failure.</td></tr>				
			<tr><td><b>CreateRouting_GetLastError()</b></td>
				<td>CreateRouting_GetLastError( <i>void</i> ) : <i>String</i></td>
				<td colspan="3">Will return the most <i>recent error message</i> emitted by <b>CreateRouting()</b> or <b>CreateRoutingNodes()</b>.<br>
				<b>NULL</b> will be returned if no such error message currently exists.</td></tr>	
			<tr><td><b>IsLowASCII()</b></td>
				<td>IsLowASCII( text_string <i>String</i> ) : <i>Integer</i></td>
				<td colspan="3">Inspects an <b>UTF-8</b> encoded <b>text_string</b> testing if it only contains <b>ASCII 7-bit</b> characters.<br>
                    The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
                    and -1 for UNKNOWN when called with invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="sqlproc">SQL Procedures, Stored Procedures and Stored Variables related SQL functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0" colspan="3">Summary</th></tr>
			<tr><td><b>SqlProc_GetLastError</b></td>
				<td>SqlProc_GetLastError( <i>void</i> ) : <i>String</i></td>
				<td colspan="3">Will return the most recent error message returned by SQL Procedures and friends (if any).<hr>
				<b>NULL</b> will be returned if there is no pending SQL Procedures error.</td></tr>
			<tr><td><b>SqlProc_SetLogfile</b></td>
				<td>SqlProc_SetLogfile( filepath <i>String</i> ) : <i>Integer</i><hr>
				    SqlProc_SetLogfile( filepath <i>String</i> , append <i>Boolean</i> ) : <i>Integer</i></td>
				<td colspan="3">Will activate a SQL Logfile supporting all following calls to <b>SqlProc_Execute()</b> and <b>StoredProc_Execute()</b>.
				<ul>
					<li>The <b>filepath</b> argument is expected to be a valid relative or absolute pathname; it could be set to <b>NULL</b> so to disable SQL Logging.</li>
					<li>The optional argument <b>append</b> if set to <b>TRUE</b> requires to open the Logfile for appending; if set to <b>FALSE</b> (default setting) the Logfile will be truncated.</li>
				</ul><hr>
				<b>1</b> will be returned on success; an exception will be raised on invalid argument or if the SQL Logfile can't be succesfully opened.<hr>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>SqlProc_GetLogfile</b></td>
				<td>SqlProc_GetLogfile( <i>void</i> ) : <i>String</i></td>
				<td colspan="3">Will return the pathname of the currently set SQL Logfile.<hr>
				<b>NULL</b> will be returned if no SQL Logfile is currently set.</td></tr>
			<tr><td><b>SqlProc_FromText</b></td>
				<td>SqlProc_FromText( sql_body <i>String</i> ) : <i>BLOB</i><hr>
				    SqlProc_FromText( sql_body <i>String</i>, charset_encoding <i>String</i> ) : <i>BLOB</i></td>
				<td colspan="3">Will return a BLOB object of the Sql Procedure type encapsulating the given <b>SQL Body</b>.<br>
				If the optional second argument is explicitly specified the SQL Body will be automatically converted from the given <b>charset encoding</b> into <b>UTF-8</b>.<hr>
				<b>1</b> will be returned on success; an exception will be raised on failure or invalid arguments.</td></tr>	
			<tr><td><b>SqlProc_FromFile</b></td>
				<td>SqlProc_FromFile( filepath <i>String</i> ) : <i>BLOB</i><hr>
				    SqlProc_FromFile( filepath <i>String</i>, charset_encoding <i>String</i> ) : <i>BLOB</i></td>
				<td colspan="3">Will return a BLOB object of the Sql Procedure type encapsulating the <b>SQL Body</b> loaded from the given <b>filepath</b>.<br>
				If the optional second argument is explicitly specified the SQL Body will be automatically converted from the given <b>charset encoding</b> into <b>UTF-8</b>.<hr>
				<b>1</b> will be returned on success; an exception will be raised on failure or invalid arguments.<hr>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>	
			<tr><td><b>SqlProc_IsValid</b></td>
				<td>SqlProc_IsValid( object <i>BLOB</i> ) : <i>Boolean</i></td>
				<td colspan="3">Returns <b>TRUE</b> if the passed BLOB is valid <b>SQL Procedure</b> object, otherwise <b>FALSE</b>.<hr>
				An exception will be raised on invalid argument.</td></tr>	
			<tr><td><b>SqlProc_NumVariables</b></td>
				<td>SqlProc_NumVariables( object <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">Returns the total number of <b>Variables</b> declared by the given <b>SQL Procedure</b> object.<hr>
				An exception will be raised on failure or invalid arguments.</td></tr>		
			<tr><td><b>SqlProc_VariableN</b></td>
				<td>SqlProc_VariableN( object <i>BLOB</i> , index <i>Integer</i> ) : <i>String</i></td>
				<td colspan="3">Returns the <b>symbolic name</b> of the <b>Nth</b> Variable declared by the given <b>SQL Procedure</b> object.<br>
				The first Variable always corresponds to <b>index=0</b>, and the last one to <b>SqlProc_NumVariables() - 1</b>.<hr>
				An exception will be raised on failure or invalid arguments.</td></tr>	
			<tr><td><b>SqlProc_AllVariables</b></td>
				<td>SqlProc_AllVariables( object <i>BLOB</i> ) : <i>String</i></td>
				<td colspan="3">Returns a space delimited list of all Variable <b>symbolic names</b> declared by the given <b>SQL Procedure</b> object.<hr>
				An exception will be raised on failure or invalid argument.</td></tr>
			<tr><td><b>SqlProc_VarValue</b></td>
				<td>SqlProc_VarValue( var_name <i>String</i> , var_value <i>NULL</i> ) : <i>String</i><hr>
					SqlProc_VarValue( var_name <i>String</i> , var_value <i>Integer</i> ) : <i>String</i><hr>
					SqlProc_VarValue( var_name <i>String</i> , var_value <i>Double</i> ) : <i>String</i><hr>
					SqlProc_VarValue( var_name <i>String</i> , var_value <i>Text</i> ) : <i>String</i><hr>
					SqlProc_VarValue( var_name <i>String</i> , var_value <i>BLOB</i> ) : <i>String</i></td>
				<td colspan="3">Returns a properly formatted <b>Variable with Value</b> Text string.<hr>
				An exception will be raised on failure or invalid argument.</td></tr>
			<tr><td><b>SqlProc_RawSQL</b></td>
				<td>SqlProc_RawSQL( object <i>BLOB</i> ) : <i>String</i></td>
				<td colspan="3">Returns the <b>raw SQL Body</b> declared by the given <b>SQL Procedure</b> object.<hr>
				An exception will be raised on failure or invalid argument.</td></tr>
			<tr><td><b>SqlProc_CookedSQL</b></td>
				<td>SqlProc_CookedSQL( object <i>BLOB</i> ) : <i>String</i><hr>
					SqlProc_CookedSQL( object <i>BLOB</i> , vararg <i>String</i> ) : <i>String</i><hr>
					SqlProc_CookedSQL( object <i>BLOB</i> , vararg1 <i>String</i> [ , ... ] , varargN <i>String</i> ) : <i>String</i></td>
				<td colspan="3">Returns the <b>cooked SQL Body</b> declared by the given <b>SQL Procedure</b> object after applying all <b>Variable Values</b>.<br>
				<i>Note:</i> this function accepts from <b>0</b> to <b>16</b> well-formed <b>Variable with Value</b> arguments; declaring twice or more the same Variable is considered to be a fatal error.<hr>
				An exception will be raised on failure or invalid arguments.</td></tr>
			<tr><td><b>SqlProc_Execute</b></td>
				<td>SqlProc_Execute( object <i>BLOB</i> ) : <i>Integer</i><hr>
					SqlProc_Execute( object <i>BLOB</i> , vararg <i>String</i> ) : <i>Integer</i><hr>
					SqlProc_Execute( object <i>BLOB</i> , vararg1 <i>String</i> [ , ... ] , varargN <i>String</i> ) : <i>Integer</i></td>
				<td colspan="3">Executes the <b>cooked SQL Body</b> declared by the given <b>SQL Procedure</b> object after applying all <b>Variable Values</b>.<br>
				<i>Note:</i> this function accepts from <b>0</b> to <b>16</b> well-formed <b>Variable with Value</b> arguments; declaring twice or more the same Variable is considered to be a fatal error.<hr>
				Will return <b>1</b> on success, an exception will be raised on failure or invalid arguments.</td></tr>
			<tr><td><b>SqlProc_Exit</b></td>
				<td>SqlProc_Exit( <i>void</i> ) : <i>Integer</i><hr>
					StoredProc_Exit( <i>void</i> ) : <i>Integer</i></td>
				<td colspan="3">
					Will notify a pending <b>EXIT</b> request to <b>SqlProc_Execute()</b> or <b>StoredProc_Execute()</b>;
					the internal execution loop will immediately stop and exit after completing the current SQL statement from the SQL Body.<br><br>
				<i>Notes:</i><ol>
					<li>These functions are completely effectless outside the specific execution context of <b>SqlProc_Execute()</b> or <b>StoredProc_Execute()</b>.</li>
					<li><b>SqlProc_Exit()</b> and <b>StoredProc_Exit()</b> are just <i>alias names</i>.
				</ol>
				Will return <b>1</b> on success, an exception will be raised on failure.</td></tr>
			<tr><td><b>StoredProc_CreateTables</b></td>
				<td>StoredProc_CreateTables( <i>void</i> ) : <i>Boolean</i></td>
				<td colspan="3">Returns <b>TRUE</b> if the <b>Stored Procedures and Variables tables</b> have been succesfully created or if they already exist, otherwise <b>FALSE</b>.</td></tr>
			<tr><td><b>StoredProc_Register</b></td>
				<td>StoredProc_Register( name <i>String</i> , title <i>String</i> , object <i>BLOB</i> ) : <i>Boolean</i></td>
				<td colspan="3">Registers a permanent <b>Stored Procedure</b>:
				<ul>
					<li><b>name</b> is expected to <b>uniquely identify</b> the Stored Procedure.</li>
					<li><b>title</b> is expected to specify a short description of the Stored Procedure intended scopes.</li>
					<li><b>object</b> is expected to be a valid BLOB of the <b>SQL Procedure</b> type created by <b>SqlProc_FromText()</b> or <b>SqlProc_FromFile()</b>.</li>
				</ul><hr>
				Returns <b>TRUE</b> on success, otherwise <b>FALSE</b>.	An exception will be raised on invalid arguments.</td></tr>		
			<tr><td><b>StoredProc_Get</b></td>
				<td>StoredProc_Get( name <i>String</i> ) : <i>BLOB</i></td>
				<td colspan="3">Will return a <b>SQL Procedure</b> BLOB object from a <b>Stored Procedure</b>. <b>NULL</b> will be returned if the Stored Procedure does not exists.<hr>
				An exception will be raised on invalid arguments.</td></tr>		
			<tr><td><b>StoredProc_Delete</b></td>
				<td>StoredProc_Delete( name <i>String</i> ) : <i>Boolean</i></td>
				<td colspan="3">Will delete a <b>Stored Procedure</b>.<hr>
				Returns <b>TRUE</b> on success, otherwise <b>FALSE</b>. An exception will be raised on invalid arguments.</td></tr>		
			<tr><td><b>StoredProc_UpdateTitle</b></td>
				<td>StoredProc_UpdateTitle( name <i>String</i> , title <i>String</i> ) : <i>Boolean</i></td>
				<td colspan="3">Will change the <b>Title</b> on the given <b>Stored Procedure</b>.<hr>
				Returns <b>TRUE</b> on success, otherwise <b>FALSE</b>. An exception will be raised on invalid arguments.</td></tr>		
			<tr><td><b>StoredProc_UpdateSqlBody</b></td>
				<td>StoredProc_UpdateSqlBody( name <i>String</i> , object <i>BLOB</i> ) : <i>Boolean</i></td>
				<td colspan="3">Will change the <b>SQL Body</b> on the given <b>Stored Procedure</b>.<hr>
				Returns <b>TRUE</b> on success, otherwise <b>FALSE</b>. An exception will be raised on invalid arguments.</td></tr>	
			<tr><td><b>StoredProc_Execute</b></td>
				<td>StoredProc_Execute( name <i>String</i> ) : <i>Integer</i><hr>
					StoredProc_Execute( name <i>String</i> , vararg <i>String</i> ) : <i>Integer</i><hr>
					StoredProc_Execute( name <i>String</i> , vararg1 <i>String</i> [ , ... ] , varargN <i>String</i> ) : <i>Integer</i></td>
				<td colspan="3">Executes the given <b>Stored Procedure</b> after applying all <b>Variable Values</b>.<br>
				<i>Note:</i> this function accepts from <b>0</b> to <b>16</b> well-formed <b>Variable with Value</b> arguments; declaring twice or more the same Variable is considered to be a fatal error.<hr>
				Will return <b>1</b> on success, an exception will be raised on failure or invalid arguments.</td></tr>
			<tr><td><b>StoredVar_Register</b></td>
				<td>StoredVar_Register( name <i>String</i> , title <i>String</i> , value <i>NULL</i> ) : <i>Boolean</i><hr>
				    StoredVar_Register( name <i>String</i> , title <i>String</i> , value <i>Integer</i> ) : <i>Boolean</i><hr>
				    StoredVar_Register( name <i>String</i> , title <i>String</i> , value <i>Double</i> ) : <i>Boolean</i><hr>
				    StoredVar_Register( name <i>String</i> , title <i>String</i> , value <i>Text</i> ) : <i>Boolean</i><hr>
				    StoredVar_Register( name <i>String</i> , title <i>String</i> , value <i>BLOB</i> ) : <i>Boolean</i></td>
				<td colspan="3">Registers a permanent <b>Stored Variable</b>:
				<ul>
					<li><b>name</b> is expected to <b>uniquely identify</b> a Variable Name.</li>
					<li><b>title</b> is expected to specify a short description of the Stored Variable intended scopes.</li>
					<li><b>value</b> can be any data-type and will be automatically converted to its correspondined textual representation.</li>
				</ul><hr>
				Returns <b>TRUE</b> on success, otherwise <b>FALSE</b>.	An exception will be raised on invalid arguments.</td></tr>		
			<tr><td><b>StoredVar_Get</b></td>
				<td>StoredVar_Get( name <i>String</i> ) : <i>BLOB</i></td>
				<td colspan="3">Will return a <b>Variable with Value</b> string from a <b>Stored Variable</b>. <b>NULL</b> will be returned if the Stored Variable does not exists.<hr>
				An exception will be raised on invalid arguments.</td></tr>			
			<tr><td><b>StoredVar_GetValue</b></td>
				<td>StoredVar_GetValue( name <i>String</i> ) : <i>BLOB</i></td>
				<td colspan="3">Will return the <b>undecorated Value</b> string from a <b>Stored Variable</b>. <b>NULL</b> will be returned if the Stored Variable does not exists.<hr>
				An exception will be raised on invalid arguments.</td></tr>			
			<tr><td><b>StoredVar_Delete</b></td>
				<td>StoredVar_Delete( name <i>String</i> ) : <i>Boolean</i></td>
				<td colspan="3">Will delete a <b>Stored Variable</b>.<hr>
				Returns <b>TRUE</b> on success, otherwise <b>FALSE</b>. An exception will be raised on invalid arguments.</td></tr>		
			<tr><td><b>StoredVar_UpdateTitle</b></td>
				<td>StoredVar_UpdateTitle( name <i>String</i> , title <i>String</i> ) : <i>Boolean</i></td>
				<td colspan="3">Will change the <b>Title</b> on the given <b>Stored Variable</b>.<hr>
				Returns <b>TRUE</b> on success, otherwise <b>FALSE</b>. An exception will be raised on invalid arguments.</td></tr>		
			<tr><td><b>StoredVar_UpdateValue</b></td>
				<td>StoredVar_UpdateValue( name <i>String</i> , var_value <i>NULL</i> ) : <i>Boolean</i><hr>
				    StoredVar_UpdateValue( name <i>String</i> , var_value <i>Integer</i> ) : <i>Boolean</i><hr>
				    StoredVar_UpdateValue( name <i>String</i> , var_value <i>Double</i> ) : <i>Boolean</i><hr>
				    StoredVar_UpdateValue( name <i>String</i> , var_value <i>Text</i> ) : <i>Boolean</i><hr>
				    StoredVar_UpdateValue( name <i>String</i> , var_value <i>BLOB</i> ) : <i>Boolean</i></td>
				<td colspan="3">Will change the <b>Value</b> on the given <b>Stored Variable</b>.<hr>
				Returns <b>TRUE</b> on success, otherwise <b>FALSE</b>. An exception will be raised on invalid arguments.</td></tr>		
		</tbody></table>
		<br>
		<a href="https://www.gaia-gis.it/fossil/libspatialite">back</a>
		<br>
	</body></html>
